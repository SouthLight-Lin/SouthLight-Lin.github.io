<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="SouthLight&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="SouthLight&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SouthLight&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>SouthLight's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SouthLight's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/" itemprop="url">Spring-Mybatis把接口变成Bean的秘密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-16T23:48:08+08:00">
                2019-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们使用Spring+Mybatis做开发时，一般都会引入spring-mybatis这个包，这个包是mybatis自己开发的，它利用Spring的扩展接口将自己很好的整合在Spring中，下面就来说一下，我们定义的mapper接口，是怎么把它变成一个实际的对象然后存储在容器中的</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>我们先来准备下环境</p>
<h2 id="配置Spring环境"><a href="#配置Spring环境" class="headerlink" title="配置Spring环境"></a>配置Spring环境</h2><p>引入Spring包，引入mybatis包，引入Spring跟Mybatis整合的包，引入数据库连接驱动的包<br><img src="/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/20190217121626695.png" alt=""></p>
<h3 id="AppConfig-java，该类只是简单的配置了Bean的扫描包"><a href="#AppConfig-java，该类只是简单的配置了Bean的扫描包" class="headerlink" title="AppConfig.java，该类只是简单的配置了Bean的扫描包"></a>AppConfig.java，该类只是简单的配置了Bean的扫描包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.config;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.demo&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MybatisConfig-java，该类配置了数据库连接池和SQLSessionFactory，以及Mapper接口的扫描"><a href="#MybatisConfig-java，该类配置了数据库连接池和SQLSessionFactory，以及Mapper接口的扫描" class="headerlink" title="MybatisConfig.java，该类配置了数据库连接池和SQLSessionFactory，以及Mapper接口的扫描"></a>MybatisConfig.java，该类配置了数据库连接池和SQLSessionFactory，以及Mapper接口的扫描</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.config;</span><br><span class="line">import org.apache.ibatis.datasource.pooled.PooledDataSource;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.demo.dao&quot;)</span><br><span class="line">public class MybatisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        System.out.println(&quot;config datasoutce------&quot;);</span><br><span class="line">        DriverManagerDataSource dataSource = new DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/classsystem&quot;);</span><br><span class="line">        dataSource.setUsername(&quot;root&quot;);</span><br><span class="line">        dataSource.setPassword(&quot;root&quot;);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Autowired</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;</span><br><span class="line">        System.out.println(&quot;config SessionFactory-------&quot;);</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        return sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UserDao-java，写一个简单的接口，用于查询数据库"><a href="#UserDao-java，写一个简单的接口，用于查询数据库" class="headerlink" title="UserDao.java，写一个简单的接口，用于查询数据库"></a>UserDao.java，写一个简单的接口，用于查询数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.dao;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    @Select(&quot;select * from stu_info where id=1&quot;)</span><br><span class="line">    public List&lt;Map&lt;String,Object&gt;&gt; selectOne();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test-java最后写一个测试启动类"><a href="#Test-java最后写一个测试启动类" class="headerlink" title="Test.java最后写一个测试启动类"></a>Test.java最后写一个测试启动类</h3><p>Test.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.test;</span><br><span class="line"></span><br><span class="line">import com.demo.config.AppConfig;</span><br><span class="line">import com.demo.dao.UserDao;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext annotationConfigApplicationContext =</span><br><span class="line">                new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        annotationConfigApplicationContext.start();</span><br><span class="line">        //以下是测试Mybatis的代码</span><br><span class="line">        UserDao dao = annotationConfigApplicationContext.getBean(UserDao.class);</span><br><span class="line">        System.out.println(dao.selectOne());</span><br><span class="line">        System.out.println(&quot;---over----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来项目即可运行并输出</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>通过上面的小demo，我们可以通过UserDao的selectOne方法查询数据库，但是我有一个问题，为什么一个UserDao可以实例化？<br>我们输出从容器中得到的UserDao的类看下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserDao dao = annotationConfigApplicationContext.getBean(UserDao.class);</span><br><span class="line">System.out.println(annotationConfigApplicationContext.getBean(&quot;&amp;userDao&quot;));</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.mybatis.spring.mapper.MapperFactoryBean@6913c1fb</span><br></pre></td></tr></table></figure></p>
<p>看来，一个Mapper接口变成了一个MapperFactoryBean了<br>这里提出几个问题？<br>1、MapperFactoryBean是什么东西？<br>2、它是怎么进入容器，然后被Spring锁管理的？</p>
<h1 id="MapperFactoryBean是什么东西"><a href="#MapperFactoryBean是什么东西" class="headerlink" title="MapperFactoryBean是什么东西"></a>MapperFactoryBean是什么东西</h1><p>我们看下MapperFactoryBean的源码，发现它实现了Spring的FactoryBean</p>
<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>FactoryBean是Spring中特殊的Bean，它可以通过getObject方法生成指定的Bean属性。<br>当我们手动向Spring容器中注册BeanDefinition（简称BD） 时，可以设置BD为FactoryBean类型，这样在Spring中获取这个Bean时，就会使用FactoryBean的getObject创建Bean</p>
<h2 id="如何手动向Spring容器中注入BeanDefinition"><a href="#如何手动向Spring容器中注入BeanDefinition" class="headerlink" title="如何手动向Spring容器中注入BeanDefinition"></a>如何手动向Spring容器中注入BeanDefinition</h2><p>何为BeanDefinition？<br>BeanDefinition是Bean的描述，如果把Bean比作一道菜的话，那么BeanDefinition就是做这道菜的原料。在Spring中，Bean的创建是通过BeanDefinition来创建的，所有属性都包含在BeanDefinition中，比如单例模式，懒加载，类名，方法….<br>如何手动的向Spring中注册BD？<br>在Spring中，只要配置类实现了ImportBeanDefinitionRegistrar接口，就可直接向Spring中注册BD<br>org.springframework.context.annotation.ImportBeanDefinitionRegistrar<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line">import com.lnw.dao.Pear;</span><br><span class="line">import com.lnw.test.MyFactoryBean2;</span><br><span class="line">import org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line">import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line"> * 实现了该接口，就可参与Spring的Factory的建设</span><br><span class="line"> * 可以调用接口的实现方法直接添加BeanDefinition</span><br><span class="line"> */</span><br><span class="line"> @Configuration</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		BeanDefinition pear = BeanDefinitionBuilder.genericBeanDefinition(Pear.class).getBeanDefinition();</span><br><span class="line">		registry.registerBeanDefinition(&quot;pear&quot;, pear);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的话就可以自己手动的在Spring容器中添加一个Pear（梨）的Bean了</p>
<h2 id="继续刚才FactoryBean的话题"><a href="#继续刚才FactoryBean的话题" class="headerlink" title="继续刚才FactoryBean的话题"></a>继续刚才FactoryBean的话题</h2><p>如果我有两个类，Apple和Pear<br>我手动先容器中注册了Pear，我可以通过FactoryBean来改变Pear从而获取Apple<br>先编写一个类实现FactoryBean接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.test;</span><br><span class="line">import com.lnw.dao.Apple;</span><br><span class="line">import org.springframework.beans.factory.FactoryBean;</span><br><span class="line">public class MyFactoryBean2 implements FactoryBean &#123;</span><br><span class="line">	Class clazz;</span><br><span class="line">	MyFactoryBean2()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	MyFactoryBean2(Class clazz)&#123;</span><br><span class="line">		this.clazz = clazz;</span><br><span class="line">	&#125;</span><br><span class="line">	public Class getClazz() &#123;</span><br><span class="line">		return clazz;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setClazz(Class clazz) &#123;</span><br><span class="line">		this.clazz = clazz;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Object getObject() throws Exception &#123;</span><br><span class="line">		return  new Apple();</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		return clazz;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点就是getObject方法，它返回一个Apple对象</p>
<p>然后，我们手动注册一个Pear的BD，把它的类型改为我们规定的FactoryBean类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line">import com.lnw.dao.Pear;</span><br><span class="line">import com.lnw.test.MyFactoryBean2;</span><br><span class="line">import org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line">import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line"> * 实现了该接口，就可参与Spring的Factory的建设</span><br><span class="line"> * 可以调用接口的实现方法直接添加BeanDefinition</span><br><span class="line"> */</span><br><span class="line"> @Configuration</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		BeanDefinition pear = BeanDefinitionBuilder.genericBeanDefinition(Pear.class).getBeanDefinition();</span><br><span class="line">        // 将Bean的类型改为我们的FactoryBean，这样返回的就是Apple</span><br><span class="line">		((AbstractBeanDefinition) pear).setBeanClass(MyFactoryBean2.class);</span><br><span class="line">		registry.registerBeanDefinition(&quot;pear&quot;, pear);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们从容器中获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ac.getBean(&quot;pear&quot;).getClass());</span><br></pre></td></tr></table></figure></p>
<p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class com.lnw.dao.Apple</span><br></pre></td></tr></table></figure></p>
<p>这就是FactoryBean的功能和作用</p>
<h1 id="MapperScan注解"><a href="#MapperScan注解" class="headerlink" title="@MapperScan注解"></a>@MapperScan注解</h1><p>通过上面我们可以大概知道，spring-mybatis就是通过设置MapperFactoryBean解决从一个Mapper接口变成一个可实际操作的对象的过程<br>那MapperFactoryBean在哪里设置进去的呢？<br>答案就在我们的@MapperScan注解中<br>我们打开注解<br>@MapperScan<br><img src="/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/20190217125931918.png" alt=""><br>发现它引入了一个类：MapperScannerRegistrar<br>MapperScannerRegistrar.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware &#123;</span><br><span class="line">  private ResourceLoader resourceLoader;</span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    // this check is needed in Spring 3.1</span><br><span class="line">    if (resourceLoader != null) &#123;</span><br><span class="line">      scanner.setResourceLoader(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(&quot;annotationClass&quot;);</span><br><span class="line">    if (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(&quot;markerInterface&quot;);</span><br><span class="line">    if (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      scanner.setMarkerInterface(markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(&quot;nameGenerator&quot;);</span><br><span class="line">    if (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(&quot;factoryBean&quot;);</span><br><span class="line">    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; basePackages = new ArrayList&lt;String&gt;();</span><br><span class="line">    for (String pkg : annoAttrs.getStringArray(&quot;value&quot;)) &#123;</span><br><span class="line">      if (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (String pkg : annoAttrs.getStringArray(&quot;basePackages&quot;)) &#123;</span><br><span class="line">      if (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Class&lt;?&gt; clazz : annoAttrs.getClassArray(&quot;basePackageClasses&quot;)) &#123;</span><br><span class="line">      basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    // 扫描包并注册BD</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void setResourceLoader(ResourceLoader resourceLoader) &#123;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它实现了ImportBeanDefinitionRegistrar，代表它手动的向Spring中注册了BD<br>它里面还有一个扫描器，通过扫描器把mapper接口扫描出来，并设置为MapperFactoryBean类型我们直接看源码<br>org.mybatis.spring.mapper.ClassPathMapperScanner#doScan<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);</span><br><span class="line">    if (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      logger.warn(&quot;No MyBatis mapper was found in &apos;&quot; + Arrays.toString(basePackages) + &quot;&apos; package. Please check your configuration.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 处理扫描出来的BD</span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    for (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating MapperFactoryBean with name &apos;&quot; + holder.getBeanName() </span><br><span class="line">          + &quot;&apos; and &apos;&quot; + definition.getBeanClassName() + &quot;&apos; mapperInterface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // the mapper interface is the original class of the bean</span><br><span class="line">      // but, the actual class of the bean is MapperFactoryBean</span><br><span class="line">      /**</span><br><span class="line">      下面两句是核心</span><br><span class="line">          1、设置构造方法中的Class属性为接口的类属性，这样的话最后生成的Bean是Mapper接口的实现类</span><br><span class="line">          2、设置Bean的类型为MapperFactoryBean的类型，这样创建Bean的时候就会调用MapperFactoryBean的getObject方法创建对象</span><br><span class="line">      */</span><br><span class="line">      definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); // issue #59</span><br><span class="line">      definition.setBeanClass(this.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);</span><br><span class="line"></span><br><span class="line">      boolean explicitFactoryUsed = false;</span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = true;</span><br><span class="line">      &#125; else if (this.sqlSessionFactory != null) &#123;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = true;</span><br><span class="line">      &#125; else if (this.sqlSessionTemplate != null) &#123;</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!explicitFactoryUsed) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Enabling autowire by type for MapperFactoryBean with name &apos;&quot; + holder.getBeanName() + &quot;&apos;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很长，但是主要的就是中间那两句代码！第一句是设置产生的Bean的类型，通过构造方法传入；第二句是设置BD的类型为FactoryBean，这样才能在创建Bean的时候调用getObject方法<br>这样一来，Spring-Mybatis在getObject方法中，通过动态代理为Mapper接口创建代理对象，产生一个可操作的Bean，创建代理对象的过程以后再讨论。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们的@MapperScan注解，会引入MapperScannerRegistrar类，这个类实现了ImportBeanDefinitionRegistrar的底层Spring接口，这个接口可以手动的向Spring注册BD，Spring使用这个BD创建Bean。<br>但是在注册BD之前mybatis把BD的属性设置为MapperFactoryBean，MapperFactoryBean实现了Spring底层的FactoryBean，FactoryBean可以指定生成什么样的Bean。所以MapperFactoryBean的getObject方法中，通过传入接口的属性，使用动态代理技术创建一个实现了Mapper接口的代理对象</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/详解SpringMVC/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/详解SpringMVC/" itemprop="url">详解SpringMVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T15:06:13+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringMVC的本质"><a href="#SpringMVC的本质" class="headerlink" title="SpringMVC的本质"></a>SpringMVC的本质</h1><p>SpringMVC本质只是一个Servlet，Servlet的运行需要Servlet容器，常见的容器有Tomcat跟Jetty。Servlet的运行会调用一次init()跟一次destory()方法，用于初始化Servlet跟销毁Servlet。SpringMVC利用init()方法创建WebApplication的运行环境。（此时的WebApplication只是ServletWebApplicationContext，存储Controller、ViewResolver、HandlerMapping等）<br>所以SpringMVC的运行需要Servlet-api，而Servlet如Tomcat或者Jetty容器已经依赖了Servlet-api（如果是开发时使用插件形式，比如使用Tomcat插件，就需要手动引入）</p>
<h1 id="SpringMVC的前身——Servlet"><a href="#SpringMVC的前身——Servlet" class="headerlink" title="SpringMVC的前身——Servlet"></a>SpringMVC的前身——Servlet</h1><p>*注：下面关于Servlet来自一篇推文：<a href="https://mp.weixin.qq.com/s__biz=MzA4MjIyNTY0MQ==&amp;mid=2647739557&amp;idx=1&amp;sn=ffd844a61c842fdc6551a2e9d4dbaab9&amp;key=3ced8d6e9f21461a1452cf26cf0e495b3ba44084c1c66b8e318a5039b4502e115714558bdf8f1a95094fbe9bf322e08b5d5f62b091a46fa4293fa17528a4a855794f08c29486fd6fac84f294b5c19a34&amp;ascene=1&amp;uin=MTEyMjk5MTQyMw%3D%3D&amp;devicetype=Windows+10&amp;version=62060728&amp;lang=zh_CN&amp;pass_ticket=TONBS%2FY8dLqbPKMCi6vH0pFR1i222o7yZyVAlvO7Ve6%2BzCA0TO5GtC6Q69c5hJqf" target="_blank" rel="noopener">https://mp.weixin.qq.com/s__biz=MzA4MjIyNTY0MQ==&amp;mid=2647739557&amp;idx=1&amp;sn=ffd844a61c842fdc6551a2e9d4dbaab9&amp;key=3ced8d6e9f21461a1452cf26cf0e495b3ba44084c1c66b8e318a5039b4502e115714558bdf8f1a95094fbe9bf322e08b5d5f62b091a46fa4293fa17528a4a855794f08c29486fd6fac84f294b5c19a34&amp;ascene=1&amp;uin=MTEyMjk5MTQyMw%3D%3D&amp;devicetype=Windows+10&amp;version=62060728&amp;lang=zh_CN&amp;pass_ticket=TONBS%2FY8dLqbPKMCi6vH0pFR1i222o7yZyVAlvO7Ve6%2BzCA0TO5GtC6Q69c5hJqf</a></p>
<p>SpringMVC之前，就是Servlet。Spring MVC 是基于 Servlet 实现的。所以要分析 Spring MVC，首先应追根溯源，弄懂 Servlet。Servlet 是 J2EE 规范之一，在遵守该规范的前提下，我们可将 Web 应用部署在 Servlet 容器下。这样做的好处是什么呢？我觉得可使开发者聚焦业务逻辑，而不用去关心 HTTP 协议方面的事情。比如，普通的 HTTP 请求就是一段有格式的文本，服务器需要去解析这段文本才能知道用户请求的内容是什么。如果我们为了写一个 Web 应用，还要去解析 HTTP 协议相关的内容，那会增加很多工作量。</p>
<p>如果我们写的 Web 应用不大，不夸张的说，项目中对 HTTP 提供支持的代码会比业务代码还要多，这岂不是得不偿失。当然，在现实中，有现成的框架可用，并不需要自己造轮子。如果我们基于 Servlet 规范实现 Web 应用的话，HTTP 协议的处理过程就不需要我们参与了。这些工作交给 Servlet 容器就行了，我们只需要关心业务逻辑怎么实现即可。<br>Servlet的具体就是交给Servlet接口、ServletConfig、GenericServlet、HttpServlet这些类中实现，等有时间再详解。</p>
<h1 id="运行SpringMVC的前期准备"><a href="#运行SpringMVC的前期准备" class="headerlink" title="运行SpringMVC的前期准备"></a>运行SpringMVC的前期准备</h1><p>SpringMVC要运行需要Servlet，这里我们使用Tomcat插件作为Servlet容器，先引入Servlet的api,虽然Servlet-api在Tomcat插件呢中已经存在，但是SpringMVC在编译时需要Servlet-api的存在，不然编译不通过<br>哦对，在这之前需要引入Spring的包有context,web,webmvc 下面会说这几个包的作用<br>完整的pom.xml如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.demo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lnw-spring-mvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;lnw-spring-mvc Maven Webapp&lt;/name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project&apos;s website --&gt;</span><br><span class="line">    &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">		&lt;!--引入Servlet-api，然后scope设置为provided，表示编译时存在，运行时可去除</span><br><span class="line">		因为Tomcat中已经有Servlet-api了，运行时使用Tomcat里面的Servelt-Api就可以了--&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;lnw-spring-mvc&lt;/finalName&gt;</span><br><span class="line">        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">            &lt;plugins&gt;</span><br><span class="line">				&lt;!--添加Tomcat插件，设置路径和端口--&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">                    &lt;configuration&gt;</span><br><span class="line">                        &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">                        &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">                    &lt;/configuration&gt;</span><br><span class="line">                &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/plugins&gt;</span><br><span class="line">        &lt;/pluginManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong> 引入的Servlet-api需要设置scope为provide表示编译时存在，运行时去除 </strong><br>Servlet容器跟依赖包都有了，接下来就是要让SpringMVC整合到Tomcat中<br>以前都是在web.xml配置，因为你Tomcat启动时会读取web.xml中的配置来启动加载SpringMVC的DispatcherServlet，但我这里想用java-config来配置，因为java-config配置更加直观一点（个人观点）<br>我们用一个MyWebApplicationInitializer类表示一个web.xml配置，用AppConfig类来配置Spring<br>我的理解是MyWebApplicationInitializer可以让Tomcat发现SpringMVC的存在并注册DispatcherServlet，AppConfig可以配置Spring的容器以及其他Spring属性</p>
<p>MyWebApplicationInitializer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.config;</span><br><span class="line">import org.springframework.web.WebApplicationInitializer;</span><br><span class="line">import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;</span><br><span class="line">import org.springframework.web.servlet.DispatcherServlet;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletRegistration;</span><br><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext servletCxt) &#123;</span><br><span class="line">        System.out.println(&quot;------init------&quot;);</span><br><span class="line">        // Load Spring web application configuration</span><br><span class="line">        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        // 注册Spring的配置类</span><br><span class="line">        ac.register(AppConfig.class);</span><br><span class="line">        // ac.refresh();</span><br><span class="line">        // Create and register the DispatcherServlet</span><br><span class="line">        DispatcherServlet servlet = new DispatcherServlet(ac);</span><br><span class="line">        ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">        registration.setLoadOnStartup(1);</span><br><span class="line">        registration.addMapping(&quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/12/详解SpringMVC/20190212115408186.png" alt=""><br>这里的ac.refresh()之所以要注释掉，因为此时容器中还没有ServletContext，因为还没有将Tomcat容器中的ServletContext注入到Spring容器中，而SpringMVC中的有些组件需要ServletContext才能进行创建，如果此时没有ServletContext，在调用refresh时就会出现错误，显示“No ServletContext set”，比如resourceHandlerMapping这个Bean，在创建的时候就会进行断言<br>ServletContext的传入，在FrameworkServlet中，还没调用refresh前<br><img src="/2019/02/12/详解SpringMVC/20190213125005726.png" alt=""><br><img src="/2019/02/12/详解SpringMVC/20190213123002392.png" alt=""><br>只有设置了ServletContext，断言的时候才不会报错，如果没有把自己手写的ac.refresh注释掉，因为容器中没有ServletContext，项目时运行不了的<br>只有执行完FrameworkServlet里的initWebApplicationContext，设置了ServletContext，才能将SpringMVC进行刷新</p>
<ul>
<li>注：ServletContext 代表一个程序的应用，管理我们的Servlet，而且所有的Servlet都可以共享这个Context<br><img src="/2019/02/12/详解SpringMVC/20190213125530145.png" alt=""><br><img src="/2019/02/12/详解SpringMVC/20190213125703302.png" alt=""></li>
</ul>
<p>还有，我已经在一篇博客中讲过SpringMVC是怎么随着Tomcat中启动的，有兴趣可以去看下，为什么配置了一个MyWebApplicationInitializer，该类只是实现了WebApplicationInitializer就可以随着Tomcat启动（很有趣的哦）</p>
<p>AppConfig.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.lnw&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class AppConfig&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppConfig类就只是一个普通的Spring配置类，标明扫描包的路径，开启SpringMVC的注解</p>
<h2 id="这里为什么要加-EnableWebMVC注解呢？"><a href="#这里为什么要加-EnableWebMVC注解呢？" class="headerlink" title="这里为什么要加@EnableWebMVC注解呢？"></a>这里为什么要加@EnableWebMVC注解呢？</h2><p>这个问题很重要！<br>加上@EnableWebMVC注解，会在Spring容器中引入一个DelegatingWebMvcConfiguration类，这个类又继承自WebMvcConfigurationSupport类<br>WebMvcConfigurationSupport里面配置了需要SpringMVC的许多默认选项，比如SpringMVC的九大组件，大多都是在这个类中默认配置（除了文件上传的那个组件好像没有默认配置）<br>WebMvcConfigurationSupport类里面配置了很多SpringMVC许多组件默认的Bean，截取相关代码<br>WebMvcConfigurationSupport.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   @Bean</span><br><span class="line">public BeanNameUrlHandlerMapping beanNameHandlerMapping() &#123;</span><br><span class="line">	BeanNameUrlHandlerMapping mapping = new BeanNameUrlHandlerMapping();</span><br><span class="line">	mapping.setOrder(2);</span><br><span class="line">	mapping.setInterceptors(getInterceptors());</span><br><span class="line">	mapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">	return mapping;</span><br><span class="line">&#125;</span><br><span class="line">   @Bean</span><br><span class="line">public ViewResolver mvcViewResolver() &#123;</span><br><span class="line">	ViewResolverRegistry registry = new ViewResolverRegistry(</span><br><span class="line">			mvcContentNegotiationManager(), this.applicationContext);</span><br><span class="line">	configureViewResolvers(registry);</span><br><span class="line"></span><br><span class="line">	if (registry.getViewResolvers().isEmpty() &amp;&amp; this.applicationContext != null) &#123;</span><br><span class="line">		String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				this.applicationContext, ViewResolver.class, true, false);</span><br><span class="line">		if (names.length == 1) &#123;</span><br><span class="line">			registry.getViewResolvers().add(new InternalResourceViewResolver());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ViewResolverComposite composite = new ViewResolverComposite();</span><br><span class="line">	composite.setOrder(registry.getOrder());</span><br><span class="line">	composite.setViewResolvers(registry.getViewResolvers());</span><br><span class="line">	if (this.applicationContext != null) &#123;</span><br><span class="line">		composite.setApplicationContext(this.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	if (this.servletContext != null) &#123;</span><br><span class="line">		composite.setServletContext(this.servletContext);</span><br><span class="line">	&#125;</span><br><span class="line">	return composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，加了@EnableWebMVC的注解，引入WebMVCConfigurationSupport类，创建配置类，Spring容器中就会有了许多SpringMVC组件的默认配置的Bean，然后在SpringMVC的DispatcherServlet中，需要组件初始化的时候就可以从Spring容器中获取这些默认的Bean</p>
<p>这样一来，运行添加的Tomcat插件（Tomcat版本最高为7…) ，就可顺利运行SpringMVC项目<br>如果想配置SpringMVC的其他属性，比如静态资源，模板引擎，文件上传的大小..<br>需要声明一个配置类，实现WebMvcConfigurer类，重写里面的方法即可</p>
<h1 id="SpringMVC运行的初始化"><a href="#SpringMVC运行的初始化" class="headerlink" title="SpringMVC运行的初始化"></a>SpringMVC运行的初始化</h1><p>SpringMVC的运行，离不开九大组件，而且SpringMVC的本质就是一个Servlet，所以在Tomcat启动的时候就会调用Init方法对Servlet的方法进行初始化<br>这里就要说一下SpringMVC的三个Servlet<br><img src="/2019/02/12/详解SpringMVC/20190213115117039.png" alt=""><br>红线上部分是Servlet的类，下部分是SpringMVC的三个Servlet（哎，反正就是一个Servlet）<br>所以注册Servlet的时候就会调用Servlet的init方法</p>
<h2 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h2><p>先执行HTTPServletBean的init方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * init()中，首先将Servlet中的配置参数使用BeanWrapper设置到DispatcherServlet的相关属性</span><br><span class="line">	 * 然后调用模板方法initServletBean()初始化</span><br><span class="line">	 */</span><br><span class="line">	public final void init() throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">		// 将Servlet中的配置参数封装到pvs中</span><br><span class="line">		// Set bean properties from init parameters.</span><br><span class="line">		PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);</span><br><span class="line">		if (!pvs.isEmpty()) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				// bw为DispatcherServlet</span><br><span class="line">				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</span><br><span class="line">				ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());</span><br><span class="line">				bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">				// 模板方法，可以在子类调用，做一些初始化工作，bw就是DispatcherServlet，</span><br><span class="line">				// 也就是初始化DispatcherServlet</span><br><span class="line">				initBeanWrapper(bw);</span><br><span class="line">				// 将配置的初始值（如contextConfigLocation)设置到DispaterServlet</span><br><span class="line">				bw.setPropertyValues(pvs, true);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isErrorEnabled()) &#123;</span><br><span class="line">					logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Let subclasses do whatever initialization they like.</span><br><span class="line">		// 一般都是FrameWorkServlet的初始化入口</span><br><span class="line">		initServletBean();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>然后调用FrameworkServlet的<strong> initServletBean </strong> 方法，但是<strong> initServlet </strong> 方法中，又调用<strong> initWebApplicationContext（）</strong> 方法初始化容器，所以FrameworkServlet的关键初始话方法就是<strong> initWebApplicationContext() </strong> 方法了<br>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext initWebApplicationContext() &#123;</span><br><span class="line">		/*----------------------------------------------------------*/</span><br><span class="line">		// initWebApplicationContext方法主要做了三件事：</span><br><span class="line">			// 1、获取spring的根容器rootContext</span><br><span class="line">			// 2、设置webApplicationContext并根据情况调用refresh方法</span><br><span class="line">			// 3、将webApplicationContext设置到Servlet中</span><br><span class="line">		/*----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">		// 1</span><br><span class="line">		WebApplicationContext rootContext =</span><br><span class="line">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">		WebApplicationContext wac = null;</span><br><span class="line"></span><br><span class="line">		if (this.webApplicationContext != null) &#123;</span><br><span class="line">			// A context instance was injected at construction time -&gt; use it</span><br><span class="line">			wac = this.webApplicationContext;</span><br><span class="line">			if (wac instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">				if (!cwac.isActive()) &#123;</span><br><span class="line">					// The context has not yet been refreshed -&gt; provide services such as</span><br><span class="line">					// setting the parent context, setting the application context id, etc</span><br><span class="line">					if (cwac.getParent() == null) &#123;</span><br><span class="line">						// The context instance was injected without an explicit parent -&gt; set</span><br><span class="line">						// the root application context (if any; may be null) as the parent</span><br><span class="line">						cwac.setParent(rootContext);</span><br><span class="line">					&#125;</span><br><span class="line">					// 2</span><br><span class="line">					configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (wac == null) &#123;</span><br><span class="line">			// No context instance was injected at construction time -&gt; see if one</span><br><span class="line">			// has been registered in the servlet context. If one exists, it is assumed</span><br><span class="line">			// that the parent context (if any) has already been set and that the</span><br><span class="line">			// user has performed any initialization such as setting the context id</span><br><span class="line">			wac = findWebApplicationContext();</span><br><span class="line">		&#125;</span><br><span class="line">		if (wac == null) &#123;</span><br><span class="line">			// No context instance is defined for this servlet -&gt; create a local one</span><br><span class="line">			wac = createWebApplicationContext(rootContext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!this.refreshEventReceived) &#123;</span><br><span class="line">			// Either the context is not a ConfigurableApplicationContext with refresh</span><br><span class="line">			// support or the context injected at construction time had already been</span><br><span class="line">			// refreshed -&gt; trigger initial onRefresh manually here.</span><br><span class="line">			synchronized (this.onRefreshMonitor) &#123;</span><br><span class="line">				//2</span><br><span class="line">				onRefresh(wac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (this.publishContext) &#123;</span><br><span class="line">			// 3</span><br><span class="line">			// Publish the context as a servlet context attribute.</span><br><span class="line">			String attrName = getServletContextAttributeName();</span><br><span class="line">			getServletContext().setAttribute(attrName, wac);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return wac;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>webApplicationContext在我们的配置类中已经注册给DispatcherServlet，DispatcherServlet又把WebApplication交给FrameworkServlet，所以这里会执行<strong> configureAndRefreshWebApplicationContext(cwac) </strong> 方法<br>如果没有webApplicationContext则SpringMVC自己创建createWebApplicationContext()，内部也是调用configureAndRefreshWebApplicationContext方法</p>
<p>org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) &#123;</span><br><span class="line">		if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">			// The application context id is still set to its original default value</span><br><span class="line">			// -&gt; assign a more useful id based on available information</span><br><span class="line">			if (this.contextId != null) &#123;</span><br><span class="line">				wac.setId(this.contextId);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// Generate default id...</span><br><span class="line">				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">						ObjectUtils.getDisplayString(getServletContext().getContextPath()) + &apos;/&apos; + getServletName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 设置ServletContext容器，这很重要，九大组件的创建需要ServletContext</span><br><span class="line">		wac.setServletContext(getServletContext());</span><br><span class="line">		// 设置ServletConfig</span><br><span class="line">		wac.setServletConfig(getServletConfig());</span><br><span class="line">		wac.setNamespace(getNamespace());</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 这里添加了一个监听器，这个监听器很重要</span><br><span class="line">		 * 监听的是ContextRefreshListener事件，也就是容器刷新时的事件</span><br><span class="line">		 * 当发生刷新容器事件时，会调用FrameworkServlet的onApplicationEvent方法</span><br><span class="line">		 * 该方法里面就会调用onRefresh（）进行初始化九大组件</span><br><span class="line">		 */</span><br><span class="line">		wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">		// The wac environment&apos;s #initPropertySources will be called in any case when the context</span><br><span class="line">		// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span><br><span class="line">		// use in any post-processing or initialization that occurs below prior to #refresh</span><br><span class="line">		ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">		if (env instanceof ConfigurableWebEnvironment) &#123;</span><br><span class="line">			((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		postProcessWebApplicationContext(wac);</span><br><span class="line">		applyInitializers(wac);</span><br><span class="line">		// 刷新容器</span><br><span class="line">		wac.refresh();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里最重要的就是添加了ContextRefreshListener监听器，这个监听器很重要，在代码的最后调用<strong> wac.refresh </strong> 刷新后，会执行这个ContextRefreshListener监听器触发事件<br>ContextRefreshListener是Framework的内部类里面只有一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">			FrameworkServlet.this.onApplicationEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>onApplicationEvent方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">		this.refreshEventReceived = true;</span><br><span class="line">		synchronized (this.onRefreshMonitor) &#123;</span><br><span class="line">			onRefresh(event.getApplicationContext());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是当发生容器的刷新时，最后会执行<strong> onRefresh </strong> 方法，该方法在DispatcherServlet具体实现</p>
<ul>
<li>注：wac.refresh() 方法就是Spring-Context的知识，也就是IOC，Bean的生成管理等，这里不深入阐述<br>来看下DispatcherServlet</li>
</ul>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>上面说到当发生刷新容器的事件时，会调用<strong> onRefresh </strong> 方法，该方法在DispatcherServlet中具体实现，而里面只是调用了<strong> initStrategies </strong> 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected void onRefresh(ApplicationContext context) &#123;</span><br><span class="line">		// 只执行了initStrategies方法</span><br><span class="line">		initStrategies(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected void initStrategies(ApplicationContext context) &#123;</span><br><span class="line">		// 初始化MultipartResolver组件</span><br><span class="line">		// 该组件是用来处理上传文件请求，只是没有默认实现</span><br><span class="line">		initMultipartResolver(context);</span><br><span class="line">		// 初始化LocaleResolver</span><br><span class="line">		// 该组件的作用是可以通过request解析出Locale，Locale是对当前区域的声明</span><br><span class="line">		initLocaleResolver(context);</span><br><span class="line">		// 初始化ThemeResolver</span><br><span class="line">		// 该组件的作用是可以通过request解析出Theme主题</span><br><span class="line">		initThemeResolver(context);</span><br><span class="line">		// 初始化HandlerMapping组件</span><br><span class="line">		// 该组件的作用是存储URL跟Controller之间的映射</span><br><span class="line">		initHandlerMappings(context);</span><br><span class="line">		// 初始化HandlerAdapters</span><br><span class="line">		// 该组件的作用是可以用Handler（Controller）执行请求</span><br><span class="line">		initHandlerAdapters(context);</span><br><span class="line">		// 初始化HandlerExceptionResolvers组件</span><br><span class="line">		// 该组件的作用是对页面渲染前的异常进行处理。然后渲染在View里面</span><br><span class="line">		initHandlerExceptionResolvers(context);</span><br><span class="line">		// 初始化RequestToViewNamTranslator组件</span><br><span class="line">		// 该组件的作用是，如果Controller没有返回值，则通过request确定ViewName值,然后查询View</span><br><span class="line">		initRequestToViewNameTranslator(context);</span><br><span class="line">		// 初始化ViewResolvers组件</span><br><span class="line">		// 该组件的作用是将String类型的视图名和Locale解析为View类型的视图</span><br><span class="line">		initViewResolvers(context);</span><br><span class="line">		// 初始化FlashMapManager组件</span><br><span class="line">		// 该组件的作用是用于管理FlashMap的</span><br><span class="line">		initFlashMapManager(context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，SpringMVC的初始化就到这了，下面来看下当一个请求过来时，SpringMVC是怎么工作的</p>
<h1 id="SpringMVC对请求的处理过程"><a href="#SpringMVC对请求的处理过程" class="headerlink" title="SpringMVC对请求的处理过程"></a>SpringMVC对请求的处理过程</h1><p>我们事先写一个Controller<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;Hello Tomcat!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来具体跟踪一下，当我们输入请求localhost:8080/hello，SpringMVC里面是怎么处理的</p>
<h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><p>首先，请求会先到达Tomcat，Tomcat会分配一个Socket线程来连接它，接着封装request和response，然后交给具体的Servlet，这里就是使用我们的DispatcherServlet，所以请求就从Servlet容器（Tomcat）传递到Servlet     （发生在：Servlet容器）</p>
<h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><p>接着，HttpServlet先处理，在service方法中，将ServletRequest和ServletResponse转换成HttpServletRequest和HttpServletResponse，并调用service方法  （发生在：Servlet-api的HttpServlet中）</p>
<h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>接下来SpringMVC出场了，FrameworkServlet的service首先处理，但是，service方法又会将请求先交给HttpServlet的service处理  （发生在：FrameworkServlet）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 实现了HttpServlet的service方法</span><br><span class="line">	 * 不管是什么请求，最后都会走processRequest方法</span><br><span class="line">	 * Override the parent class implementation in order to intercept PATCH requests.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void service(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		// 添加了对PATCH请求的处理</span><br><span class="line">		HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">		if (httpMethod == HttpMethod.PATCH || httpMethod == null) &#123;</span><br><span class="line">			processRequest(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		// 其他类型全部交给父类处理，也就是交给HttpServlet处理</span><br><span class="line">		// 但是由于FrameworkServlet重写了get，post，put等请求方法，最后还是会调用该类的</span><br><span class="line">		// 其他请求方法比如doGet()</span><br><span class="line">		else &#123;</span><br><span class="line">			super.service(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		// 反正不管是什么方法，最后都会走processRequest方法</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><p>在HttpServlet的service方法中，会根据请求的类型将请求传递到doGet方法  （发生在：HttpServlet中）</p>
<h2 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h2><p>由于FrameworkServlet实现了doGet方法，所以请求又回到了FrameworkServlet中，而doGet方法中只调用了<strong> processRequest </strong> 方法。这里需要说明一下，几乎所有的请求都会交给<strong> processRequest </strong> 方法处理<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected final void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	protected final void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p><strong> processRequest </strong> 里面有调用 <strong> doService </strong> 方法，该方法在DispatcherServlet中具体实现，也就是说最后将请求交给了DispatcherServlet （发生在FrameworkServlet中）</p>
<h2 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h2><p>DispatcherServlet的doService方法将webApplicationContext、localeResolver、themeResolver、outputFlashMap和FlashMapManager设置到了request属性中，然后将请求交给doDispatch方法中  （发生在：DispatcherServlet）<br>org.springframework.web.servlet.DispatcherServlet#doService<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		logRequest(request);</span><br><span class="line">		// 对include请求，进行request的attribute做快照备份</span><br><span class="line">		Map&lt;String, Object&gt; attributesSnapshot = null;</span><br><span class="line">		if (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">			attributesSnapshot = new HashMap&lt;&gt;();</span><br><span class="line">			Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">			while (attrNames.hasMoreElements()) &#123;</span><br><span class="line">				String attrName = (String) attrNames.nextElement();</span><br><span class="line">				if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">					attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 对request设置一些属性，在handler和view中需要使用到</span><br><span class="line">		// Make framework objects available to handlers and view objects.</span><br><span class="line">		request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">		request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</span><br><span class="line">		request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);</span><br><span class="line">		request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line">		if (this.flashMapManager != null) &#123;</span><br><span class="line">			// 都跟FlashMap 有关，主要作用域redirect转发时参数的传递</span><br><span class="line">			// 应用场景：</span><br><span class="line">			// 			当你提交完订单后，需要重定向到一个页面，但是重定向无法传递参数过去</span><br><span class="line">			//			这时，你可以使用FlashMap帮助你完成参数的传递</span><br><span class="line"></span><br><span class="line">			// 每次处理请求时，都会先判断一下FlashMap中是否有数据</span><br><span class="line">			// 如果有就先设置到 inputFlashMap里面，也就是保存上次转发过来的属性</span><br><span class="line">			// 再设置到Model里面</span><br><span class="line">			FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">			if (inputFlashMap != null) &#123;</span><br><span class="line">				request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">			&#125;</span><br><span class="line">			// OUTPUT_FLASH_MAP_ATTRIBUTE用于保存本次请求需要转发的属性</span><br><span class="line">			request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());</span><br><span class="line">			request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 最后将请求交给doDispatch</span><br><span class="line">			doDispatch(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				// Restore the original attribute snapshot, in case of an include.</span><br><span class="line">				// 还原request的快照属性</span><br><span class="line">				if (attributesSnapshot != null) &#123;</span><br><span class="line">					restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7、"><a href="#7、" class="headerlink" title="7、"></a>7、</h2><p>doDispatch是DispatcherServlet中最重要的方法，里面有很多判断和操作，但是主要有四个功能。在此之前先说下Handler、HandlerMapping跟HandlerAdapter三者之间的关系，还有View跟ViewResolver</p>
<h3 id="Handler、HandlerMapping跟HandlerAdapter"><a href="#Handler、HandlerMapping跟HandlerAdapter" class="headerlink" title="Handler、HandlerMapping跟HandlerAdapter"></a>Handler、HandlerMapping跟HandlerAdapter</h3><p>Handler：就是我们编写的Controller控制器<br>HandlerMapping：可以用来速查Handler，可以根据request返回HandlerExecutionChain，HandlerExecutionChain里面包含Handler跟Interceptor<br>HandlerAdapter：当要执行我们的Controller时，SpringMVC就会使用HandlerAdapter来执行，调用handle方法，执行完返回ModelAndView<br>我们可以这样理解，Handler就是工具，可以用来做某件事；HandlerMapping是存放工具的清单，标明了工具放在哪里；HandlerAdapter就是使用工具干活的工人。</p>
<h3 id="View跟ViewResolver"><a href="#View跟ViewResolver" class="headerlink" title="View跟ViewResolver"></a>View跟ViewResolver</h3><p>View是用来展示数据的<br>ViewResolver是用来查找View的<br>做完请求工作后，需要返回结果，而返回结果就需要模板，View就是所需的模板，ViewResolver就是用来选择哪个模板</p>
<p>这四个功能分别为：一、使用HandlerMapping找到可以干活的Handler； 二、找到合适的HandlerAdapter让他去干活； 三、让HandlerAdapter开始干活，干完活后返回数据； 四、将返回的数据进行处理，封装成View展示给用户<br>先来看下doDispatch方法的代码，具体代码再分析<br>org.springframework.web.servlet.DispatcherServlet#doDispatch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		/**</span><br><span class="line">		 *</span><br><span class="line">		 *   doDispatch中最重要的代码总共有四句（见下面的标签数字）</span><br><span class="line">		 *</span><br><span class="line">		 *   Handler、HandlerMapping、HandlerAdapter三者的关系：</span><br><span class="line">		 *   	Handler：就是我们的控制器Controller中加了@XXXMapping的方法</span><br><span class="line">		 *   	HandlerMapping：	用来快速查找Handler</span><br><span class="line">		 *   	HandlerAdapter：调用Handler来干活，而且不同Handler需要不同的Adapter</span><br><span class="line">		 *   这就好比HandlerAdapter是工人，Handler是工具，HandlerMapping是根据加工的需求来选择用什么设备</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 封装Request，如果不是上传请求则直接使用接收到的request</span><br><span class="line">		 * 如果是上传请求，重新封装成MultipartHttpServletRequest</span><br><span class="line">		 */</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		/**</span><br><span class="line">		 * 处理请求的处理器链</span><br><span class="line">		 * 包含有处理器Handler和对应的拦截器Interceptor</span><br><span class="line">		 */</span><br><span class="line">		HandlerExecutionChain mappedHandler = null;</span><br><span class="line">		/**</span><br><span class="line">		 * 是否为上传请求的标记</span><br><span class="line">		 */</span><br><span class="line">		boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 从request中获取异步请求</span><br><span class="line">		 */</span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			/**</span><br><span class="line">			 * View 跟 ViewResolver</span><br><span class="line">			 * View 是用来展示数据的</span><br><span class="line">			 * 而ViewResolver是用来查找View的</span><br><span class="line">			 * 做完请求工作后，需要返回结果，而返回结果就需要模板，</span><br><span class="line">			 * View就是所需要的模板，ViewResolver就是来选择哪个模板</span><br><span class="line">			 *</span><br><span class="line">			 * **/</span><br><span class="line">			ModelAndView mv = null;</span><br><span class="line">			/**</span><br><span class="line">			 * 异常声明</span><br><span class="line">			 * doDispatch()中对异常又两种处理方法：</span><br><span class="line">			 * 		一、如果是处理请求中出现的异常，会捕获并在processDispatchResult中渲染到最后的视图中</span><br><span class="line">			 * 		二、如果是渲染中出现异常，则直接抛出</span><br><span class="line">			 */</span><br><span class="line">			Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// 检查是不是上传请求</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">				/** 第一句</span><br><span class="line">				 *  使用HandlerMapping找到可以干活的Handler</span><br><span class="line">				 *</span><br><span class="line">				 * **/</span><br><span class="line">				// Determine handler for the current request.</span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				if (mappedHandler == null) &#123;</span><br><span class="line">					// 找不到Handler返回404</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 第二句</span><br><span class="line">				 * 	找到合适的HandlerAdapter去让他干活</span><br><span class="line">				 * **/</span><br><span class="line">				// Determine handler adapter for the current request.</span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// 处理GET、HEAD请求的last-modified</span><br><span class="line">				// Process last-modified header, if supported by the handler.</span><br><span class="line">				/**</span><br><span class="line">				 * Last-Modified是HTTP头部的一种属性，表示当前请求的资源跟上一次请求的资源是否相同</span><br><span class="line">				 * 如果相同，返回304并且没有新的实体（body)返回</span><br><span class="line">				 * 否则返回新的实体内容</span><br><span class="line">				 *</span><br><span class="line">				 * 在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是客户端请求的资源，</span><br><span class="line">				 * 同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</span><br><span class="line">				 * 客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过</span><br><span class="line">				 * 如果服务器端的资源没有变化，则自动返回 HTTP 304（Not Changed.）状态码，内容为空，这样就节省了传输数据量。</span><br><span class="line">				 * 当服务器端代码发生改变或者重启服务器时，则重新发出资源，</span><br><span class="line">				 * 返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</span><br><span class="line">				 */</span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">				if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 如果有拦截器，就饿执行我们的拦截器，preHandle前置处理**/</span><br><span class="line">				if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 第三句</span><br><span class="line">				 * 	让HandlerAdapter开始干活，干完活后返回数据</span><br><span class="line">				 * **/</span><br><span class="line">				// Actually invoke the handler.</span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// 如果需要异步处理，则直接返回</span><br><span class="line">				/**</span><br><span class="line">				 * 因为异步处理会重新开启一个线程去执行结果的返回</span><br><span class="line">				 * 不会占用目前这个线程，所以可以直接返回</span><br><span class="line">				 */</span><br><span class="line">				if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 当view为空时（比如，handler返回类型为void），根据request设置默认view</span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line">				/** 执行了拦截器的后置处理 postHandle**/</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				dispatchException = ex;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable err) &#123;</span><br><span class="line">				// As of 4.3, we&apos;re processing Errors thrown from handler methods as well,</span><br><span class="line">				// making them available for @ExceptionHandler methods and other scenarios.</span><br><span class="line">				dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);</span><br><span class="line">			&#125;</span><br><span class="line">			/** 第四句</span><br><span class="line">			 * 	将数据处理，通过View展示给用户</span><br><span class="line">			 * 	处理结果，包括处理异常，渲染页面，发出完成通知，触发拦截器的afterCompletion</span><br><span class="line">			 * **/</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable err) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">					new NestedServletException(&quot;Handler processing failed&quot;, err));</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			// 判断是否为异步请求</span><br><span class="line">			if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				// 执行异步的拦截器</span><br><span class="line">				// Instead of postHandle and afterCompletion</span><br><span class="line">				if (mappedHandler != null) &#123;</span><br><span class="line">					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// 删除上传请求的资源，不然会产生临时的资源</span><br><span class="line">				// Clean up any resources used by a multipart request.</span><br><span class="line">				if (multipartRequestParsed) &#123;</span><br><span class="line">					cleanupMultipart(processedRequest);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="8、"><a href="#8、" class="headerlink" title="8、"></a>8、</h2><p>getHandler方法获取Handler的过程，会遍历容器中所有的HandlerMapping，上面说到的WebMVCConfigurationSupport会默认创建RequestMappingHandlerMapping和BeanNameUrlHandlerMapping，在用RequestMappingHandlerMapping匹配时，我们的请求会和其初始化时读取到定义的@RequestMapping(“hello”)所注解里面的内容相匹配，然后根据这个条件找到定义的处理器方法，也就是我们的hello()方法<br> （发生在：RequestMappingHandlerMapping）<br> org.springframework.web.servlet.DispatcherServlet#getHandler<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	if (this.handlerMappings != null) &#123;</span><br><span class="line">		for (HandlerMapping mapping : this.handlerMappings) &#123;</span><br><span class="line">			HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">			if (handler != null) &#123;</span><br><span class="line">				return handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="9、"><a href="#9、" class="headerlink" title="9、"></a>9、</h2><p> 如果是使用@PathVariable注解，则会使用RequestMappingInfoHandlerMapping里的handleMatch方法会将匹配到的Pattern设置到Request属性中，这里我们没有使用@PathVariable，所以跳过</p>
<h2 id="10、"><a href="#10、" class="headerlink" title="10、"></a>10、</h2><p> 找到Handler后，接着调用getHandlerAdapter方法根据Handler查找HandlerAdapter，也就是根据工具找到工人。查找的方式也是遍历配置的所有HandlerAdapter，然后分别调用他们的supports方法进行检查，判断Handler的类型是否支持。WebMvcConfigrationSupport类默认配置的HandlerAdapter是RequestMappingHandlerAdapter、HttpRequstHandlerAdapter和SimpleControllerHandlerAdapter，最后找到RequestMappingHandlerAdapter （发生在：DispatcherServlet）</p>
<h2 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h2><p> 接下来检查到请求时GET请求，然后检查是否可以使用缓存（我那一大段注释可以看看），因为是第一次请求，所以不使用缓存；接着调用HandlerInterceptor的preHandler方法，这里我们没有配置拦截器，所以跳过。接下来用RequestMappingHandlerAdapter使用Handler处理请求，也就是调用 mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  （发生在：DispatcherServlet中）</p>
<h2 id="12、"><a href="#12、" class="headerlink" title="12、"></a>12、</h2><p> HandlerAdapter的实现一般都很复杂，因为它要封装参数，参数有ModelAttribute，SessionAttributes，FlashMap，Request中的参数等等，所以RequestMappingHandlerAdapter会先将需要的参数封装，这里我们没有设置参数，可省略，接着讲请求传递给invokeHandleMethod方法 （发生在：RequestMappingHandlerAdapter）</p>
<h2 id="13、"><a href="#13、" class="headerlink" title="13、"></a>13、</h2><p>invokeHandleMethod方法首先创建WebDataBinderFactory、ModelFactory和ServletInvocableHandlerMethod。<br>WebDataBinderFactory跟@InitBinder注解的绑定参数有关<br>ModelFactory主要是对Model的初始化和更新<br>ServletInvocableHandlerMethod就是执行请求，参数的绑定<br> 而且，不同类型的参数的解析器是不同的，比如@PathVariable参数、RedirectAttributes参数、Model里的参数分别对应PathVariableMethodArgumentResolver、RedirectAttributeMethodArgumentResolver和ModelMethodProcessor<br> 具体执行在doInvoke中<br> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">protected ModelAndView invokeHandlerMethod(HttpServletRequest request,</span><br><span class="line">		HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	ServletWebRequest webRequest = new ServletWebRequest(request, response);</span><br><span class="line">	try &#123;</span><br><span class="line">		// 需要下面这三个工具</span><br><span class="line">		// WebDataBinderFactory的创建过程是将注解了@InitBinder的方法找出来，并</span><br><span class="line">			// 使用它们新建出ServletRequestDataBinderFactory类型的WebDataBinderFactory</span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line"></span><br><span class="line">		// ModelFactory主要有两个功能：一、在处理器具体处理前对Model进行初始化</span><br><span class="line">									//二、处理完请求后对Model参数进行更新</span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">		// 实际请求的处理就是通过它来执行的， 参数的绑定、处理请求以及返回值处理都在它里边完成</span><br><span class="line">		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line"></span><br><span class="line">		// 将argumentsResolvers、returnValueHandlers、binderFactory</span><br><span class="line">		// paramterNameDiscoverer设置进去invocableMethod中</span><br><span class="line">		if (this.argumentResolvers != null) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.returnValueHandlers != null) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">		// 新建ModelAndViewContainer容器， 并将相应的参数设置到Model中</span><br><span class="line">		ModelAndViewContainer mavContainer = new ModelAndViewContainer();</span><br><span class="line">		// 设置FlashMap</span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">		// 使用ModelFactory将SessionAttribute和注释了@ModelAttribute的方法的参数设置到Model</span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">		//</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">		// 异步处理的相关工作</span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(this.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(this.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(this.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		if (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">				String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">				return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;</span><br><span class="line">			&#125;);</span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 执行请求</span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 处理完请求的后置处理</span><br><span class="line">		return getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="14、"><a href="#14、" class="headerlink" title="14、"></a>14、</h2><p> 当执行完HandlerMethod（也就是执行完我们的Controller代码后），调用getModelAndView方法（我们代码执行完后的数据都设置在ModelAndViewContainer中）<br> 方法中使用ModelAndViewContainer中的Model和View创建ModelAndView，将值返回给DispatcherServlet<br> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getModelAndView<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,</span><br><span class="line">		ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	// 更新Model（包括设置SessionAttribute）</span><br><span class="line">	modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">	if (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	ModelMap model = mavContainer.getModel();</span><br><span class="line">	// 创建ModelAndView</span><br><span class="line">	ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">	if (!mavContainer.isViewReference()) &#123;</span><br><span class="line">		mav.setView((View) mavContainer.getView());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 如果是RedirectAttributes（重定向请求）</span><br><span class="line">	// 则将其值设置到FlashMap中</span><br><span class="line">	if (model instanceof RedirectAttributes) &#123;</span><br><span class="line">		Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">		if (request != null) &#123;</span><br><span class="line">			RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> (发生在：RequestMappingHandlerAdapter）</p>
<h2 id="15、"><a href="#15、" class="headerlink" title="15、"></a>15、</h2><p> 然后判断返回的View是否为空，如果为空就使用RequestToViewNameTranslatior查找默认视图，接着调用HandlerInterceptor的后置方法applyPostHandle</p>
<h2 id="16、"><a href="#16、" class="headerlink" title="16、"></a>16、</h2><p> 最后就调用processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); 将结果渲染，里面是调用render方法进行页面的渲染。调用resolveViewName方法解析出View，解析过程使用到了ViewResolver，这里使用的是默认配置InternalResourceViewResolver（它可以处理jsp视图）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">		@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span><br><span class="line">		@Nullable Exception exception) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	boolean errorView = false;</span><br><span class="line"></span><br><span class="line">	// 如果处理请求过程中有异常抛出</span><br><span class="line">	if (exception != null) &#123;</span><br><span class="line">		if (exception instanceof ModelAndViewDefiningException) &#123;</span><br><span class="line">			logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);</span><br><span class="line">			mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 将错误内容设置到View中</span><br><span class="line">			Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);</span><br><span class="line">			mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">			errorView = (mv != null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Did the handler return a view to render?</span><br><span class="line">	if (mv != null &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * -------------------------------</span><br><span class="line">		 * 渲染页面就是在这个render方法中执行的</span><br><span class="line">		 * -------------------------------</span><br><span class="line">		 */</span><br><span class="line">		render(mv, request, response);</span><br><span class="line">		if (errorView) &#123;</span><br><span class="line">			WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">		// Concurrent handling started during a forward</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (mappedHandler != null) &#123;</span><br><span class="line">		mappedHandler.triggerAfterCompletion(request, response, null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 至此，SpringMVC的分析到此结束，里面还有很多东西没有说到，比如FlashMap是什么东西，FlashMap是怎么传递和管理的，九大组件各个组件的作用是什么，九大组件的实现类都有哪些..<br> 我们只是讲讲SpringMVC的冰山一角而已</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/SpringMVC的M、V、C到底是什么东西/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/SpringMVC的M、V、C到底是什么东西/" itemprop="url">SpringMVC的M、V、C到底是什么东西</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T14:44:42+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们Web开发用得最多的框架可能要数SpringMVC了，但一直不是很清楚M、V、C对应SpringMVC里面的什么东西，只知道C就是Controller，就是我们写的逻辑控制器，V就是View，但是View就是指HTML或者JSP这种东西吗？还有M，Model是指我们的POJO类吗？<br>带着这些问题查阅了一些资料，有了一点头绪</p>
<h1 id="MVC三层结构"><a href="#MVC三层结构" class="headerlink" title="MVC三层结构"></a>MVC三层结构</h1><h2 id="What’s-C"><a href="#What’s-C" class="headerlink" title="What’s C ?"></a>What’s C ?</h2><p>没错，C就是Controller，是我们写的逻辑控制器，但在Spring中叫做Handler（处理器），Handler是SpringMVC的C层</p>
<h2 id="What’s-V"><a href="#What’s-V" class="headerlink" title="What’s V ?"></a>What’s V ?</h2><p>V层就是View视图层，SpringMVC把最后要展示给用户的数据+网页封装到View中</p>
<h2 id="What’s-M"><a href="#What’s-M" class="headerlink" title="What’s M ?"></a>What’s M ?</h2><p>M层就是Model层，这层功能和工作很多，它是C层和V层传输数据的桥梁，也就是说它贯穿于Controller层和View层之中，为这两层提供数据。像注视了@ModelAttribute方法、SessionAttribute、FlashMap、Model以及需要执行的方法的参数和返回值都属于这一层，而使用这一层的类有HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler、ModelFactory和FlashMapManager。它是SpringMVC中最复杂的一层，因为一个请求的参数封装有多重形式，比如方法里的参数，注解了@ModelAttribute，@SessionAttribute，还有FlashMap中的参数…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/09/SpringMVC是怎么跟着Tomcat启动的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/09/SpringMVC是怎么跟着Tomcat启动的/" itemprop="url">SpringMVC是怎么跟着Tomcat启动的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-09T23:19:12+08:00">
                2019-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们通过官方文档使用SpringMVC，用Tomcat来跑时，需要配置下面这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.SpringServletContainerInitializer;</span><br><span class="line">import org.springframework.web.WebApplicationInitializer;</span><br><span class="line">import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;</span><br><span class="line">import org.springframework.web.servlet.DispatcherServlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletContainerInitializer;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRegistration;</span><br><span class="line">import javax.servlet.annotation.HandlesTypes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 为什么实现了WebApplicationInitializer就可以被Tomcat所管理？</span><br><span class="line"> * 先看一个注解和一个类</span><br><span class="line"> * @see HandlesTypes</span><br><span class="line"> * @see ServletContainerInitializer</span><br><span class="line"> * 这两个一般成对出现的</span><br><span class="line"> * 在Tomcat启动的时候，会自动去寻找所有实现该接口的类</span><br><span class="line"> * 找到这个类后，里面唯一的实现方法需要一个Set参数</span><br><span class="line"> * 这些参数Tomcat会帮你去找，参数的类型是@HandlesTypes里面的value值</span><br><span class="line"> * Spring在org.springframework.web.SpringServletContainerInitializer中引用该注解并实现ServletContainerInitializer</span><br><span class="line"> * value值就是WebApplicationInitializer</span><br><span class="line"> * @see SpringServletContainerInitializer</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;----init  my ServletContext----&quot;);</span><br><span class="line">		// Load Spring web application configuration</span><br><span class="line">		AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();</span><br><span class="line">		ac.register(AppConfig.class);</span><br><span class="line">		// ac.refresh();</span><br><span class="line"></span><br><span class="line">		// Create and register the DispatcherServlet</span><br><span class="line">		DispatcherServlet servlet = new DispatcherServlet(ac);</span><br><span class="line">		ServletRegistration.Dynamic registration = servletContext.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">		registration.setLoadOnStartup(1);</span><br><span class="line">		registration.addMapping(&quot;/*&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppConfig.class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.lnw&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，当我们整合Tomcat来跑时（一般都是Tomcat插件），就会执行onStartup方法来启动SpringMVC</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>我们看下我们实现的接口WebApplicationInitializr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.web;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">public interface WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Configure the given &#123;@link ServletContext&#125; with any servlets, filters, listeners</span><br><span class="line">	 * context-params and attributes necessary for initializing this web application. See</span><br><span class="line">	 * examples &#123;@linkplain WebApplicationInitializer above&#125;.</span><br><span class="line">	 * @param servletContext the &#123;@code ServletContext&#125; to initialize</span><br><span class="line">	 * @throws ServletException if any call against the given &#123;@code ServletContext&#125;</span><br><span class="line">	 * throws a &#123;@code ServletException&#125;</span><br><span class="line">	 */</span><br><span class="line">	void onStartup(ServletContext servletContext) throws ServletException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现它还是Spring的东西，如果要随着Tomcat启动执行的话，那也得是Servlet或者Tomcat里面的东西吧</p>
<p>在Tomcat启动的时候，它会去扫描classpath下的services文件夹（包括依赖的项目），如果文件名是javax.servlet.ServletContainerInitializer，就把文件里面的值读取出来（值是个类，读取出来后加载）<br>SpringMVC的web项目下就有一个services文件夹，而且文件名也是那个，里面的值是SpringServletContainerInitializer<br><img src="/2019/02/09/SpringMVC是怎么跟着Tomcat启动的/20190306100444231.png" alt=""><br><img src="/2019/02/09/SpringMVC是怎么跟着Tomcat启动的/20190306100459166.png" alt=""><br>我们查看SpringMVC里面的类SpringServletContainerInitializer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.web;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ServiceLoader;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import javax.servlet.ServletContainerInitializer;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.HandlesTypes;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.annotation.AnnotationAwareOrderComparator;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line">import org.springframework.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="line">public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span><br><span class="line">			throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">		List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (webAppInitializerClasses != null) &#123;</span><br><span class="line">			for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">				// Be defensive: Some servlet containers provide us with invalid classes,</span><br><span class="line">				// no matter what @HandlesTypes says...</span><br><span class="line">				if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">						WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						initializers.add((WebApplicationInitializer)</span><br><span class="line">								ReflectionUtils.accessibleConstructor(waiClass).newInstance());</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Throwable ex) &#123;</span><br><span class="line">						throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (initializers.isEmpty()) &#123;</span><br><span class="line">			servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);</span><br><span class="line">		AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">		for (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">			initializer.onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注解@HandlerTypes里面的value值正是我们上面的那个WebApplicationInitializer</p>
<p>下面我们先来说下Tomcat里面的原理</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>就只说关键部分<br>Tomcat在启动的时候，会配置Context，配置Context需要ContextConfig<br>ContextConfig的核心就是webConfig 方法，下面主要看几条主要的代码<br>org.apache.catalina.startup.ContextConfig#webConfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.startup.ContextConfig#webConfig</span><br><span class="line"></span><br><span class="line">// Step 1. 读取各个jar模块和fragments</span><br><span class="line">Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Step 2. 排序fragments</span><br><span class="line">Set&lt;WebXml&gt; orderedFragments = null;</span><br><span class="line">orderedFragments =</span><br><span class="line">	WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">// Step 3. 寻找所有的ServletContainerInitializer实现</span><br><span class="line">// SpringMVC也是基于这个过程开展的</span><br><span class="line">if (ok) &#123;</span><br><span class="line">processServletContainerInitializers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step 4. 处理/WEB-INF/classes文件夹下面的注解了@HandlesTypes</span><br><span class="line">// 这一步很重要</span><br><span class="line">Map&lt;String,JavaClassCacheEntry&gt; javaClassCache = new HashMap&lt;&gt;();</span><br><span class="line">if (ok) &#123;</span><br><span class="line">	WebResource[] webResources =</span><br><span class="line">			context.getResources().listResources(&quot;/WEB-INF/classes&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Step 5. 处理所有的jar中有关的@HandlesTypes</span><br><span class="line">if (ok) &#123;</span><br><span class="line">	processAnnotations(</span><br><span class="line">			orderedFragments, webXml.isMetadataComplete(), javaClassCache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step 6. 将所有的fragments.xml合并</span><br><span class="line">if (ok) &#123;</span><br><span class="line">	ok = webXml.merge(orderedFragments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step 7a，将所有的web.xml合并</span><br><span class="line">// merge tomcat-web.xml</span><br><span class="line">webXml.merge(tomcatWebXml);</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"> // Step 11. 将扫描到的所有实现了ServletContainerInitializer类添加到StandardContext容器中</span><br><span class="line">if (ok) &#123;</span><br><span class="line">	for (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">			Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">				initializerClassMap.entrySet()) &#123;</span><br><span class="line">		if (entry.getValue().isEmpty()) &#123;</span><br><span class="line">			context.addServletContainerInitializer(</span><br><span class="line">					entry.getKey(), null);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			context.addServletContainerInitializer(</span><br><span class="line">					entry.getKey(), entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过注释大概可以知道每段代码的作用<br>其中这段代码很重要<strong> processServletContainerInitializers(); </strong><br>还有就是最后的Step 11将扫描到的类添加到Context 中<br>也就是说，Tomcat启动的时候，会使用ClassLoader扫描classes路径下所有的类，找出实现了ServletContainerInitializer类并保存，然后在随后的启动中调用ServletContainerInitializer<br>的onStart方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException;</span><br></pre></td></tr></table></figure></p>
<p>集合Set是存放注解@HandlesTypes中的类，目的是在特定的ServletContainerInitializer中启动的时候做另外的操作</p>
<h1 id="SpringMVC跟Tomcat"><a href="#SpringMVC跟Tomcat" class="headerlink" title="SpringMVC跟Tomcat"></a>SpringMVC跟Tomcat</h1><p>上面我们讲到Tomcat启动的时候会扫描到所有实现了ServletContainerInitializer的类，而我们的SpringServletContainerInitialzer就是SpringMVC跟Tomcat的桥接<br>我们再来看下SpringServletContainerInitializer的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.web;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ServiceLoader;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import javax.servlet.ServletContainerInitializer;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.HandlesTypes;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.annotation.AnnotationAwareOrderComparator;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line">import org.springframework.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="line">public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span><br><span class="line">			throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">		List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (webAppInitializerClasses != null) &#123;</span><br><span class="line">			for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">				// Be defensive: Some servlet containers provide us with invalid classes,</span><br><span class="line">				// no matter what @HandlesTypes says...</span><br><span class="line">				if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">						WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						initializers.add((WebApplicationInitializer)</span><br><span class="line">								ReflectionUtils.accessibleConstructor(waiClass).newInstance());</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Throwable ex) &#123;</span><br><span class="line">						throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (initializers.isEmpty()) &#123;</span><br><span class="line">			servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);</span><br><span class="line">		AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">		for (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">			initializer.onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为SpringServletContainerInitializer实现了ServletContainerInitializer，所以会被Tomcat扫描存储到Context，并且因为该类上面注解了@HandlesTypes，里面的value为WebApplicationInitializer.class，所以Tomcat会将实现了WebApplicationInitializer的类扫描出来封装到Set中。<br>Tomcat的启动中，会调用所有的ServletContainerInitializer的onStartup方法来初始化并启动StrandContext容器，所以SpringServletContainerInitiar的onStartup方法就会被调用<br>在org.springframework.web.SpringServletContainerInitializer#onStartup方法中，通过一个for循环启动所有的WebApplicationInitializer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">	initializer.onStartup(servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是这样，执行了SpringMVC官方文档的这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;----init  my ServletContext----&quot;);</span><br><span class="line">		// Load Spring web application configuration</span><br><span class="line">		AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();</span><br><span class="line">		ac.register(AppConfig.class);</span><br><span class="line">		// ac.refresh();</span><br><span class="line"></span><br><span class="line">		// Create and register the DispatcherServlet</span><br><span class="line">		DispatcherServlet servlet = new DispatcherServlet(ac);</span><br><span class="line">		ServletRegistration.Dynamic registration = servletContext.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">		registration.setLoadOnStartup(1);</span><br><span class="line">		registration.addMapping(&quot;/*&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/07/Redis之持久化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/07/Redis之持久化/" itemprop="url">Redis之持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-07T16:47:06+08:00">
                2019-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么需要持久化"><a href="#为什么需要持久化" class="headerlink" title="为什么需要持久化"></a>为什么需要持久化</h1><p>Redis的所有数据是存储在内存里面的，Redis的持久化，为了防止机器忽然的宕机、断电使Redis内存中的数据来不及存储在硬盘而导致数据的丢失</p>
<h1 id="哪些持久化方法"><a href="#哪些持久化方法" class="headerlink" title="哪些持久化方法"></a>哪些持久化方法</h1><p>Redis有两种持久化机制<br><strong> 快照 </strong><br><strong> AOF </strong></p>
<h1 id="快照-snopashotting"><a href="#快照-snopashotting" class="headerlink" title="快照 snopashotting"></a>快照 snopashotting</h1><p>跟名字一样，就是将内存中的数据全部备份到硬盘的一个文件中，我们可以在redis.conf文件中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000  # 当60秒内写入1000个请求时，触发BGSAVE</span><br><span class="line">stop-write-on-bgsave-error  no   # 当创建快照文件失败后是否继续执行写命令</span><br><span class="line">rdbcomparession yes      # 是否对快照文件进行压缩</span><br><span class="line">dbfilename dump.rdb     # 备份数据的文件</span><br><span class="line">dir ./                          # 存储的路径</span><br></pre></td></tr></table></figure></p>
<h2 id="创建快照的方法"><a href="#创建快照的方法" class="headerlink" title="创建快照的方法"></a>创建快照的方法</h2><p>1、 客户端发送BGSAVE命令来创建一个快照，Redis会调用fork创建一个子进程，子进程负责快照备份并写入硬盘，父进程继续处理客户端的请求<br>2、客户端发送SAVE指令，这时Redis只会进行快照的备份，在快照完成之前，不会再响应任何其他命令<br>3、如果用户在redis.conf中设置了SAVE配置（也就是上面那段代码），比如save 60 1000  从Redis最近一次创建快照之后算起，当60秒内有1000次写入，就会自动触发BGSAVE命令。当设置了多个SAVE配置，只要有一个满足就会执行BGSAVE<br>4、当Redis通过SHUTDOWN命令接收到关闭服务器或者接受到标准的TEMP信号时，会执行一个SAVE命令<br>5、当Redis服务器连接另一个Redis服务器，并向对方发送SYNC命令来开始一个复制操作时，如果主服务器没有执行BGSAVE操作，就会自己执行BGSAVE操作</p>
<p>注意：快照会丢失数据的，因为在创建快照的时候，如果有指令写入，此时数据是不会被备份的，因为Redis是使用系统的COW（Copy On Write）</p>
<h2 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h2><p>上面说当Redis执行BGSAVE命令时，会调用系统glibc的函数fork产生一个子进程，来完成快照的创建，而父进程继续处理请求<br>当子进程创建出来的时候，它不会修改内存中的数据结构，只会对数据进行遍历读取然后序列化到硬盘，如果此时父进程有请求指令处理时，Redis就会调用系统的COW（Copy on Write ）机制来进行数据段页面的分离。页面是内存中存储的一种形式，当一个页面中的数据在父进程中被修改时，父进程就会把该页面复制出来，然后在该页面里面操作数据，此时子进程快照备份的是没有被修改的页面，所以父进程在创建快照期间的所有操作是不会被备份的</p>
<h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>AOF（append-only file）只追加文件，它存储的是命令不是数据，也就是说，Redis会将成功执行的命令写入到一个文件中，然后把该文件的命令从头到尾在另一台Redis服务器运行一遍，就能恢复原来的数据<br>AOF配置可以通过设置redis.conf来配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appendonly  no                       # 是否开启AOF持久化</span><br><span class="line">appendfysnc  everysec              # 多久将写入内容同步到硬盘</span><br><span class="line">no-appendsync-on-rewrite  no    # 在对AOF进行同步的时候是否执行同步操作</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;  # 存储AOF的文件</span><br><span class="line"># 下面两条命令可以配置自动执行AOF重写</span><br><span class="line">auto-aof-rewrite-percentage 100  # AOF的体积比上一次文件重写之后的体积大了一倍（100%）</span><br><span class="line">auto-aof-rewrite-min-size 64mb  #  AOF文件的体积大于64MB</span><br></pre></td></tr></table></figure></p>
<p>上面第三条配置，是配置是否开启文件同步，文件同步是强制Redis将缓存区里的数据（AOF数据会先写入缓存）马上写入硬盘，此时会阻塞客户端的请求</p>
<h2 id="appendfsync同步频率"><a href="#appendfsync同步频率" class="headerlink" title="appendfsync同步频率"></a>appendfsync同步频率</h2><p>上面配置的第二句，设置了多久将缓存中的文件写入到硬盘。AOF是先写入硬盘的缓存的，然后才从缓存写入硬盘，所以如果发生宕机，会发生AOF数据丢失的风险，所以设置同步频率很重要，设置同步频率是调用Linux的glibc的fsync(int id)函数，只要Redis调用了该函数就能保证aof日志不丢失，因为会强制系统写入，还发生阻塞了其他请求<br>三种同步频率：</p>
<ul>
<li>always：每个Redis写命令都要同步到硬盘，这严重降低了Redis的速度，不建议</li>
<li>everysec：每秒执行一次同步，将一秒内的请求命令写入硬盘，推荐使用，就算是发送故障，丢失的数据也能控制在1秒内</li>
<li>no：让系统自己决定何时进行同步</li>
</ul>
<h2 id="重写AOF（AOF瘦身）"><a href="#重写AOF（AOF瘦身）" class="headerlink" title="重写AOF（AOF瘦身）"></a>重写AOF（AOF瘦身）</h2><p>随着系统的运行，AOF日志文件的体积会不断增大，这时可以通过重写AOF来减小AOF的体积。<br>用户可以发送BGREWRITEAOF命令，该命令会移除AOF文件中冗余的命令来重写（rewrite）AOF，BGREWRITEAOF跟BGSAVE很相似，也是开启一个子进程后台运行<br>除了手动开启BGREWRITEAOF，还可以通过配置redis.conf来开启，也就是上面最后两条配置<br>auto-aof-rewrite-percentage 100 #AOF的体积比上一次文件重写之后的体积大了一倍（100%）<br>auto-aof-rewrite-min-size 64mb # AOF文件的体积大于64MB<br>当上面这两个条件满足时，就会开启BGREWRITEAOF</p>
<h1 id="快照跟AOF的比较"><a href="#快照跟AOF的比较" class="headerlink" title="快照跟AOF的比较"></a>快照跟AOF的比较</h1><p>AOF恢复数据的速度远不如快照，当时快照会发生数据丢失，两者各有各的优点<br>在Redis4.0后，引入了混合持久化，也就是快照跟AOF并存，当需要Redis持久化时，先进行快照备份，在快照备份期间，所有的写命令都将写入AOF<br>当需要重启或者恢复数据时，先进行快照恢复，等快照恢复进行完了就进行AOF恢复，完美解决！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/HTTP的GET跟POST的区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/HTTP的GET跟POST的区别/" itemprop="url">HTTP的GET跟POST的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T23:12:26+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/http/" itemprop="url" rel="index">
                    <span itemprop="name">http</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本区别"><a href="#基本区别" class="headerlink" title="基本区别"></a>基本区别</h1><ul>
<li>GET 比 POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</li>
<li>GET 参数通过URL传递，而POST则放在request body中（这就解释了上一条规则</li>
<li>GET在浏览器回退时是无害的，而POST会再次提交请求</li>
<li>GET请求会被浏览器主动缓存（cache），而POST不会，除非手动设置</li>
<li>GET 请求只会进行URL编码，而POST支持多种编码方式</li>
<li>GET请求在URL中有参数限制（一般是2K），而POST没有限制</li>
</ul>
<h1 id="更加深入一点："><a href="#更加深入一点：" class="headerlink" title="更加深入一点："></a>更加深入一点：</h1><p>HTTP底层是TCP/IP实现的，所以GET和POST底层都是用TCP/IP，所以理论上我们可以在GET带上request body，也可以让POST带上URL参数，只是这样做违反了HTTP的规定而已</p>
<h2 id="还有一个重大的区别："><a href="#还有一个重大的区别：" class="headerlink" title="还有一个重大的区别："></a>还有一个重大的区别：</h2><p>GET会产生一个TCP数据包，而POST产生两个TCP数据包<br>GET请求会把header头部和data数据一起发送过去，服务器返回200<br>POST请求，浏览器会先发送header，服务器返回100 continue，浏览器再发送data，服务器返回200<br>即使是这样，发送一次包的时间和发送两次包的时间其实是差不多的，所以POST请求也不必GET请求差</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/equals跟-的区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/equals跟-的区别/" itemprop="url">equals跟==的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T22:57:04+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id=""><a href="#" class="headerlink" title="=="></a>==</h1><p>== 比较的是变量（栈）内存中存放的对象的（堆）地址是否相同，即是否为同一个对象， <strong> 比较的真正意义是指针上的操作 </strong></p>
<p>此时我们可能有一些疑问，如果是int a=1; int b=1;此时我们a==b，为什么为true呢？<br>我们上面说说， == 是比较内存地址是否相同，是指针上的操作比较，如果为true的话，就说明一个问题！那就是a和b的值都是指向同一个地址！因为都是1嘛，1这种数据都是会放在 <strong> 常量池 </strong> 里面。<br>不仅a可以等于b，如果long b=1L; double c=10.0；他们彼此之间都会相等</p>
<h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><p>equals用来比较两个对象的内容是否相等，equals是Object的方法<br>源码上看，其实是没有区别的，我们看Object类的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object#equals</span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>底层只是调用==<br>但是我们所有的类都是Object类的子类，都可以重写equals的方法，比如String，他重写了Object的equals的方法，用equals方法来比较每个String对象里面value值是否相等，所以String类型的equals跟==是有区别了！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String#equals</span><br><span class="line">public boolean equals(Object anObject) &#123;   </span><br><span class="line">    if (this == anObject) &#123; </span><br><span class="line">        return true;   </span><br><span class="line">        &#125;    if (anObject instanceof String) &#123; </span><br><span class="line">            String anotherString = (String)anObject; </span><br><span class="line">            int n = value.length;</span><br><span class="line">            if (n == anotherString.value.length) &#123; </span><br><span class="line">                char v1[] = value; </span><br><span class="line">                char v2[] = anotherString.value; </span><br><span class="line">                int i = 0;</span><br><span class="line">                while (n-- != 0) &#123; </span><br><span class="line">                    if (v1[i] != v2[i]) </span><br><span class="line">                    return false;  </span><br><span class="line">                    i++;   </span><br><span class="line">                &#125;   </span><br><span class="line">                return true;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;  </span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果类没有重写equals，那么调用equals方法跟调用==是没有什么区别的！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/Autowired跟-Resource的关系和区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/Autowired跟-Resource的关系和区别/" itemprop="url">@Autowired跟@Resource的关系和区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T21:36:16+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Spring自动装配中，我们可能会使用到两个注解@Autowired跟@Resource<br>这两个注解都可以帮我们完成Bean之间的自动装配，那它们之间有什么不一样呢？</p>
<h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><ul>
<li>是Spring自己家的产品（亲儿子），需要引入Spring的包才能使用</li>
<li>默认是按照类型byType来自动装配的</li>
<li>如果要通过name来装配（byName），需要配合另一个注解@Qualifier使用<br>如图所示：<br><img src="/2019/02/03/Autowired跟-Resource的关系和区别/20190203110600737.png" alt=""><br>@Autowired源码<br><img src="/2019/02/03/Autowired跟-Resource的关系和区别/20190203110632646.png" alt=""><br>@Qualifier源码<br><img src="/2019/02/03/Autowired跟-Resource的关系和区别/20190203110659408.png" alt=""></li>
</ul>
<h1 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h1><ul>
<li>这是JDK中自带的注解，但是Spring也是支持这个注解</li>
<li>@Resource默认是byName，也就是通过名称来装配Bean</li>
<li>如果要通过类型来装配，需要声明byType指定类型</li>
</ul>
<p>如图<br><img src="/2019/02/03/Autowired跟-Resource的关系和区别/20190203110958397.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/31/SpringMVC之三个Servlet/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/SpringMVC之三个Servlet/" itemprop="url">SpringMVC之三个Servlet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-31T22:51:53+08:00">
                2019-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、HttpServletBean"><a href="#一、HttpServletBean" class="headerlink" title="一、HttpServletBean"></a>一、HttpServletBean</h1><p>参与创建工作，没有涉及请求的处理</p>
<h1 id="二、FrameworkServlet"><a href="#二、FrameworkServlet" class="headerlink" title="二、FrameworkServlet"></a>二、FrameworkServlet</h1><p>当第一个请求过来时，就初始化容器</p>
<p><img src="/2019/01/31/SpringMVC之三个Servlet/init.png" alt=""><br>如上图，当<strong>第一个请求</strong>过来时，FrameworkServlet就初始化容器，并将Spring的容器进行刷新，而DispatcherServlet的onRefresh刷新只是初始化九大组件。以后的请求就都不需要初始化容器。<br>初始化完容器以后，因为FrameworkServlet重写了Servlet的service，doGet，doPost等方法，所以会先走到Framework的doGet或者doPost等请求方法。<br>FrameworkServlet的设计很有趣，它将所有的请求get,post,delete等请求全部嫁接到<br><strong>processRequest(request,response)</strong><br><img src="/2019/01/31/SpringMVC之三个Servlet/processRequest.png" alt=""></p>
<p>在 <strong>doService(request,response)</strong> 方法中又调用了 <strong>doService(request,response)</strong> 方法，该方法是在DispatcherServlet中具体实现<br>所以说FrameworkServlet主要有两个作用：<br>1.创建并初始化Spring容器<br>2.请求的入口</p>
<h1 id="三、DispatcherServlet"><a href="#三、DispatcherServlet" class="headerlink" title="三、DispatcherServlet"></a>三、DispatcherServlet</h1><p>第一个作用是初始化九大组件，就是在上面的FrameworkServlet执行完初始化容器后，就调用 <strong>onRefresh</strong> ，方法里面只调用了 <strong>initStrategies(context)</strong> 方法，initStrategies方法才是重点，如下图<br><img src="/2019/01/31/SpringMVC之三个Servlet/nine_components.png" alt=""></p>
<p>每个组件在处理请求时都有可能会用到<br>第二个作用就是处理请求<br>请求的入口是doService ，我们看下请求过来的调用链<br><img src="/2019/01/31/SpringMVC之三个Servlet/20190131105943159.png" alt=""><br>doService对request设置了一些属性<br><img src="/2019/01/31/SpringMVC之三个Servlet/doService.png" alt=""></p>
<p>接着调用doDispatch，doDispatch是DispatcherServlet的核心<br>我们看代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* doDispatch中最重要的代码总共有四句（见下面的标签数字）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Handler、HandlerMapping、HandlerAdapter三者的关系：</span></span><br><span class="line"><span class="comment">* Handler：就是我们的控制器Controller中加了<span class="doctag">@XXXMapping</span>的方法</span></span><br><span class="line"><span class="comment">* HandlerMapping： 用来快速查找Handler</span></span><br><span class="line"><span class="comment">* HandlerAdapter：调用Handler来干活，而且不同Handler需要不同的Adapter</span></span><br><span class="line"><span class="comment">* 这就好比HandlerAdapter是工人，Handler是工具，HandlerMapping是根据加工的需求来选择用</span></span><br><span class="line"><span class="comment">* 什么设备</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 封装Request，如果不是上传请求则直接使用接收到的request</span></span><br><span class="line"><span class="comment">* 如果是上传请求，重新封装成MultipartHttpServletRequest</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 处理请求的处理器链</span></span><br><span class="line"><span class="comment">* 包含有处理器Handler和对应的拦截器Interceptor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 是否为上传请求的标记</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 从request中获取异步请求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* View 跟 ViewResolver</span></span><br><span class="line"><span class="comment">* View 是用来展示数据的</span></span><br><span class="line"><span class="comment">* 而ViewResolver是用来查找View的</span></span><br><span class="line"><span class="comment">* 做完请求工作后，需要返回结果，而返回结果就需要模板，</span></span><br><span class="line"><span class="comment">* View就是所需要的模板，ViewResolver就是来选择哪个模板</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* **/</span></span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 异常声明</span></span><br><span class="line"><span class="comment">* doDispatch()中对异常又两种处理方法：</span></span><br><span class="line"><span class="comment">* 一、如果是处理请求中出现的异常，会捕获并在processDispatchResult中渲染到最后的视图中</span></span><br><span class="line"><span class="comment">* 二、如果是渲染中出现异常，则直接抛出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 检查是不是上传请求</span></span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 第一句</span></span><br><span class="line"><span class="comment">* 使用HandlerMapping找到可以干活的Handler</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* **/</span></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 找不到Handler返回404</span></span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 第二句</span></span><br><span class="line"><span class="comment">* 找到合适的HandlerAdapter去让他干活</span></span><br><span class="line"><span class="comment">* **/</span></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理GET、HEAD请求的last-modified</span></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Last-Modified是HTTP头部的一种属性，表示当前请求的资源跟上一次请求的资源是否相同</span></span><br><span class="line"><span class="comment">* 如果相同，返回304并且没有新的实体（body)返回</span></span><br><span class="line"><span class="comment">* 否则返回新的实体内容</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是客户端请求的资源，</span></span><br><span class="line"><span class="comment">* 同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</span></span><br><span class="line"><span class="comment">* 客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过</span></span><br><span class="line"><span class="comment">* 如果服务器端的资源没有变化，则自动返回 HTTP 304（Not Changed.）状态码，内容为空，这样就节省了传输数据量。</span></span><br><span class="line"><span class="comment">* 当服务器端代码发生改变或者重启服务器时，则重新发出资源，</span></span><br><span class="line"><span class="comment">* 返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 如果有拦截器，就饿执行我们的拦截器，preHandle前置处理**/</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 第三句</span></span><br><span class="line"><span class="comment">* 让HandlerAdapter开始干活，干完活后返回数据</span></span><br><span class="line"><span class="comment">* **/</span></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要异步处理，则直接返回</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 因为异步处理会重新开启一个线程去执行结果的返回</span></span><br><span class="line"><span class="comment">* 不会占用目前这个线程，所以可以直接返回</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当view为空时（比如，handler返回类型为void），根据request设置默认view</span></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"><span class="comment">/** 执行了拦截器的后置处理 postHandle**/</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 第四句</span></span><br><span class="line"><span class="comment">* 将数据处理，通过View展示给用户</span></span><br><span class="line"><span class="comment">* 处理结果，包括处理异常，渲染页面，发出完成通知，触发拦截器的afterCompletion</span></span><br><span class="line"><span class="comment">* **/</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 判断是否为异步请求</span></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// 执行异步的拦截器</span></span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 删除上传请求的资源，不然会产生临时的资源</span></span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>doDispatch方法主要有四个任务：1.用request找到Handler； 2.根据Handler找到HandlerAdapter； 3.用HandlerAdapter处理Handler 4.调用processDispatchResult方法处理结果（包括异常的处理和View视图的渲染）。除此之外还另外做了许多事情，比如判断是否为上传文件请求，是否带有Last-Modified头部，执行拦截器，是否为异步请求…processDispatchResult方法处理上面doDispatch返回的结果，包括处理异常、渲染页面、触发拦截器的后置处理，处理异常只是处理doDispatch()方法中的异常、渲染页面的异常就抛出。渲染页面的方法调用render</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/31/Java基础之Error、Exception/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/31/Java基础之Error、Exception/" itemprop="url">Java基础之Error、Exception</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-31T22:30:48+08:00">
                2019-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>只要是程序，就会有错误跟异常，Java程序也不例外！<br>那什么是错误，什么是异常？Java异常又可分为哪两类？</p>
<h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><h2 id="VirtualMachineError（虚拟机错误）"><a href="#VirtualMachineError（虚拟机错误）" class="headerlink" title="VirtualMachineError（虚拟机错误）"></a>VirtualMachineError（虚拟机错误）</h2><p>错误一般是程序在正常条件下，是系统内部的错误或者资源耗尽的错误！常见的错误主要有两种，内存溢出和栈溢出！</p>
<ul>
<li>OutOfMemoryError（内存溢出）：一般是虚拟机分配的内存不能容下程序所需的数据，或者new 出的对象太多太多了（主要是堆内存或者方法区内存的不足）</li>
<li>StackOverFlowError（栈溢出）：常见的就是递归循环没有出口，导致虚拟机栈记录太多东西导致溢出</li>
</ul>
<h2 id="AWTError"><a href="#AWTError" class="headerlink" title="AWTError"></a>AWTError</h2><p>一般是调用AWT包下的类，使用操作系统的资源时出现的错误</p>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><h2 id="RuntimeExcept（运行时异常，非检查异常）"><a href="#RuntimeExcept（运行时异常，非检查异常）" class="headerlink" title="RuntimeExcept（运行时异常，非检查异常）"></a>RuntimeExcept（运行时异常，非检查异常）</h2><p>这种异常在我们的程序中是最常见的：</p>
<ol>
<li>NullPointException（空指针异常）</li>
<li>IndexOutOfBoundsException （数组下表越界）</li>
<li>ClassCastException （强转类型是异常）</li>
<li>ClassNotFoundException （找不到指定类）</li>
<li>ArithmeticException （算数运算异常 如除0）</li>
<li>NumberFormatException （String类型装数字类型异常）<br>…<h2 id="IOException-（其他异常，也叫做检查异常，必须处理的异常）"><a href="#IOException-（其他异常，也叫做检查异常，必须处理的异常）" class="headerlink" title="IOException （其他异常，也叫做检查异常，必须处理的异常）"></a>IOException （其他异常，也叫做检查异常，必须处理的异常）</h2></li>
<li>FileNotFoundException （文件未找到异常）</li>
<li>EOFException （文件已经结束异常）</li>
<li>SQLException （SQL异常）</li>
</ol>
<h1 id="关于检查异常跟非异常"><a href="#关于检查异常跟非异常" class="headerlink" title="关于检查异常跟非异常"></a>关于检查异常跟非异常</h1><p>非检查异常（unchecked exception）： 包括RuntimeException和Error类的异常，对于运行时的异常，编译器不要求程序员强制捕获异常处理或者抛出异常声明<br>检查异常（checked exception） ： 编译器强制要求程序员对异常进行捕获，比如常见的IOException和SQLException！！</p>
<h1 id="总结图："><a href="#总结图：" class="headerlink" title="总结图："></a>总结图：</h1><p>最后给一张大图完整的说明Exception和Error：<br><img src="/2019/01/31/Java基础之Error、Exception/20190131104704989.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">SouthLight Lin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SouthLight Lin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
