<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="SpringMVC,">










<meta name="description" content="SpringMVC的本质SpringMVC本质只是一个Servlet，Servlet的运行需要Servlet容器，常见的容器有Tomcat跟Jetty。Servlet的运行会调用一次init()跟一次destory()方法，用于初始化Servlet跟销毁Servlet。SpringMVC利用init()方法创建WebApplication的运行环境。（此时的WebApplication只是Serv">
<meta name="keywords" content="SpringMVC">
<meta property="og:type" content="article">
<meta property="og:title" content="详解SpringMVC">
<meta property="og:url" content="http://yoursite.com/2019/02/12/详解SpringMVC/index.html">
<meta property="og:site_name" content="SouthLight&#39;s Blog">
<meta property="og:description" content="SpringMVC的本质SpringMVC本质只是一个Servlet，Servlet的运行需要Servlet容器，常见的容器有Tomcat跟Jetty。Servlet的运行会调用一次init()跟一次destory()方法，用于初始化Servlet跟销毁Servlet。SpringMVC利用init()方法创建WebApplication的运行环境。（此时的WebApplication只是Serv">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/02/12/详解SpringMVC/20190212115408186.png">
<meta property="og:image" content="http://yoursite.com/2019/02/12/详解SpringMVC/20190213125005726.png">
<meta property="og:image" content="http://yoursite.com/2019/02/12/详解SpringMVC/20190213123002392.png">
<meta property="og:image" content="http://yoursite.com/2019/02/12/详解SpringMVC/20190213125530145.png">
<meta property="og:image" content="http://yoursite.com/2019/02/12/详解SpringMVC/20190213125703302.png">
<meta property="og:image" content="http://yoursite.com/2019/02/12/详解SpringMVC/20190213115117039.png">
<meta property="og:updated_time" content="2019-02-13T15:52:23.595Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="详解SpringMVC">
<meta name="twitter:description" content="SpringMVC的本质SpringMVC本质只是一个Servlet，Servlet的运行需要Servlet容器，常见的容器有Tomcat跟Jetty。Servlet的运行会调用一次init()跟一次destory()方法，用于初始化Servlet跟销毁Servlet。SpringMVC利用init()方法创建WebApplication的运行环境。（此时的WebApplication只是Serv">
<meta name="twitter:image" content="http://yoursite.com/2019/02/12/详解SpringMVC/20190212115408186.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/12/详解SpringMVC/">





  <title>详解SpringMVC | SouthLight's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SouthLight's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/详解SpringMVC/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">详解SpringMVC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T15:06:13+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="SpringMVC的本质"><a href="#SpringMVC的本质" class="headerlink" title="SpringMVC的本质"></a>SpringMVC的本质</h1><p>SpringMVC本质只是一个Servlet，Servlet的运行需要Servlet容器，常见的容器有Tomcat跟Jetty。Servlet的运行会调用一次init()跟一次destory()方法，用于初始化Servlet跟销毁Servlet。SpringMVC利用init()方法创建WebApplication的运行环境。（此时的WebApplication只是ServletWebApplicationContext，存储Controller、ViewResolver、HandlerMapping等）<br>所以SpringMVC的运行需要Servlet-api，而Servlet如Tomcat或者Jetty容器已经依赖了Servlet-api（如果是开发时使用插件形式，比如使用Tomcat插件，就需要手动引入）</p>
<h1 id="运行SpringMVC的前期准备"><a href="#运行SpringMVC的前期准备" class="headerlink" title="运行SpringMVC的前期准备"></a>运行SpringMVC的前期准备</h1><p>SpringMVC要运行需要Servlet，这里我们使用Tomcat插件作为Servlet容器，先引入Servlet的api,虽然Servlet-api在Tomcat插件呢中已经存在，但是SpringMVC在编译时需要Servlet-api的存在，不然编译不通过<br>哦对，在这之前需要引入Spring的包有context,web,webmvc 下面会说这几个包的作用<br>完整的pom.xml如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.demo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lnw-spring-mvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;lnw-spring-mvc Maven Webapp&lt;/name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project&apos;s website --&gt;</span><br><span class="line">    &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">		&lt;!--引入Servlet-api，然后scope设置为provided，表示编译时存在，运行时可去除</span><br><span class="line">		因为Tomcat中已经有Servlet-api了，运行时使用Tomcat里面的Servelt-Api就可以了--&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;lnw-spring-mvc&lt;/finalName&gt;</span><br><span class="line">        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">            &lt;plugins&gt;</span><br><span class="line">				&lt;!--添加Tomcat插件，设置路径和端口--&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">                    &lt;configuration&gt;</span><br><span class="line">                        &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">                        &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">                    &lt;/configuration&gt;</span><br><span class="line">                &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/plugins&gt;</span><br><span class="line">        &lt;/pluginManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong> 引入的Servlet-api需要设置scope为provide表示编译时存在，运行时去除 </strong><br>Servlet容器跟依赖包都有了，接下来就是要让SpringMVC整合到Tomcat中<br>以前都是在web.xml配置，因为你Tomcat启动时会读取web.xml中的配置来启动加载SpringMVC的DispatcherServlet，但我这里想用java-config来配置，因为java-config配置更加直观一点（个人观点）<br>我们用一个MyWebApplicationInitializer类表示一个web.xml配置，用AppConfig类来配置Spring<br>我的理解是MyWebApplicationInitializer可以让Tomcat发现SpringMVC的存在并注册DispatcherServlet，AppConfig可以配置Spring的容器以及其他Spring属性</p>
<p>MyWebApplicationInitializer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.config;</span><br><span class="line">import org.springframework.web.WebApplicationInitializer;</span><br><span class="line">import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;</span><br><span class="line">import org.springframework.web.servlet.DispatcherServlet;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletRegistration;</span><br><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext servletCxt) &#123;</span><br><span class="line">        System.out.println(&quot;------init------&quot;);</span><br><span class="line">        // Load Spring web application configuration</span><br><span class="line">        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        // 注册Spring的配置类</span><br><span class="line">        ac.register(AppConfig.class);</span><br><span class="line">        // ac.refresh();</span><br><span class="line">        // Create and register the DispatcherServlet</span><br><span class="line">        DispatcherServlet servlet = new DispatcherServlet(ac);</span><br><span class="line">        ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">        registration.setLoadOnStartup(1);</span><br><span class="line">        registration.addMapping(&quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/12/详解SpringMVC/20190212115408186.png" alt=""><br>这里的ac.refresh()之所以要注释掉，因为此时容器中还没有ServletContext，因为还没有将Tomcat容器中的ServletContext注入到Spring容器中，而SpringMVC中的有些组件需要ServletContext才能进行创建，如果此时没有ServletContext，在调用refresh时就会出现错误，显示“No ServletContext set”，比如resourceHandlerMapping这个Bean，在创建的时候就会进行断言<br>ServletContext的传入，在FrameworkServlet中，还没调用refresh前<br><img src="/2019/02/12/详解SpringMVC/20190213125005726.png" alt=""><br><img src="/2019/02/12/详解SpringMVC/20190213123002392.png" alt=""><br>只有设置了ServletContext，断言的时候才不会报错，如果没有把自己手写的ac.refresh注释掉，因为容器中没有ServletContext，项目时运行不了的<br>只有执行完FrameworkServlet里的initWebApplicationContext，设置了ServletContext，才能将SpringMVC进行刷新</p>
<ul>
<li>注：ServletContext 代表一个程序的应用，管理我们的Servlet，而且所有的Servlet都可以共享这个Context<br><img src="/2019/02/12/详解SpringMVC/20190213125530145.png" alt=""><br><img src="/2019/02/12/详解SpringMVC/20190213125703302.png" alt=""></li>
</ul>
<p>还有，我已经在一篇博客中讲过SpringMVC是怎么随着Tomcat中启动的，有兴趣可以去看下，为什么配置了一个MyWebApplicationInitializer，该类只是实现了WebApplicationInitializer就可以随着Tomcat启动（很有趣的哦）</p>
<p>AppConfig.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.lnw&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class AppConfig&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppConfig类就只是一个普通的Spring配置类，标明扫描包的路径，开启SpringMVC的注解</p>
<h2 id="这里为什么要加-EnableWebMVC注解呢？"><a href="#这里为什么要加-EnableWebMVC注解呢？" class="headerlink" title="这里为什么要加@EnableWebMVC注解呢？"></a>这里为什么要加@EnableWebMVC注解呢？</h2><p>这个问题很重要！<br>加上@EnableWebMVC注解，会在Spring容器中引入一个DelegatingWebMvcConfiguration类，这个类又继承自WebMvcConfigurationSupport类<br>WebMvcConfigurationSupport里面配置了需要SpringMVC的许多默认选项，比如SpringMVC的九大组件，大多都是在这个类中默认配置（除了文件上传的那个组件好像没有默认配置）<br>WebMvcConfigurationSupport类里面配置了很多SpringMVC许多组件默认的Bean，截取相关代码<br>WebMvcConfigurationSupport.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   @Bean</span><br><span class="line">public BeanNameUrlHandlerMapping beanNameHandlerMapping() &#123;</span><br><span class="line">	BeanNameUrlHandlerMapping mapping = new BeanNameUrlHandlerMapping();</span><br><span class="line">	mapping.setOrder(2);</span><br><span class="line">	mapping.setInterceptors(getInterceptors());</span><br><span class="line">	mapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">	return mapping;</span><br><span class="line">&#125;</span><br><span class="line">   @Bean</span><br><span class="line">public ViewResolver mvcViewResolver() &#123;</span><br><span class="line">	ViewResolverRegistry registry = new ViewResolverRegistry(</span><br><span class="line">			mvcContentNegotiationManager(), this.applicationContext);</span><br><span class="line">	configureViewResolvers(registry);</span><br><span class="line"></span><br><span class="line">	if (registry.getViewResolvers().isEmpty() &amp;&amp; this.applicationContext != null) &#123;</span><br><span class="line">		String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				this.applicationContext, ViewResolver.class, true, false);</span><br><span class="line">		if (names.length == 1) &#123;</span><br><span class="line">			registry.getViewResolvers().add(new InternalResourceViewResolver());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ViewResolverComposite composite = new ViewResolverComposite();</span><br><span class="line">	composite.setOrder(registry.getOrder());</span><br><span class="line">	composite.setViewResolvers(registry.getViewResolvers());</span><br><span class="line">	if (this.applicationContext != null) &#123;</span><br><span class="line">		composite.setApplicationContext(this.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	if (this.servletContext != null) &#123;</span><br><span class="line">		composite.setServletContext(this.servletContext);</span><br><span class="line">	&#125;</span><br><span class="line">	return composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，加了@EnableWebMVC的注解，引入WebMVCConfigurationSupport类，创建配置类，Spring容器中就会有了许多SpringMVC组件的默认配置的Bean，然后在SpringMVC的DispatcherServlet中，需要组件初始化的时候就可以从Spring容器中获取这些默认的Bean</p>
<p>这样一来，运行添加的Tomcat插件（Tomcat版本最高为7…) ，就可顺利运行SpringMVC项目<br>如果想配置SpringMVC的其他属性，比如静态资源，模板引擎，文件上传的大小..<br>需要声明一个配置类，实现WebMvcConfigurer类，重写里面的方法即可</p>
<h1 id="SpringMVC运行的初始化"><a href="#SpringMVC运行的初始化" class="headerlink" title="SpringMVC运行的初始化"></a>SpringMVC运行的初始化</h1><p>SpringMVC的运行，离不开九大组件，而且SpringMVC的本质就是一个Servlet，所以在Tomcat启动的时候就会调用Init方法对Servlet的方法进行初始化<br>这里就要说一下SpringMVC的三个Servlet<br><img src="/2019/02/12/详解SpringMVC/20190213115117039.png" alt=""><br>红线上部分是Servlet的类，下部分是SpringMVC的三个Servlet（哎，反正就是一个Servlet）<br>所以注册Servlet的时候就会调用Servlet的init方法</p>
<h2 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h2><p>先执行HTTPServletBean的init方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * init()中，首先将Servlet中的配置参数使用BeanWrapper设置到DispatcherServlet的相关属性</span><br><span class="line">	 * 然后调用模板方法initServletBean()初始化</span><br><span class="line">	 */</span><br><span class="line">	public final void init() throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">		// 将Servlet中的配置参数封装到pvs中</span><br><span class="line">		// Set bean properties from init parameters.</span><br><span class="line">		PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);</span><br><span class="line">		if (!pvs.isEmpty()) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				// bw为DispatcherServlet</span><br><span class="line">				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</span><br><span class="line">				ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());</span><br><span class="line">				bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">				// 模板方法，可以在子类调用，做一些初始化工作，bw就是DispatcherServlet，</span><br><span class="line">				// 也就是初始化DispatcherServlet</span><br><span class="line">				initBeanWrapper(bw);</span><br><span class="line">				// 将配置的初始值（如contextConfigLocation)设置到DispaterServlet</span><br><span class="line">				bw.setPropertyValues(pvs, true);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isErrorEnabled()) &#123;</span><br><span class="line">					logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Let subclasses do whatever initialization they like.</span><br><span class="line">		// 一般都是FrameWorkServlet的初始化入口</span><br><span class="line">		initServletBean();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>然后调用FrameworkServlet的<strong> initServletBean </strong> 方法，但是<strong> initServlet </strong> 方法中，又调用<strong> initWebApplicationContext（）</strong> 方法初始化容器，所以FrameworkServlet的关键初始话方法就是<strong> initWebApplicationContext() </strong> 方法了<br>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext initWebApplicationContext() &#123;</span><br><span class="line">		/*----------------------------------------------------------*/</span><br><span class="line">		// initWebApplicationContext方法主要做了三件事：</span><br><span class="line">			// 1、获取spring的根容器rootContext</span><br><span class="line">			// 2、设置webApplicationContext并根据情况调用refresh方法</span><br><span class="line">			// 3、将webApplicationContext设置到Servlet中</span><br><span class="line">		/*----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">		// 1</span><br><span class="line">		WebApplicationContext rootContext =</span><br><span class="line">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">		WebApplicationContext wac = null;</span><br><span class="line"></span><br><span class="line">		if (this.webApplicationContext != null) &#123;</span><br><span class="line">			// A context instance was injected at construction time -&gt; use it</span><br><span class="line">			wac = this.webApplicationContext;</span><br><span class="line">			if (wac instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">				if (!cwac.isActive()) &#123;</span><br><span class="line">					// The context has not yet been refreshed -&gt; provide services such as</span><br><span class="line">					// setting the parent context, setting the application context id, etc</span><br><span class="line">					if (cwac.getParent() == null) &#123;</span><br><span class="line">						// The context instance was injected without an explicit parent -&gt; set</span><br><span class="line">						// the root application context (if any; may be null) as the parent</span><br><span class="line">						cwac.setParent(rootContext);</span><br><span class="line">					&#125;</span><br><span class="line">					// 2</span><br><span class="line">					configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (wac == null) &#123;</span><br><span class="line">			// No context instance was injected at construction time -&gt; see if one</span><br><span class="line">			// has been registered in the servlet context. If one exists, it is assumed</span><br><span class="line">			// that the parent context (if any) has already been set and that the</span><br><span class="line">			// user has performed any initialization such as setting the context id</span><br><span class="line">			wac = findWebApplicationContext();</span><br><span class="line">		&#125;</span><br><span class="line">		if (wac == null) &#123;</span><br><span class="line">			// No context instance is defined for this servlet -&gt; create a local one</span><br><span class="line">			wac = createWebApplicationContext(rootContext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!this.refreshEventReceived) &#123;</span><br><span class="line">			// Either the context is not a ConfigurableApplicationContext with refresh</span><br><span class="line">			// support or the context injected at construction time had already been</span><br><span class="line">			// refreshed -&gt; trigger initial onRefresh manually here.</span><br><span class="line">			synchronized (this.onRefreshMonitor) &#123;</span><br><span class="line">				//2</span><br><span class="line">				onRefresh(wac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (this.publishContext) &#123;</span><br><span class="line">			// 3</span><br><span class="line">			// Publish the context as a servlet context attribute.</span><br><span class="line">			String attrName = getServletContextAttributeName();</span><br><span class="line">			getServletContext().setAttribute(attrName, wac);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return wac;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>webApplicationContext在我们的配置类中已经注册给DispatcherServlet，DispatcherServlet又把WebApplication交给FrameworkServlet，所以这里会执行<strong> configureAndRefreshWebApplicationContext(cwac) </strong> 方法<br>如果没有webApplicationContext则SpringMVC自己创建createWebApplicationContext()，内部也是调用configureAndRefreshWebApplicationContext方法</p>
<p>org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) &#123;</span><br><span class="line">		if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">			// The application context id is still set to its original default value</span><br><span class="line">			// -&gt; assign a more useful id based on available information</span><br><span class="line">			if (this.contextId != null) &#123;</span><br><span class="line">				wac.setId(this.contextId);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// Generate default id...</span><br><span class="line">				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">						ObjectUtils.getDisplayString(getServletContext().getContextPath()) + &apos;/&apos; + getServletName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 设置ServletContext容器，这很重要，九大组件的创建需要ServletContext</span><br><span class="line">		wac.setServletContext(getServletContext());</span><br><span class="line">		// 设置ServletConfig</span><br><span class="line">		wac.setServletConfig(getServletConfig());</span><br><span class="line">		wac.setNamespace(getNamespace());</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 这里添加了一个监听器，这个监听器很重要</span><br><span class="line">		 * 监听的是ContextRefreshListener事件，也就是容器刷新时的事件</span><br><span class="line">		 * 当发生刷新容器事件时，会调用FrameworkServlet的onApplicationEvent方法</span><br><span class="line">		 * 该方法里面就会调用onRefresh（）进行初始化九大组件</span><br><span class="line">		 */</span><br><span class="line">		wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">		// The wac environment&apos;s #initPropertySources will be called in any case when the context</span><br><span class="line">		// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span><br><span class="line">		// use in any post-processing or initialization that occurs below prior to #refresh</span><br><span class="line">		ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">		if (env instanceof ConfigurableWebEnvironment) &#123;</span><br><span class="line">			((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		postProcessWebApplicationContext(wac);</span><br><span class="line">		applyInitializers(wac);</span><br><span class="line">		// 刷新容器</span><br><span class="line">		wac.refresh();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里最重要的就是添加了ContextRefreshListener监听器，这个监听器很重要，在代码的最后调用<strong> wac.refresh </strong> 刷新后，会执行这个ContextRefreshListener监听器触发事件<br>ContextRefreshListener是Framework的内部类里面只有一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">			FrameworkServlet.this.onApplicationEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>onApplicationEvent方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">		this.refreshEventReceived = true;</span><br><span class="line">		synchronized (this.onRefreshMonitor) &#123;</span><br><span class="line">			onRefresh(event.getApplicationContext());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是当发生容器的刷新时，最后会执行<strong> onRefresh </strong> 方法，该方法在DispatcherServlet具体实现</p>
<ul>
<li>注：wac.refresh() 方法就是Spring-Context的知识，也就是IOC，Bean的生成管理等，这里不深入阐述<br>来看下DispatcherServlet</li>
</ul>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>上面说到当发生刷新容器的事件时，会调用<strong> onRefresh </strong> 方法，该方法在DispatcherServlet中具体实现，而里面只是调用了<strong> initStrategies </strong> 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected void onRefresh(ApplicationContext context) &#123;</span><br><span class="line">		// 只执行了initStrategies方法</span><br><span class="line">		initStrategies(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected void initStrategies(ApplicationContext context) &#123;</span><br><span class="line">		// 初始化MultipartResolver组件</span><br><span class="line">		// 该组件是用来处理上传文件请求，只是没有默认实现</span><br><span class="line">		initMultipartResolver(context);</span><br><span class="line">		// 初始化LocaleResolver</span><br><span class="line">		// 该组件的作用是可以通过request解析出Locale，Locale是对当前区域的声明</span><br><span class="line">		initLocaleResolver(context);</span><br><span class="line">		// 初始化ThemeResolver</span><br><span class="line">		// 该组件的作用是可以通过request解析出Theme主题</span><br><span class="line">		initThemeResolver(context);</span><br><span class="line">		// 初始化HandlerMapping组件</span><br><span class="line">		// 该组件的作用是存储URL跟Controller之间的映射</span><br><span class="line">		initHandlerMappings(context);</span><br><span class="line">		// 初始化HandlerAdapters</span><br><span class="line">		// 该组件的作用是可以用Handler（Controller）执行请求</span><br><span class="line">		initHandlerAdapters(context);</span><br><span class="line">		// 初始化HandlerExceptionResolvers组件</span><br><span class="line">		// 该组件的作用是对页面渲染前的异常进行处理。然后渲染在View里面</span><br><span class="line">		initHandlerExceptionResolvers(context);</span><br><span class="line">		// 初始化RequestToViewNamTranslator组件</span><br><span class="line">		// 该组件的作用是，如果Controller没有返回值，则通过request确定ViewName值,然后查询View</span><br><span class="line">		initRequestToViewNameTranslator(context);</span><br><span class="line">		// 初始化ViewResolvers组件</span><br><span class="line">		// 该组件的作用是将String类型的视图名和Locale解析为View类型的视图</span><br><span class="line">		initViewResolvers(context);</span><br><span class="line">		// 初始化FlashMapManager组件</span><br><span class="line">		// 该组件的作用是用于管理FlashMap的</span><br><span class="line">		initFlashMapManager(context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，SpringMVC的初始化就到这了，下面来看下当一个请求过来时，SpringMVC是怎么工作的</p>
<h1 id="SpringMVC对请求的处理过程"><a href="#SpringMVC对请求的处理过程" class="headerlink" title="SpringMVC对请求的处理过程"></a>SpringMVC对请求的处理过程</h1><p>我们事先写一个Controller<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;Hello Tomcat!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来具体跟踪一下，当我们输入请求localhost:8080/hello，SpringMVC里面是怎么处理的</p>
<h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><p>首先，请求会先到达Tomcat，Tomcat会分配一个Socket线程来连接它，接着封装request和response，然后交给具体的Servlet，这里就是使用我们的DispatcherServlet，所以请求就从Servlet容器（Tomcat）传递到Servlet     （发生在：Servlet容器）</p>
<h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><p>接着，HttpServlet先处理，在service方法中，将ServletRequest和ServletResponse转换成HttpServletRequest和HttpServletResponse，并调用service方法  （发生在：Servlet-api的HttpServlet中）</p>
<h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>接下来SpringMVC出场了，FrameworkServlet的service首先处理，但是，service方法又会将请求先交给HttpServlet的service处理  （发生在：FrameworkServlet）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 实现了HttpServlet的service方法</span><br><span class="line">	 * 不管是什么请求，最后都会走processRequest方法</span><br><span class="line">	 * Override the parent class implementation in order to intercept PATCH requests.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void service(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		// 添加了对PATCH请求的处理</span><br><span class="line">		HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">		if (httpMethod == HttpMethod.PATCH || httpMethod == null) &#123;</span><br><span class="line">			processRequest(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		// 其他类型全部交给父类处理，也就是交给HttpServlet处理</span><br><span class="line">		// 但是由于FrameworkServlet重写了get，post，put等请求方法，最后还是会调用该类的</span><br><span class="line">		// 其他请求方法比如doGet()</span><br><span class="line">		else &#123;</span><br><span class="line">			super.service(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		// 反正不管是什么方法，最后都会走processRequest方法</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><p>在HttpServlet的service方法中，会根据请求的类型将请求传递到doGet方法  （发生在：HttpServlet中）</p>
<h2 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h2><p>由于FrameworkServlet实现了doGet方法，所以请求又回到了FrameworkServlet中，而doGet方法中只调用了<strong> processRequest </strong> 方法。这里需要说明一下，几乎所有的请求都会交给<strong> processRequest </strong> 方法处理<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected final void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	protected final void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p><strong> processRequest </strong> 里面有调用 <strong> doService </strong> 方法，该方法在DispatcherServlet中具体实现，也就是说最后将请求交给了DispatcherServlet （发生在FrameworkServlet中）</p>
<h2 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h2><p>DispatcherServlet的doService方法将webApplicationContext、localeResolver、themeResolver、outputFlashMap和FlashMapManager设置到了request属性中，然后将请求交给doDispatch方法中  （发生在：DispatcherServlet）<br>org.springframework.web.servlet.DispatcherServlet#doService<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		logRequest(request);</span><br><span class="line">		// 对include请求，进行request的attribute做快照备份</span><br><span class="line">		Map&lt;String, Object&gt; attributesSnapshot = null;</span><br><span class="line">		if (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">			attributesSnapshot = new HashMap&lt;&gt;();</span><br><span class="line">			Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">			while (attrNames.hasMoreElements()) &#123;</span><br><span class="line">				String attrName = (String) attrNames.nextElement();</span><br><span class="line">				if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">					attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 对request设置一些属性，在handler和view中需要使用到</span><br><span class="line">		// Make framework objects available to handlers and view objects.</span><br><span class="line">		request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">		request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</span><br><span class="line">		request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);</span><br><span class="line">		request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line">		if (this.flashMapManager != null) &#123;</span><br><span class="line">			// 都跟FlashMap 有关，主要作用域redirect转发时参数的传递</span><br><span class="line">			// 应用场景：</span><br><span class="line">			// 			当你提交完订单后，需要重定向到一个页面，但是重定向无法传递参数过去</span><br><span class="line">			//			这时，你可以使用FlashMap帮助你完成参数的传递</span><br><span class="line"></span><br><span class="line">			// 每次处理请求时，都会先判断一下FlashMap中是否有数据</span><br><span class="line">			// 如果有就先设置到 inputFlashMap里面，也就是保存上次转发过来的属性</span><br><span class="line">			// 再设置到Model里面</span><br><span class="line">			FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">			if (inputFlashMap != null) &#123;</span><br><span class="line">				request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">			&#125;</span><br><span class="line">			// OUTPUT_FLASH_MAP_ATTRIBUTE用于保存本次请求需要转发的属性</span><br><span class="line">			request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());</span><br><span class="line">			request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 最后将请求交给doDispatch</span><br><span class="line">			doDispatch(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				// Restore the original attribute snapshot, in case of an include.</span><br><span class="line">				// 还原request的快照属性</span><br><span class="line">				if (attributesSnapshot != null) &#123;</span><br><span class="line">					restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7、"><a href="#7、" class="headerlink" title="7、"></a>7、</h2><p>doDispatch是DispatcherServlet中最重要的方法，里面有很多判断和操作，但是主要有四个功能。在此之前先说下Handler、HandlerMapping跟HandlerAdapter三者之间的关系，还有View跟ViewResolver</p>
<h3 id="Handler、HandlerMapping跟HandlerAdapter"><a href="#Handler、HandlerMapping跟HandlerAdapter" class="headerlink" title="Handler、HandlerMapping跟HandlerAdapter"></a>Handler、HandlerMapping跟HandlerAdapter</h3><p>Handler：就是我们编写的Controller控制器<br>HandlerMapping：可以用来速查Handler，可以根据request返回HandlerExecutionChain，HandlerExecutionChain里面包含Handler跟Interceptor<br>HandlerAdapter：当要执行我们的Controller时，SpringMVC就会使用HandlerAdapter来执行，调用handle方法，执行完返回ModelAndView<br>我们可以这样理解，Handler就是工具，可以用来做某件事；HandlerMapping是存放工具的清单，标明了工具放在哪里；HandlerAdapter就是使用工具干活的工人。</p>
<h3 id="View跟ViewResolver"><a href="#View跟ViewResolver" class="headerlink" title="View跟ViewResolver"></a>View跟ViewResolver</h3><p>View是用来展示数据的<br>ViewResolver是用来查找View的<br>做完请求工作后，需要返回结果，而返回结果就需要模板，View就是所需的模板，ViewResolver就是用来选择哪个模板</p>
<p>这四个功能分别为：一、使用HandlerMapping找到可以干活的Handler； 二、找到合适的HandlerAdapter让他去干活； 三、让HandlerAdapter开始干活，干完活后返回数据； 四、将返回的数据进行处理，封装成View展示给用户<br>先来看下doDispatch方法的代码，具体代码再分析<br>org.springframework.web.servlet.DispatcherServlet#doDispatch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		/**</span><br><span class="line">		 *</span><br><span class="line">		 *   doDispatch中最重要的代码总共有四句（见下面的标签数字）</span><br><span class="line">		 *</span><br><span class="line">		 *   Handler、HandlerMapping、HandlerAdapter三者的关系：</span><br><span class="line">		 *   	Handler：就是我们的控制器Controller中加了@XXXMapping的方法</span><br><span class="line">		 *   	HandlerMapping：	用来快速查找Handler</span><br><span class="line">		 *   	HandlerAdapter：调用Handler来干活，而且不同Handler需要不同的Adapter</span><br><span class="line">		 *   这就好比HandlerAdapter是工人，Handler是工具，HandlerMapping是根据加工的需求来选择用什么设备</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 封装Request，如果不是上传请求则直接使用接收到的request</span><br><span class="line">		 * 如果是上传请求，重新封装成MultipartHttpServletRequest</span><br><span class="line">		 */</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		/**</span><br><span class="line">		 * 处理请求的处理器链</span><br><span class="line">		 * 包含有处理器Handler和对应的拦截器Interceptor</span><br><span class="line">		 */</span><br><span class="line">		HandlerExecutionChain mappedHandler = null;</span><br><span class="line">		/**</span><br><span class="line">		 * 是否为上传请求的标记</span><br><span class="line">		 */</span><br><span class="line">		boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 从request中获取异步请求</span><br><span class="line">		 */</span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			/**</span><br><span class="line">			 * View 跟 ViewResolver</span><br><span class="line">			 * View 是用来展示数据的</span><br><span class="line">			 * 而ViewResolver是用来查找View的</span><br><span class="line">			 * 做完请求工作后，需要返回结果，而返回结果就需要模板，</span><br><span class="line">			 * View就是所需要的模板，ViewResolver就是来选择哪个模板</span><br><span class="line">			 *</span><br><span class="line">			 * **/</span><br><span class="line">			ModelAndView mv = null;</span><br><span class="line">			/**</span><br><span class="line">			 * 异常声明</span><br><span class="line">			 * doDispatch()中对异常又两种处理方法：</span><br><span class="line">			 * 		一、如果是处理请求中出现的异常，会捕获并在processDispatchResult中渲染到最后的视图中</span><br><span class="line">			 * 		二、如果是渲染中出现异常，则直接抛出</span><br><span class="line">			 */</span><br><span class="line">			Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// 检查是不是上传请求</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">				/** 第一句</span><br><span class="line">				 *  使用HandlerMapping找到可以干活的Handler</span><br><span class="line">				 *</span><br><span class="line">				 * **/</span><br><span class="line">				// Determine handler for the current request.</span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				if (mappedHandler == null) &#123;</span><br><span class="line">					// 找不到Handler返回404</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 第二句</span><br><span class="line">				 * 	找到合适的HandlerAdapter去让他干活</span><br><span class="line">				 * **/</span><br><span class="line">				// Determine handler adapter for the current request.</span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// 处理GET、HEAD请求的last-modified</span><br><span class="line">				// Process last-modified header, if supported by the handler.</span><br><span class="line">				/**</span><br><span class="line">				 * Last-Modified是HTTP头部的一种属性，表示当前请求的资源跟上一次请求的资源是否相同</span><br><span class="line">				 * 如果相同，返回304并且没有新的实体（body)返回</span><br><span class="line">				 * 否则返回新的实体内容</span><br><span class="line">				 *</span><br><span class="line">				 * 在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是客户端请求的资源，</span><br><span class="line">				 * 同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</span><br><span class="line">				 * 客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过</span><br><span class="line">				 * 如果服务器端的资源没有变化，则自动返回 HTTP 304（Not Changed.）状态码，内容为空，这样就节省了传输数据量。</span><br><span class="line">				 * 当服务器端代码发生改变或者重启服务器时，则重新发出资源，</span><br><span class="line">				 * 返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</span><br><span class="line">				 */</span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">				if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 如果有拦截器，就饿执行我们的拦截器，preHandle前置处理**/</span><br><span class="line">				if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 第三句</span><br><span class="line">				 * 	让HandlerAdapter开始干活，干完活后返回数据</span><br><span class="line">				 * **/</span><br><span class="line">				// Actually invoke the handler.</span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// 如果需要异步处理，则直接返回</span><br><span class="line">				/**</span><br><span class="line">				 * 因为异步处理会重新开启一个线程去执行结果的返回</span><br><span class="line">				 * 不会占用目前这个线程，所以可以直接返回</span><br><span class="line">				 */</span><br><span class="line">				if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 当view为空时（比如，handler返回类型为void），根据request设置默认view</span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line">				/** 执行了拦截器的后置处理 postHandle**/</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				dispatchException = ex;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable err) &#123;</span><br><span class="line">				// As of 4.3, we&apos;re processing Errors thrown from handler methods as well,</span><br><span class="line">				// making them available for @ExceptionHandler methods and other scenarios.</span><br><span class="line">				dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);</span><br><span class="line">			&#125;</span><br><span class="line">			/** 第四句</span><br><span class="line">			 * 	将数据处理，通过View展示给用户</span><br><span class="line">			 * 	处理结果，包括处理异常，渲染页面，发出完成通知，触发拦截器的afterCompletion</span><br><span class="line">			 * **/</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable err) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">					new NestedServletException(&quot;Handler processing failed&quot;, err));</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			// 判断是否为异步请求</span><br><span class="line">			if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				// 执行异步的拦截器</span><br><span class="line">				// Instead of postHandle and afterCompletion</span><br><span class="line">				if (mappedHandler != null) &#123;</span><br><span class="line">					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// 删除上传请求的资源，不然会产生临时的资源</span><br><span class="line">				// Clean up any resources used by a multipart request.</span><br><span class="line">				if (multipartRequestParsed) &#123;</span><br><span class="line">					cleanupMultipart(processedRequest);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="8、"><a href="#8、" class="headerlink" title="8、"></a>8、</h2><p>getHandler方法获取Handler的过程，会遍历容器中所有的HandlerMapping，上面说到的WebMVCConfigurationSupport会默认创建RequestMappingHandlerMapping和BeanNameUrlHandlerMapping，在用RequestMappingHandlerMapping匹配时，我们的请求会和其初始化时读取到定义的@RequestMapping(“hello”)所注解里面的内容相匹配，然后根据这个条件找到定义的处理器方法，也就是我们的hello()方法<br> （发生在：RequestMappingHandlerMapping）<br> org.springframework.web.servlet.DispatcherServlet#getHandler<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	if (this.handlerMappings != null) &#123;</span><br><span class="line">		for (HandlerMapping mapping : this.handlerMappings) &#123;</span><br><span class="line">			HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">			if (handler != null) &#123;</span><br><span class="line">				return handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="9、"><a href="#9、" class="headerlink" title="9、"></a>9、</h2><p> 如果是使用@PathVariable注解，则会使用RequestMappingInfoHandlerMapping里的handleMatch方法会将匹配到的Pattern设置到Request属性中，这里我们没有使用@PathVariable，所以跳过</p>
<h2 id="10、"><a href="#10、" class="headerlink" title="10、"></a>10、</h2><p> 找到Handler后，接着调用getHandlerAdapter方法根据Handler查找HandlerAdapter，也就是根据工具找到工人。查找的方式也是遍历配置的所有HandlerAdapter，然后分别调用他们的supports方法进行检查，判断Handler的类型是否支持。WebMvcConfigrationSupport类默认配置的HandlerAdapter是RequestMappingHandlerAdapter、HttpRequstHandlerAdapter和SimpleControllerHandlerAdapter，最后找到RequestMappingHandlerAdapter （发生在：DispatcherServlet）</p>
<h2 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h2><p> 接下来检查到请求时GET请求，然后检查是否可以使用缓存（我那一大段注释可以看看），因为是第一次请求，所以不使用缓存；接着调用HandlerInterceptor的preHandler方法，这里我们没有配置拦截器，所以跳过。接下来用RequestMappingHandlerAdapter使用Handler处理请求，也就是调用 mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  （发生在：DispatcherServlet中）</p>
<h2 id="12、"><a href="#12、" class="headerlink" title="12、"></a>12、</h2><p> HandlerAdapter的实现一般都很复杂，因为它要封装参数，参数有ModelAttribute，SessionAttributes，FlashMap，Request中的参数等等，所以RequestMappingHandlerAdapter会先将需要的参数封装，这里我们没有设置参数，可省略，接着讲请求传递给invokeHandleMethod方法 （发生在：RequestMappingHandlerAdapter）</p>
<h2 id="13、"><a href="#13、" class="headerlink" title="13、"></a>13、</h2><p>invokeHandleMethod方法首先创建WebDataBinderFactory、ModelFactory和ServletInvocableHandlerMethod。<br>WebDataBinderFactory跟@InitBinder注解的绑定参数有关<br>ModelFactory主要是对Model的初始化和更新<br>ServletInvocableHandlerMethod就是执行请求，参数的绑定<br> 而且，不同类型的参数的解析器是不同的，比如@PathVariable参数、RedirectAttributes参数、Model里的参数分别对应PathVariableMethodArgumentResolver、RedirectAttributeMethodArgumentResolver和ModelMethodProcessor<br> 具体执行在doInvoke中<br> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">protected ModelAndView invokeHandlerMethod(HttpServletRequest request,</span><br><span class="line">		HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	ServletWebRequest webRequest = new ServletWebRequest(request, response);</span><br><span class="line">	try &#123;</span><br><span class="line">		// 需要下面这三个工具</span><br><span class="line">		// WebDataBinderFactory的创建过程是将注解了@InitBinder的方法找出来，并</span><br><span class="line">			// 使用它们新建出ServletRequestDataBinderFactory类型的WebDataBinderFactory</span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line"></span><br><span class="line">		// ModelFactory主要有两个功能：一、在处理器具体处理前对Model进行初始化</span><br><span class="line">									//二、处理完请求后对Model参数进行更新</span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">		// 实际请求的处理就是通过它来执行的， 参数的绑定、处理请求以及返回值处理都在它里边完成</span><br><span class="line">		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line"></span><br><span class="line">		// 将argumentsResolvers、returnValueHandlers、binderFactory</span><br><span class="line">		// paramterNameDiscoverer设置进去invocableMethod中</span><br><span class="line">		if (this.argumentResolvers != null) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.returnValueHandlers != null) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">		// 新建ModelAndViewContainer容器， 并将相应的参数设置到Model中</span><br><span class="line">		ModelAndViewContainer mavContainer = new ModelAndViewContainer();</span><br><span class="line">		// 设置FlashMap</span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">		// 使用ModelFactory将SessionAttribute和注释了@ModelAttribute的方法的参数设置到Model</span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">		//</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">		// 异步处理的相关工作</span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(this.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(this.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(this.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		if (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">				String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">				return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;</span><br><span class="line">			&#125;);</span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 执行请求</span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 处理完请求的后置处理</span><br><span class="line">		return getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="14、"><a href="#14、" class="headerlink" title="14、"></a>14、</h2><p> 当执行完HandlerMethod（也就是执行完我们的Controller代码后），调用getModelAndView方法（我们代码执行完后的数据都设置在ModelAndViewContainer中）<br> 方法中使用ModelAndViewContainer中的Model和View创建ModelAndView，将值返回给DispatcherServlet<br> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getModelAndView<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,</span><br><span class="line">		ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	// 更新Model（包括设置SessionAttribute）</span><br><span class="line">	modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">	if (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	ModelMap model = mavContainer.getModel();</span><br><span class="line">	// 创建ModelAndView</span><br><span class="line">	ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">	if (!mavContainer.isViewReference()) &#123;</span><br><span class="line">		mav.setView((View) mavContainer.getView());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 如果是RedirectAttributes（重定向请求）</span><br><span class="line">	// 则将其值设置到FlashMap中</span><br><span class="line">	if (model instanceof RedirectAttributes) &#123;</span><br><span class="line">		Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">		if (request != null) &#123;</span><br><span class="line">			RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> (发生在：RequestMappingHandlerAdapter）</p>
<h2 id="15、"><a href="#15、" class="headerlink" title="15、"></a>15、</h2><p> 然后判断返回的View是否为空，如果为空就使用RequestToViewNameTranslatior查找默认视图，接着调用HandlerInterceptor的后置方法applyPostHandle</p>
<h2 id="16、"><a href="#16、" class="headerlink" title="16、"></a>16、</h2><p> 最后就调用processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); 将结果渲染，里面是调用render方法进行页面的渲染。调用resolveViewName方法解析出View，解析过程使用到了ViewResolver，这里使用的是默认配置InternalResourceViewResolver（它可以处理jsp视图）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">		@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span><br><span class="line">		@Nullable Exception exception) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	boolean errorView = false;</span><br><span class="line"></span><br><span class="line">	// 如果处理请求过程中有异常抛出</span><br><span class="line">	if (exception != null) &#123;</span><br><span class="line">		if (exception instanceof ModelAndViewDefiningException) &#123;</span><br><span class="line">			logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);</span><br><span class="line">			mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 将错误内容设置到View中</span><br><span class="line">			Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);</span><br><span class="line">			mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">			errorView = (mv != null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Did the handler return a view to render?</span><br><span class="line">	if (mv != null &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * -------------------------------</span><br><span class="line">		 * 渲染页面就是在这个render方法中执行的</span><br><span class="line">		 * -------------------------------</span><br><span class="line">		 */</span><br><span class="line">		render(mv, request, response);</span><br><span class="line">		if (errorView) &#123;</span><br><span class="line">			WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">		// Concurrent handling started during a forward</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (mappedHandler != null) &#123;</span><br><span class="line">		mappedHandler.triggerAfterCompletion(request, response, null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 至此，SpringMVC的分析到此结束，里面还有很多东西没有说到，比如FlashMap是什么东西，FlashMap是怎么传递和管理的，九大组件各个组件的作用是什么，九大组件的实现类都有哪些..<br> 我们只是讲讲SpringMVC的冰山一角而已</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/SpringMVC/" rel="tag"># SpringMVC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/12/SpringMVC的M、V、C到底是什么东西/" rel="next" title="SpringMVC的M、V、C到底是什么东西">
                <i class="fa fa-chevron-left"></i> SpringMVC的M、V、C到底是什么东西
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/" rel="prev" title="Spring-Mybatis把接口变成Bean的秘密">
                Spring-Mybatis把接口变成Bean的秘密 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">SouthLight Lin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringMVC的本质"><span class="nav-number">1.</span> <span class="nav-text">SpringMVC的本质</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#运行SpringMVC的前期准备"><span class="nav-number">2.</span> <span class="nav-text">运行SpringMVC的前期准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#这里为什么要加-EnableWebMVC注解呢？"><span class="nav-number">2.1.</span> <span class="nav-text">这里为什么要加@EnableWebMVC注解呢？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringMVC运行的初始化"><span class="nav-number">3.</span> <span class="nav-text">SpringMVC运行的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HttpServletBean"><span class="nav-number">3.1.</span> <span class="nav-text">HttpServletBean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FrameworkServlet"><span class="nav-number">3.2.</span> <span class="nav-text">FrameworkServlet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatcherServlet"><span class="nav-number">3.3.</span> <span class="nav-text">DispatcherServlet</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringMVC对请求的处理过程"><span class="nav-number">4.</span> <span class="nav-text">SpringMVC对请求的处理过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、"><span class="nav-number">4.1.</span> <span class="nav-text">1、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、"><span class="nav-number">4.2.</span> <span class="nav-text">2、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、"><span class="nav-number">4.3.</span> <span class="nav-text">3、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、"><span class="nav-number">4.4.</span> <span class="nav-text">4、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、"><span class="nav-number">4.5.</span> <span class="nav-text">5、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、"><span class="nav-number">4.6.</span> <span class="nav-text">6、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、"><span class="nav-number">4.7.</span> <span class="nav-text">7、</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Handler、HandlerMapping跟HandlerAdapter"><span class="nav-number">4.7.1.</span> <span class="nav-text">Handler、HandlerMapping跟HandlerAdapter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View跟ViewResolver"><span class="nav-number">4.7.2.</span> <span class="nav-text">View跟ViewResolver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、"><span class="nav-number">4.8.</span> <span class="nav-text">8、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、"><span class="nav-number">4.9.</span> <span class="nav-text">9、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、"><span class="nav-number">4.10.</span> <span class="nav-text">10、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、"><span class="nav-number">4.11.</span> <span class="nav-text">11、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、"><span class="nav-number">4.12.</span> <span class="nav-text">12、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、"><span class="nav-number">4.13.</span> <span class="nav-text">13、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、"><span class="nav-number">4.14.</span> <span class="nav-text">14、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15、"><span class="nav-number">4.15.</span> <span class="nav-text">15、</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16、"><span class="nav-number">4.16.</span> <span class="nav-text">16、</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SouthLight Lin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
