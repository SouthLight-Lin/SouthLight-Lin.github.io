<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Kafka,">










<meta name="description" content="What’s Kafka？官方定义，Kafka是一款开源的消息引擎系统。消息引擎系统是一种规范，利用这种规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递举个例子：比如系统A发送消息给消息引擎系统（Kafka），系统B从消息引擎中读取A的消息  注：Kafka发展到现在是2.0版本了，现在致力于流处理平台，这篇博客讨论的还是Kafka消息引擎，对于Kafka的流处理，可以自行goog">
<meta name="keywords" content="Kafka">
<meta property="og:type" content="article">
<meta property="og:title" content="初识Kafka">
<meta property="og:url" content="http://yoursite.com/2019/11/23/初识Kafka/index.html">
<meta property="og:site_name" content="SouthLight&#39;s Blog">
<meta property="og:description" content="What’s Kafka？官方定义，Kafka是一款开源的消息引擎系统。消息引擎系统是一种规范，利用这种规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递举个例子：比如系统A发送消息给消息引擎系统（Kafka），系统B从消息引擎中读取A的消息  注：Kafka发展到现在是2.0版本了，现在致力于流处理平台，这篇博客讨论的还是Kafka消息引擎，对于Kafka的流处理，可以自行goog">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123030442600.png">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123035549442.png">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123040402203.png">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123040423457.png">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123042531211.png">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123044031994.png">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123044111034.png">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123044221995.png">
<meta property="og:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123044307339.png">
<meta property="og:updated_time" content="2019-11-23T15:12:23.092Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="初识Kafka">
<meta name="twitter:description" content="What’s Kafka？官方定义，Kafka是一款开源的消息引擎系统。消息引擎系统是一种规范，利用这种规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递举个例子：比如系统A发送消息给消息引擎系统（Kafka），系统B从消息引擎中读取A的消息  注：Kafka发展到现在是2.0版本了，现在致力于流处理平台，这篇博客讨论的还是Kafka消息引擎，对于Kafka的流处理，可以自行goog">
<meta name="twitter:image" content="http://yoursite.com/2019/11/23/初识Kafka/20191123030442600.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/23/初识Kafka/">





  <title>初识Kafka | SouthLight's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SouthLight's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/23/初识Kafka/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">初识Kafka</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-23T10:16:24+08:00">
                2019-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Kafka/" itemprop="url" rel="index">
                    <span itemprop="name">Kafka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="What’s-Kafka？"><a href="#What’s-Kafka？" class="headerlink" title="What’s Kafka？"></a>What’s Kafka？</h1><p>官方定义，Kafka是一款<strong>开源的消息引擎系统</strong>。消息引擎系统是一种规范，利用这种规范在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递<br>举个例子：比如系统A发送消息给消息引擎系统（Kafka），系统B从消息引擎中读取A的消息</p>
<ul>
<li>注：Kafka发展到现在是2.0版本了，现在致力于流处理平台，这篇博客讨论的还是Kafka消息引擎，对于Kafka的流处理，可以自行google了解下</li>
</ul>
<h1 id="Kafka能解决什么"><a href="#Kafka能解决什么" class="headerlink" title="Kafka能解决什么"></a>Kafka能解决什么</h1><p>1、 异步处理<br>2、 流量控制<br>3、 服务解耦<br>4、 削峰填谷：保护下游系统，防止下游系统被压垮</p>
<h1 id="Kafka传输消息的两种方式"><a href="#Kafka传输消息的两种方式" class="headerlink" title="Kafka传输消息的两种方式"></a>Kafka传输消息的两种方式</h1><p>1、 点对点：生产生产的消息只能被一个消费者消费<br>2、 发布/订阅模型：生产者生产的消息，被多个订阅的消费者消费</p>
<h1 id="Kafka中的术语"><a href="#Kafka中的术语" class="headerlink" title="Kafka中的术语"></a>Kafka中的术语</h1><p>先来看一张图<br><img src="/2019/11/23/初识Kafka/20191123030442600.png" alt=""><br>1、 Record（消息）：主要是指发送到Kafka，Kafka处理的对象<br>2、 Broker：你可以简单的理解，一个Broker就是一个Kafka进程（如果你一台服务器运行多个Kafka，那就代表有多个Broker），一个Kafka集群可以有多个Broker组成，Broker负责接受消息和处理客户端发送过来的请求，以及对消息进行持久化。<br>3、 Topic（主题）：发布订阅的对象，你可以为每个业务、每个应用甚至每类数据都创建专属的主题（比如，商品系统跟订单系统需要消息通信，那么你可以在Kafka上创建一个Topic名字叫order_good_topic，两个系统同时指定这个topic就可完成通信）<br>4、 Producer（生产者）：向主题发送消息的客户端程序，生产者可以不断地向一个或多个主题发送消息<br>5、 Consumer（消费者）：订阅这些主题的客户端程序，消费者可以同时订阅多个主题<br>6、 Replica（副本）：相当于备份。Kafka中同一条消息能够被拷贝到多个地方一提供数据冗余，这些地方就是副本。<br>7、Leader Replica（领导者副本）：对外提供服务<br>8、Follower Replica（追随者副本）：被动地追随领导者副本，不能与外界进行交互</p>
<ul>
<li>你可能会有这样的疑惑，竟然追随者副本不能对外提供，只是类似一种备份的作用，那么也就是说只有一个Kafka集群里面，只有一台主Broker进行读写请求的响应，而一台Broker肯定不能积累太多消息，并且所有请求都集中到一台Broker，那肯定会挂，Kafka不能做到横向扩展，这也太cai了吧。别急，分区Partition的出现就是为了解决这种情况<br>9、Partition（分区）：这是个很重要的概念！为了解决伸缩性问题，防止领导者副本积累了太多的数据以至于单台Broker机器无法容纳。我们可以把数据分割成多份保存到不同的Broker上。分区机制指将每个主题划分成多个分区，每个分区是一组<strong>有序的</strong>消息日志，生产者生产的数据只会被发送到一个分区中。上面的图中，有两台Broker，同一个主题中有3个分区，两个Leader副本（绿色的）在Broker0，一个Leader副本在Broker1，这样的读写消息会分布在两台机器上。这里特别指出，同一个分区中的数据时有序的，什么意思呢？比如你发送三条消息——&gt;1,2,3。那么Kafka接受到这三条数据可能存在不同的分区上，这样消费的顺序可能不是1,2,3（不同分区可以并发消费），如果这三条消息都放在了同一个分区比如分区0，那么消费的时候顺序就一定是1,2,3<br>10、 Offset（消息位移）：向分区写入消息时，每条消息在分区中的位置消息由位移（Offset）的数据来表征<br>11、 Consumer Offset（消费者位移）：记录消费者消费消息的进度，每个消费者都有自己的消费位移<br>12、 Consumer Group（消费者组）：多个消费者实例可以组成一个组，共同消费同一个Topic下的多个分区以实现高吞吐，默认情况下一个分区只能被一个消费者消费<br>13、 Rebalance（重平衡）：前面说一个分区只能被一个消费者消费，如果消费者挂了或者新增加了一个分区，那么就要把这个分区分配给其他消费者，这时需要重平衡操作</li>
</ul>
<h1 id="Docker运行Kafka"><a href="#Docker运行Kafka" class="headerlink" title="Docker运行Kafka"></a>Docker运行Kafka</h1><p>我们在Docker中装个Kafka玩一下，首先编写docker-compose.yml文件<br>docker-compose.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  zookeeper:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wurstmeister/zookeeper</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"2181:2181"</span></span><br><span class="line"><span class="attr">  kafka:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">wurstmeister/kafka</span></span><br><span class="line"><span class="attr">    depends_on:</span> <span class="string">[</span> <span class="string">zookeeper</span> <span class="string">]</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9092:9092"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="attr">      KAFKA_ADVERTISED_HOST_NAME:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">      KAFKA_CREATE_TOPICS:</span> <span class="string">"test:1:1"</span></span><br><span class="line"><span class="attr">      KAFKA_ZOOKEEPER_CONNECT:</span> <span class="attr">zookeeper:2181</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br></pre></td></tr></table></figure></p>
<p>上述运行文件，运行一个Zookeeper和一个Kafka实例，如果需要配置一个Kafka集群，需要添加多个kafka实例，指定不同的端口</p>
<p>运行kafka</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose.exe start</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：需要安装docker-compose，并且运行时是在docker-compose.yml文件路径下，这样才能加载配置文件</li>
</ul>
<p><img src="/2019/11/23/初识Kafka/20191123035549442.png" alt=""><br>这样kafka就运行了</p>
<h2 id="运行Kafka生产者和消费者"><a href="#运行Kafka生产者和消费者" class="headerlink" title="运行Kafka生产者和消费者"></a>运行Kafka生产者和消费者</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 进入容器</span><br><span class="line">docker exec -it kafka_kafka_1 bash</span><br><span class="line"><span class="meta">#</span> 切换到kafka bin命令</span><br><span class="line">cd /opt/kafka/bin</span><br><span class="line"><span class="meta">#</span> 生产数据</span><br><span class="line">kafka-console-producer.sh --topic test --broker-list localhost:9092</span><br><span class="line"><span class="meta">#</span> 消费数据</span><br><span class="line">kafka-console-consumer.sh --topic test --bootstrap-list localhost:9092</span><br></pre></td></tr></table></figure>
<p><img src="/2019/11/23/初识Kafka/20191123040402203.png" alt=""><br><img src="/2019/11/23/初识Kafka/20191123040423457.png" alt=""><br>可以看到通过生产者向test的topic生产一条数据，消费者就可在topic中消费一条数据</p>
<h1 id="Kotlin代码实现生产者和消费者"><a href="#Kotlin代码实现生产者和消费者" class="headerlink" title="Kotlin代码实现生产者和消费者"></a>Kotlin代码实现生产者和消费者</h1><p>引入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> kafkaProps = Properties()</span><br><span class="line">    kafkaProps[<span class="string">"bootstrap.servers"</span>] = <span class="string">"localhost:9092"</span></span><br><span class="line">    kafkaProps[<span class="string">"key.serializer"</span>] = <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span></span><br><span class="line">    kafkaProps[<span class="string">"value.serializer"</span>] = <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span></span><br><span class="line">    <span class="keyword">val</span> producer = KafkaProducer&lt;String, String&gt;(kafkaProps)</span><br><span class="line">    <span class="keyword">val</span> record1 = ProducerRecord(<span class="string">"test"</span>,<span class="string">"Products"</span>, <span class="string">"Hello, I am Java producer 1"</span>)</span><br><span class="line">    <span class="keyword">val</span> record2 = ProducerRecord(<span class="string">"test"</span>,<span class="string">"Products"</span>, <span class="string">"Hello, I am Java producer 5"</span>)</span><br><span class="line">    <span class="comment">// 同步发送</span></span><br><span class="line">    println(producer.send(record2).<span class="keyword">get</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步发送，带上callback</span></span><br><span class="line">    producer.send(record2, DemoProducerCallback()).<span class="keyword">get</span>()</span><br><span class="line">    println(<span class="string">"-----Done-----"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoProducerCallback</span>: <span class="type">Callback &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCompletion</span><span class="params">(metadata: <span class="type">RecordMetadata</span>?, exception: <span class="type">Exception</span>?)</span></span> &#123;</span><br><span class="line">        exception?.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java或者Kotlin实现的客户端，在发送消息前都是要对消息实现序列化的，这样能提高传输的效率<br>上面代码的两种发送方式，一种是有带Callback一种是没有带Callback的，在日常工作使用中，建议带上Callback，这样当Kafka发生异常时，方便于我们通过日志追踪</p>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> kafkaProps = Properties()</span><br><span class="line">    kafkaProps[<span class="string">"bootstrap.servers"</span>] = <span class="string">"localhost:9092"</span></span><br><span class="line">    kafkaProps[<span class="string">"group.id"</span>] = <span class="string">"helloKafka"</span></span><br><span class="line">    kafkaProps[<span class="string">"key.deserializer"</span>] = <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span></span><br><span class="line">    kafkaProps[<span class="string">"value.deserializer"</span>] = <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span></span><br><span class="line">    <span class="keyword">val</span> consumer = KafkaConsumer&lt;String, String&gt;(kafkaProps)</span><br><span class="line">    <span class="comment">// 订阅主题</span></span><br><span class="line">    consumer.subscribe(listOf(<span class="string">"test"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use关键字和自动关闭consumer连接</span></span><br><span class="line">    consumer.use &#123;</span><br><span class="line">        <span class="comment">// 轮询</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> records = consumer.poll(Duration.ofMillis(<span class="number">100</span>)); <span class="comment">// 消费者必须持续对kafka进行轮询，否则就会被认为死亡</span></span><br><span class="line">            <span class="keyword">for</span> (record <span class="keyword">in</span> records) &#123;</span><br><span class="line">                println(<span class="string">"topic = <span class="subst">$&#123;record.topic()&#125;</span>, partition = <span class="subst">$&#123;record.partition()&#125;</span>, offset = <span class="subst">$&#123;record.offset()&#125;</span>, key = <span class="subst">$&#123;record.key()&#125;</span>, value = <span class="subst">$&#123;record.value()&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同生产者一样，也是需要序列化消息，这里也可以通过添加一个group.id参数，来指定对应的消费者群组</p>
<h3 id="轮询的重要性"><a href="#轮询的重要性" class="headerlink" title="轮询的重要性"></a>轮询的重要性</h3><p>Consumer消费者通过轮询的方式监听消息，轮询还有其他重要作用，除了监听消息，还有<strong>群组的协调、分区再平衡、发送心跳和获取数据</strong><br>consumer.poll就是发送轮询的重要方法，里面的参数，指定一个超时时间，用于控制poll的阻塞时间，它会在指定的毫秒内一直等待broker返回数据<br>而且poll方法返回的是一批数据，这种批量操作有很高的吞吐率</p>
<h1 id="生产者的分区机制"><a href="#生产者的分区机制" class="headerlink" title="生产者的分区机制"></a>生产者的分区机制</h1><p>这里我们聊聊分区机制<br><img src="/2019/11/23/初识Kafka/20191123042531211.png" alt=""><br>Kafka中消息的组织形式：主题-&gt;分区-&gt;消息，主题下的每条消息都只会被保存在某个分区下，不会在多个分区中保存多份</p>
<h2 id="为什么要分区"><a href="#为什么要分区" class="headerlink" title="为什么要分区"></a>为什么要分区</h2><p>前面已经讲过，主要是为了<strong>提供负载均衡能力</strong>，或者说为了实现系统的可伸缩性（Scalability）<br>除此之外，还有实现业务级别的消息顺序</p>
<h2 id="Kafka的分区策略"><a href="#Kafka的分区策略" class="headerlink" title="Kafka的分区策略"></a>Kafka的分区策略</h2><p>1、 轮询（默认的策略）<br>Round-robin策略，也叫做顺序分配。轮询策略具有非常优秀的负载均衡表现，能保证消息最大限度的被平均分配到所有分区上</p>
<p>2、 随机<br>Randomness策略，随意地将消息放置到一个分区上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 实现伪代码</span><br><span class="line">List&lt;PartitionInfo&gt; partitions = cluter.partitionsForTopic(topic);</span><br><span class="line">return ThreadLocalRandom.current().nextInt(partitions.size());</span><br></pre></td></tr></table></figure></p>
<p>3、 按消息键保序策略<br>Key-ordering策略，指定相同的可以存储相同的分区里面（hash），这个key可以是客户代码，部门编号后者业务ID等，这个功能对我们非常有用，如果我们对消息的顺序保证有严格要求时，可以指定此策略，因为我们前面讲过，同一个分区下的消息是有序的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 实现伪代码</span><br><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">return Math.abs(key.hashCode())%partitions.size());</span><br></pre></td></tr></table></figure></p>
<p>Kafka默认分区策略同时实现了两种策略：如果指定了key，那么可以默认实现消息键保序策略；如果没有指定key，则使用轮询策略</p>
<p>4、自定义策略<br>通过实现org.apache.kafka.clients.producer.Partition接口来自定义分区策略</p>
<h1 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h1><p>聊完生产者，我们来聊聊消费者</p>
<h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h2><p>前面我们说过，同一个消费者组订阅同一个topic，该topic中的每一条消息只会被消费者组中的一个消费者消费，每个消费者消费一个分区<br>如果只有一个消费时，它就会消费topic下的所有分区（这时单个消费者线的消费速度可能跟不上生产速度）<br><img src="/2019/11/23/初识Kafka/20191123044031994.png" alt=""><br>所以最好的方案就是每个分区都有一个消费者线程，提高吞吐量<br><img src="/2019/11/23/初识Kafka/20191123044111034.png" alt=""><br>但是也不能让消费者的线程数大于分区数，这样只会让多出的消费者做无用功<br><img src="/2019/11/23/初识Kafka/20191123044221995.png" alt=""><br>如上图，消费者5没有获得分区的消费，一直做无用功<br>多个消费者组之间互不影响<br><img src="/2019/11/23/初识Kafka/20191123044307339.png" alt=""><br>互不影响的底层实现是通过<strong>消费者位移</strong>实现</p>
<h2 id="再平衡"><a href="#再平衡" class="headerlink" title="再平衡"></a>再平衡</h2><p>1、 当一个消费者崩溃或关闭（不可用）时，此时会发生分区重新分配<br>2、 当一个消费者新加入消费者组时（消费者数小于分区数）时，此时会发生分区重新分配<br>3、 当增加一个新的分区是，此时也是会发生分区重新分配</p>
<p>缺点和危害：<br>1、 当发生分区重新分配时，消费者无法读取消息，造成整个群组不用<br>2、 当分区被重新分配时给另一个消费者时，消费者当前的读取状态可能会丢失<br>对于第二种情况，在代码层面是可以避免的，我们可以实现一个Kafka再分配监听器，当发生再平衡时，触发函数，在consumer中提交目前已经完成消费的消息偏移<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Handle</span> <span class="keyword">implements</span> <span class="title">ConsumerRebalanceListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重新分配分区之前，消费者停止读取消息之后</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsRevoked</span><span class="params">(<span class="keyword">final</span> Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Lost partitions in rebalance.Committing current offsets:"</span>+ConsumerWithListener.<span class="keyword">this</span>.currentOffsets);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPartitionsAssigned</span><span class="params">(<span class="keyword">final</span> Collection&lt;TopicPartition&gt; partitions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过实现ConsumerRebalanceListener接口可完成对再平衡发生的监听</p>
<p>分配分区的过程<br>Broker端会有一个<strong>群组协调器</strong>，当一个新的消费者加入时，会向该协调器发送一个<strong>JoinGroup</strong>请求。第一个加入群组的消费者成为<strong>群主</strong>，群主有三个功能：1、能够从协调器获取当前所有的成员列表（活跃的消费者）；2、根据成员列表，将分区平均分配；3、分配完毕后，将分区情况发回给协调器；<br>每个消费者只能看到自己的分配信息，只有群主知道所有消费者的分配信息。这些过程只有在再平衡时发生</p>
<h1 id="Kafka如何实现消息交付的可靠性"><a href="#Kafka如何实现消息交付的可靠性" class="headerlink" title="Kafka如何实现消息交付的可靠性"></a>Kafka如何实现消息交付的可靠性</h1><p>有这么个问题：如何保证生产者不会重复发送消息，比如因为网络抖动，生产者发送消息失败，等网络好了以后，生产者重复发送了消息，这会出现消费者重复消费的情况 </p>
<p>Kafka提供了三种承诺：</p>
<p>1、 最多一次（at most once)：消息可能会丢失，但绝不会被重复发送<br>2、 至少一次（at least once）：消息不会丢失，但可能会被重复发送（<strong>默认</strong>）<br>3、 精确一次（exactly once）：消息不会丢失，也不会被重复发送</p>
<h2 id="Kafka做到精确一次的技术实现"><a href="#Kafka做到精确一次的技术实现" class="headerlink" title="Kafka做到精确一次的技术实现"></a>Kafka做到精确一次的技术实现</h2><p>Kafka使用分别使用两种技术实现：<strong>幂等性</strong>和<strong>事务</strong></p>
<h3 id="幂等性（Idempotence）"><a href="#幂等性（Idempotence）" class="headerlink" title="幂等性（Idempotence）"></a>幂等性（Idempotence）</h3><p>在配置Kafka的生产者，可以加上该参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(<span class="string">"enable.idempotence"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种幂等性跟Web实现幂等性是差不多的，服务端Broker多存一些字段，当Producer发送了具有相同的字段（比如一个随机的ID）消息后，Broker就可以知道这些消息有没有被重复消费<br>局限性：只能保证某个主题的一个分区上不会出现重复消息，无法实现多个分区的幂等性。而且只能保证同一个会话的幂等性，当服务端重启后，幂等性保证就消失</p>
<p>如果要实现多分区以及多会话的消息无重复保证，就是用事务(Transaction)</p>
<h3 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h3><p>Kafka 0.11版本开始引入了对事务的支持<br><strong>read committed</strong>隔离级别，保证多条消息原子地写入到目标分区，能够保证Consumer只能看到事务成功提交的消息</p>
<p>事务型Producer能够保证将消息原子性地写入到多个分区中，要么全部写入成功，要么全部写入失败。所以就算是网络发生异常，那条旧的消息是不会发送的</p>
<p>开启事务型Producer（需要两步）：<br>1、 开启幂等性Idempotence：enabl.idempotence = true<br>2、 设置Producer端陈述transaction.id</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">producer.initTransactions();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    producer.beginTransaction();</span><br><span class="line">    producer.send(msg1);</span><br><span class="line">    producer.send(msg2);</span><br><span class="line">    producer.commitTransaction();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>但发生写入失败时，Kafka也会把消息写入到底层日志，Consumer也可能会看到并消费这条消息，不过这也是可配置的，通过配置隔离级别isolation.level参数：<br>1、 read_uncommitted：这是默认值，Consumer可以读取到Kafka写入消息，不管消息是否被提交<br>2、 read_committed：表明Consumer只可以读取到事务提交的消息</p>
<p>这里稍微总结一下，Kafka怎么保证生产者不会重复发送相同的消息？<br>1、通过幂等性Producer，但幂等性Producer有局限性，比如智能保证同一个分区下的幂等性<br>2、通过事务型Producer，虽然有很好的可靠性保证，但是性能会很差，吞吐量不高</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kafka/" rel="tag"># Kafka</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/22/浅析ClassLoader/" rel="next" title="浅析ClassLoader">
                <i class="fa fa-chevron-left"></i> 浅析ClassLoader
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/20/WebFlux入门/" rel="prev" title="WebFlux入门">
                WebFlux入门 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">SouthLight Lin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#What’s-Kafka？"><span class="nav-number">1.</span> <span class="nav-text">What’s Kafka？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka能解决什么"><span class="nav-number">2.</span> <span class="nav-text">Kafka能解决什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka传输消息的两种方式"><span class="nav-number">3.</span> <span class="nav-text">Kafka传输消息的两种方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka中的术语"><span class="nav-number">4.</span> <span class="nav-text">Kafka中的术语</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker运行Kafka"><span class="nav-number">5.</span> <span class="nav-text">Docker运行Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#运行Kafka生产者和消费者"><span class="nav-number">5.1.</span> <span class="nav-text">运行Kafka生产者和消费者</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kotlin代码实现生产者和消费者"><span class="nav-number">6.</span> <span class="nav-text">Kotlin代码实现生产者和消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#生产者"><span class="nav-number">6.1.</span> <span class="nav-text">生产者</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消费者"><span class="nav-number">6.2.</span> <span class="nav-text">消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#轮询的重要性"><span class="nav-number">6.2.1.</span> <span class="nav-text">轮询的重要性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#生产者的分区机制"><span class="nav-number">7.</span> <span class="nav-text">生产者的分区机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要分区"><span class="nav-number">7.1.</span> <span class="nav-text">为什么要分区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka的分区策略"><span class="nav-number">7.2.</span> <span class="nav-text">Kafka的分区策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消费者-1"><span class="nav-number">8.</span> <span class="nav-text">消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#消费者组"><span class="nav-number">8.1.</span> <span class="nav-text">消费者组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#再平衡"><span class="nav-number">8.2.</span> <span class="nav-text">再平衡</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka如何实现消息交付的可靠性"><span class="nav-number">9.</span> <span class="nav-text">Kafka如何实现消息交付的可靠性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kafka做到精确一次的技术实现"><span class="nav-number">9.1.</span> <span class="nav-text">Kafka做到精确一次的技术实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#幂等性（Idempotence）"><span class="nav-number">9.1.1.</span> <span class="nav-text">幂等性（Idempotence）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务（Transaction）"><span class="nav-number">9.1.2.</span> <span class="nav-text">事务（Transaction）</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SouthLight Lin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
