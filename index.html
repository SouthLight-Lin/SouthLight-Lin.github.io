<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="SouthLight&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SouthLight&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SouthLight&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>SouthLight's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SouthLight's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/28/Java的线程IO模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/28/Java的线程IO模型/" itemprop="url">Java的线程IO模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-28T21:14:04+08:00">
                2019-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们的IO操作：文件的操作，网络请求的操作都跟IO有关，我们需要了解下目前的IO模型有哪些。在这之前我们需要了解<strong>缓存IO</strong> </p>
<h1 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h1><p>缓存IO又叫做标准IO，所有的IO写入都会先写向操作系统内核的缓存，再由操作系统刷新到硬盘。返回来也是一样，读取文件也是先读取到操作系统的缓存，然后再给程序。<br>缓存I/O的缺点是数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p>
<h1 id="同步、异步、阻塞、非阻塞的概念"><a href="#同步、异步、阻塞、非阻塞的概念" class="headerlink" title="同步、异步、阻塞、非阻塞的概念"></a>同步、异步、阻塞、非阻塞的概念</h1><p>同步和异步最大的区别就是被调用方的执行方式和返回时机。 同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。<br>阻塞和非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。 阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。<br><strong>阻塞、非阻塞说的是调用者。同步、异步说的是被调用者。</strong></p>
<h1 id="常见的IO模型"><a href="#常见的IO模型" class="headerlink" title="常见的IO模型"></a>常见的IO模型</h1><p>一个Socket请求服务器，会经过哪些步骤？<br>1、一个Socket会被分成多个包，经过多个路由到达服务器，进入操作系统的缓存区，也就是说要等待所有的Socket包都到达服务器<br>2、操作系统将数据拷贝给应用程序缓存<br>文件的IO也跟网络的IO类似，第一步需要等待操作系统从硬盘中读取数据到缓冲区</p>
<h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><p>同步阻塞说明上面两步操作都会被阻塞，既要等待数据的准备，又要等待数据的拷贝<br><img src="/2019/03/28/Java的线程IO模型/20190328094528216.png" alt=""></p>
<h2 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h2><p>同步阻塞相当在第一步的时候你可以去做别的事情，只是做的过程回来询问数据是否准备好了。当应用程序调用recvform后并不会阻塞，也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好， 此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。<br><img src="/2019/03/28/Java的线程IO模型/20190328100712368.png" alt=""></p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>这个是重点中的重点，现在的IO模型大多都是这个，Nginx，Redis，Java的NIO都是这个实现的<br>IO多路复用是指操作系统会有一个线程监听所有的IO请求，如果有一个请求的数据已经准备好了，那么就将该请求发送给预定的程序<br>目前的Unix系统的IO多路复用的函数有select、poll、epoll，select是最早出现的多路复用api，但是有一些缺点，比如最大只能有1024个线程，线程不安全；接着poll就修复了select的一些问题，解决了1024的问题，但还是线程不安全；最后epoll出现了，他解决了select的所有问题，现在的Linux都是使用它完成多路复用模型，但epoll只能在Linux上实现。还有一种叫kqueue的IO多路复用函数，但它是macos系统的东西。<br>想比较于同步非阻塞IO，它的改进之处在于原来用户进程轮询这事<strong>交给操作系统内核线程实现</strong> ，如果数据准备好，操作系统就会通知用户进程，将数据拷贝，而且这个内核进程可以等待多个Socket，能实现对多个IO端口进行监听<br><img src="/2019/03/28/Java的线程IO模型/20190329041513978.png" alt=""><br>如果连接数不高的话，使用IO多路复用并不一定比使用多线程+阻塞IO的Web Server性能好，因为<strong>IO多路复用的优势并不是对于单个连接处理得快，而是在于能处理更多的连接</strong> 。<br><strong>IO多路复用归为同步阻塞</strong> ，为什么？因为调用select、poll、epoll这些复用函数其实也是阻塞的，但是这种阻塞丢给操作系统后台去执行，用户进程不需要阻塞而已。</p>
<h2 id="异步非阻塞IO"><a href="#异步非阻塞IO" class="headerlink" title="异步非阻塞IO"></a>异步非阻塞IO</h2><p>用户进程如果想进行异步非阻塞IO，调用aio_read系统后，等到Socket数据准备好，内核直接复制数据给进程（不是进程去内核拷贝数据了），然后内核向进程发送通知，IO这两个阶段都是非阻塞的</p>
<p>Linux下的AIO库函数实现异步，但用得很少，目前很多开源异步IO库有：libevent、libev、libuv。<br><img src="/2019/03/28/Java的线程IO模型/20190329042912467.png" alt=""></p>
<h1 id="Java中的四种IO模型"><a href="#Java中的四种IO模型" class="headerlink" title="Java中的四种IO模型"></a>Java中的四种IO模型</h1><ul>
<li>1、Java传统IO模型，即阻塞IO</li>
<li>2、NIO是同步非阻塞</li>
<li>3、同步NIO实现的Reactor模式，即IO多路复用模型的实现</li>
<li>4、同步AIO实现的Proactor模式，即是异步IO模型的实现</li>
<li>本篇博客是读完该公众号后写的<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247488064&amp;idx=2&amp;sn=56b6f87cb4e99107737c73f7ed1e5e8e&amp;chksm=eb539776dc241e60f88f7185da4b7fb46bf41f10a66a53898ca672e8942e8b6a8d47ec7d3d3d&amp;mpshare=1&amp;scene=1&amp;srcid=03282f5UGrOPqla3FRHsnIBf&amp;key=07b41b11cd2ea3cf8754e412ce5b2e1dda0131c9a5fa746e0eb74dbecee757f47a4be1b7ab19876a05437cfac54fc5fa19f2c7f64870a4920d18b6ca45c1ac83a0841ecd111138fb03b3d3e54daf5119&amp;ascene=1&amp;uin=MTEyMjk5MTQyMw%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=L34Qc03cLwYw%2FDmghOHdw%2Fwmxf4sCxrhU%2FUHEHTt68cCHJY3jbH53l0ddsu2QPAy" target="_blank" rel="noopener">Java技术栈</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/23/Spring的事务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/Spring的事务/" itemprop="url">Spring的事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-23T19:43:13+08:00">
                2019-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用Spring事务的两种方式"><a href="#使用Spring事务的两种方式" class="headerlink" title="使用Spring事务的两种方式"></a>使用Spring事务的两种方式</h1><p>spring使用事务有两种方式：编程式事务（自己写代码）和声明式事务（注解）<br>注意： 关于编程式事务，一般用得很少，因为事务的代码会散落在我们的逻辑代码中，如果你真的想要使用编程式事务，就得使用<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#tx-prog-template" target="_blank" rel="noopener">TransactionTemplate</a></p>
<h2 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h2><p><img src="/2019/03/23/Spring的事务/20190324113149114.png" alt=""></p>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><p>Spring中的声明式事务其实是通过AOP实现的，通过Spring官网的一张图可以看到AOP代理的过程<br><img src="/2019/03/23/Spring的事务/20190324101047878.png" alt=""></p>
<h3 id="声明式事务的代码"><a href="#声明式事务的代码" class="headerlink" title="声明式事务的代码"></a>声明式事务的代码</h3><p><img src="/2019/03/23/Spring的事务/20190324011843914.png" alt=""></p>
<h2 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h2><p>接口，主要实现事务的提交回滚<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line"></span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PlatformTransactionManager需要引入数据源DataSource（一般SpringBoot会自动帮你解决），我们用的最多的TransactionManager是DataSourceTransactionManager，它是JDBC包下（还有其他的，比如Hibernate或者JTA的）</p>
<h2 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h2><p>接口，标明事务的状态，比如是否为可读，控制事务的执行</p>
<h2 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h2><p>接口，标明事务的定义，比如事务的传播性、隔离性、timeout、可读性..</p>
<h2 id="TransactionAttribute"><a href="#TransactionAttribute" class="headerlink" title="TransactionAttribute"></a>TransactionAttribute</h2><p>接口，获取@Transactional注解的value值、rollbackOn，然后添加进TransactionDefintion</p>
<h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><p>注解，可以在类、接口、方法上注解，表示该类或方法需要事务代理<br>该注解的属性详解：<br><img src="/2019/03/23/Spring的事务/20190324105826403.png" alt=""></p>
<h1 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h1><ul>
<li>1、传播性</li>
<li>2、隔离性</li>
<li>3、超时性</li>
<li>4、只读性</li>
</ul>
<h2 id="事务的传播性"><a href="#事务的传播性" class="headerlink" title="事务的传播性"></a>事务的传播性</h2><p>总共七种，但Spring官方文档只给出了三种，就是下面的三种：PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW、PROPAGATION_NESTED<br>PROPAGATION_REQUIRED<br><img src="/2019/03/23/Spring的事务/20190324103943218.png" alt=""><br>PROPAGATION_REQUIRES_NEW<br><img src="/2019/03/23/Spring的事务/20190324103953698.png" alt=""><br>PROPAGATION_NESTED<br>虽然跟REQUIRES_NEW差不多，也是再起一个事务，但是两个事务之间是有关联的，外部事务发生回滚时，内部事务也要回滚，但是内部事务发生回滚时，外部事务不用回滚（简单理解就是：外部最大）</p>
<p>七种：<br><img src="/2019/03/23/Spring的事务/20190324110720493.png" alt=""></p>
<h2 id="事务的隔离性："><a href="#事务的隔离性：" class="headerlink" title="事务的隔离性："></a>事务的隔离性：</h2><p><img src="/2019/03/23/Spring的事务/20190324110934634.png" alt=""></p>
<h1 id="关于REQUIRES-NEW与NESTED事务传播特性的说明"><a href="#关于REQUIRES-NEW与NESTED事务传播特性的说明" class="headerlink" title="关于REQUIRES_NEW与NESTED事务传播特性的说明"></a>关于REQUIRES_NEW与NESTED事务传播特性的说明</h1><p><img src="/2019/03/23/Spring的事务/20190324041955623.png" alt=""></p>
<p>比如有一段代码<br><img src="/2019/03/23/Spring的事务/20190324042441436.png" alt=""><br>一个事务方法里面调用另一个事务的方法，如果内部事务为NESTED，外部事务发生异常回滚时，内部事务也要回滚，但是内部事务发生回滚时，外部事务不需要回滚<br>如果内部事务为REQUIRES_NEW，不管事务的回滚只看当前方法是否发生异常</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/17/Redis线程模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/17/Redis线程模型/" itemprop="url">Redis线程模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-17T20:10:54+08:00">
                2019-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h1><ul>
<li>1、纯内存操作：我们的数据都是存储在内存中的，所以跟存储在硬盘相比，写入读取速度快很多倍</li>
<li>2、丰富的数据结构：redis基础的五种数据结构（string、hash、list、set、zset）是我们日常使用存储数据的结构（当然还有其他的结构，比如geo、hyperloglog），这些结构的性能非常优越，比如基础数据结构（除了set），刚开始是用压缩列表的结构存储数据，不仅读取速度快，而且占用内存也少。    （关于压缩列表可以查看，<a href="https://southlight-lin.github.io/2019/03/09/通过优化降低Redis的内存占用/" target="_blank" rel="noopener">通过优化降低Redis的内存占用</a> 这篇博客)</li>
<li>3、I/O多路复用模型——本篇博客就是为了讲解这个模型</li>
<li>4、单线程操作：减少多核CPU上下文切换引起的开销</li>
</ul>
<h1 id="Redis的IO多路复用模型"><a href="#Redis的IO多路复用模型" class="headerlink" title="Redis的IO多路复用模型"></a>Redis的IO多路复用模型</h1><p>借助网上的例子说明情况：比如有很多个水龙头（就是我们客户端的请求），但这些水龙头都不知道什么时候来水。当水来的时候，要把这些水接住，所以需要人（redis的线程）负责，但是我们需要多少个人？难道要每个水龙头都站一个人？这样的话当请求很多时，创建很多线程，肯定内存不够用。所以Redis采用一个线程（相当于一个人）来循环试探这些水龙头，当拧开水龙头发现有水时就处理。</p>
<p>I/O多路复用模块是操作系统底层的东西，进程只要告诉操作系统需要监听哪个端口的Socket，当这些端口有套接字的可读或可写（Socket）事件时，操作系统就会通知进程（Redis）。而I/O监听这些端口，就是使用<strong>select</strong> ，<strong>poll</strong> ，<strong>epoll</strong> ，<strong>kqueue</strong> 这些I/O多路复用函数。这些函数可以同时监控多个流的I/O事件能力，如果没有Socket连接（没有请求过来时）的时候，当前主线程会阻塞；当有一个或者多个流过来时，操作系统就会通知程序（Redis），Redis就会轮询一遍所有的流，对这些流进行处理，这过程是有顺序的，先来先服务FIFS。所以“多路”指的是有多个请求连接，“复用”指的是复用一个线程，这个线程负责把请求监听请求，当有请求到来时，就传递给程序处理。<strong>这样的模型，提高了单个线程的处理能力，一个线程就可以高效的处理多个连接请求，尽量减少网络IO的开销</strong> 。<br>跟传统的阻塞IO相比，在计算机网络中，我们的请求可能被分成许多包，经过不同的路由器传递，如果有些包到达了服务器，有些还没到，那么服务器就要等到这些包全都收集齐了才能处理。如果请求很多，那么等待的时间就会很长，这就是网络开销之一。如果使用IO多路复用模型，把监听这些包有没有准备好的事情交给操作系统，我们只需调用轮询api（select、poll、epoll..）不断的询问操作系统就行了。当没有请求或者请求还没准备好时，Redis就可以做其他事情。<br>来看张图<br><img src="/2019/03/17/Redis线程模型/20190317092104769.png" alt=""><br>在Linux中，Socket也是文件！<br>类似上面的例子，当有很多请求到来时（一个Socket就相当于一个请求），操作系统就会跟踪这些请求 ，而且是有顺序的存入，先来先服务FIFO的原则。接下来，<strong>文件事件分配器</strong> 循环扫描指令队列，将不同类型请求的Socket交给不同的处理器（比如有些请求时get、有些是set）。循环扫描的过程就叫<strong>事件轮询</strong> ，这种事件轮询是操作实现的，常见的事件轮询api有：<strong>select</strong> ，<strong>poll</strong> ，<strong>epoll</strong> ，<strong>kqueue</strong> 。<br>select是最早出现的多路复用api，但是有一些缺点，比如最大只能有1024个线程，线程不安全；接着poll就修复了select的一些问题，解决了1024的问题，但还是线程不安全；最后epoll出现了，他解决了select的所有问题，现在的Linux都是使用它完成多路复用模型，但epoll只能在Linux上实现。kqueue是macos系统的东西。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/通过优化降低Redis的内存占用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/通过优化降低Redis的内存占用/" itemprop="url">通过优化降低Redis的内存占用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T20:40:33+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道Redis是直接将数据存储在内存里面着，但是一般我们的内存的容量是有限的，小则一两个G，最多也就十多个G，而且内存都很贵，在数据量大的话导致Redis服务器的内存严重不足，是非常头疼的事，要么加内存解决，要么使用集群解决，两者都会引起资金上的开销。我们可以使用另一种方法来降低Redis存储数据的空间，以此来降低内存的开销，解决内存不足的问题。本篇博客主要讲解 <strong>短结构</strong>  和 <strong>分片技术（sharding)</strong> 。</p>
<h1 id="短结构"><a href="#短结构" class="headerlink" title="短结构"></a>短结构</h1><p>Redis默认为列表、集合、散列和有序集合提供了一种配置，当这四种结构存储的数据不是很大时，Redis使用更加节约空间的方式存储数据，这种结构称为 <strong>短结构</strong> 。<br>在列表、散列和有序集合的长度较短的时候，Redis会选择一种名为 <strong>压缩列表（ziplist）</strong> 来存储（集合是另一种形式，等下再说）。通常情况下Redis使用双链表表示列表、使用散列表（类似于HashMap）表示散列、使用散列表加跳跃表（skiplist）表示有序集合的做法不同，压缩列表会以序列化的方式存储数据，这些序列化数据每次被读取的时候都需要进行解码，写入的时候也要局部重新编码，并且可能会对内存中的数据进行移动。<br>当存储的列表过长时，就会使用双向链表，比如列表中有”one”,”two”,”ten”这三个值，存储形式如下图<br><img src="/2019/03/09/通过优化降低Redis的内存占用/20190309092425331.png" alt=""><br>前面的4表示存储的字符创的长度，0表示存储字符串值中剩余可用的字节数量，最后一部分就是字符串本身，除此之外剩余的就是指针的存在，因此，指针带来了额外的开销。在32位平台上，每存储这样3字节长的字符串，需要付出21字节的额外开销。<br>而压缩列表由节点组成的序列（sequence），每个节点都由两个长度值和一个字符串组成。长度值记录前一个节点的长度（这样当下一个节点需要读取上一个节点的值时，因为空间是连续的，直接通过长度就可读取上一个节点的值），第二个长度值记录当前节点的长度，最后存储字符串。<br>在redis.conf配置文件中，就有规定在数据大小多大的范围内使用短结构（压缩列表不是越长越好）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Hashes are encoded using a memory efficient data structure when they have a</span><br><span class="line"># small number of entries, and the biggest entry does not exceed a given</span><br><span class="line"># threshold. These thresholds can be configured using the following directives.</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># Similarly to hashes and lists, sorted sets are also specially encoded in</span><br><span class="line"># order to save a lot of space. This encoding is only used when the length and</span><br><span class="line"># elements of a sorted set are below the following limits:</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br></pre></td></tr></table></figure></p>
<p>上面规定了hash或者zset的大小超过64字节或者元素超过规定的大小时，就会从压缩列表转变为原来的数据结构（这里没有给出list列表的规定原因是：新的Redis中已经更改了list压缩列表的条件，但是我还不是很懂规定的形式，所以没贴出来），而且要注意， <strong>如果从压缩列表转变为普通的数据结构比如转变为双向列表，即使后面把双向列表的大小减小到小于64字节，也不能够重新转变为压缩列表，也就是说转变是不可逆的</strong> </p>
<h2 id="集合的整数编码"><a href="#集合的整数编码" class="headerlink" title="集合的整数编码"></a>集合的整数编码</h2><p>上面之所以没有提到集合，是因为集合跟上面三种数据结构不同，但是体积较小的集合也还是有自己紧凑形式表现，Redis就会以有序集合整数的形式存储集合，称为 <strong>整数集合（intset）</strong><br>redis.conf中作了这样的限制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Sets have a special encoding in just one case: when a set is composed</span><br><span class="line"># of just strings that happen to be integers in radix 10 in the range</span><br><span class="line"># of 64 bit signed integers.</span><br><span class="line"># The following configuration setting sets the limit in the size of the</span><br><span class="line"># set in order to use this special memory saving encoding.</span><br><span class="line">set-max-intset-entries 512</span><br></pre></td></tr></table></figure></p>
<h2 id="并不是说压缩列表或者整数集合越大越好"><a href="#并不是说压缩列表或者整数集合越大越好" class="headerlink" title="并不是说压缩列表或者整数集合越大越好"></a>并不是说压缩列表或者整数集合越大越好</h2><p>当一个结构突破了用户为压缩列表或者整数集合设置的限制条件时，Redis就会自动将它转换为更为经典的底层数据结构，这样做的主要原因在于，随着紧凑结构的体积越来越大，操作这些结构的速度就会越来越慢。<br>主要将压缩列表的长度限制在500~2000个元素内，并将每个元素的体积限制在128字节或以下，那么压缩列表的性能就会处于合理范围之内。</p>
<p>压缩列表一般要配合分片结构才能发挥降低内存的作用</p>
<h1 id="分片结构"><a href="#分片结构" class="headerlink" title="分片结构"></a>分片结构</h1><p>分片是基于某种简单的规则将数据划分为更小的部分，然后根据数据所属的部分来决定将数据存储到哪个位置上，很多集群时的数据可以通过分片结构将数据平分到不同的Redis服务器上<br>比如当我们有一个很大的Hash结构时，里面的数据只是一个简单的key-value，你可以想象成  学号-姓名的对应，这个Hash里面存储了上万条数据（学号是唯一的），这样的话Redis底层的就不是用压缩列表存储了，因为数据大小已经远远超过了entry或者size了。<br>这个分片结构就派上用场了，我们可以把里面的key-value平分到多个Hash结构上，使每个Hash的大小都不超过entry和size的规定，这样每个Hash就还是压缩列表的结构。<br>这种实现方式也很简单， 只要设置预计元素的总数量以及请求的分片数量，然后对键通过算法进行计算，得出这个键应该存储在哪个位置即可。</p>
<p>java———使用Jedis<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public String shardKey(String base, String key, long totalElements, int shardSize) &#123;</span><br><span class="line">        long shardId = 0;</span><br><span class="line">        // 判断是否为整数</span><br><span class="line">        if (isDigit(key)) &#123;</span><br><span class="line">            shardId = Integer.parseInt(key, 10) / shardSize;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 如果不为整数，通过CRC32算法计算出该键的模来得出位置</span><br><span class="line">            CRC32 crc = new CRC32();</span><br><span class="line">            crc.update(key.getBytes());</span><br><span class="line">            long shards = 2 * totalElements / shardSize;</span><br><span class="line">            shardId = Math.abs(((int)crc.getValue()) % shards);</span><br><span class="line">        &#125;</span><br><span class="line">        return base + &apos;:&apos; + shardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long shardHset(</span><br><span class="line">        Jedis conn, String base, String key, String value, long totalElements, int shardSize)</span><br><span class="line">    &#123;</span><br><span class="line">        String shard = shardKey(base, key, totalElements, shardSize);</span><br><span class="line">        return conn.hset(shard, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String shardHget(</span><br><span class="line">        Jedis conn, String base, String key, int totalElements, int shardSize)</span><br><span class="line">    &#123;</span><br><span class="line">        String shard = shardKey(base, key, totalElements, shardSize);</span><br><span class="line">        return conn.hget(shard, key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>java——使用RedisTemplate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String shardKey(String base, String key, long totalElements, int shardSize) &#123;</span><br><span class="line">       long shardId = 0;</span><br><span class="line"></span><br><span class="line">       CRC32 crc = new CRC32();</span><br><span class="line">       crc.update(key.getBytes());</span><br><span class="line">       long shards = 2 * totalElements / shardSize;</span><br><span class="line">       shardId = Math.abs(((int)crc.getValue()) % shards);</span><br><span class="line"></span><br><span class="line">       return base + &apos;:&apos; + shardId;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void shardHset(</span><br><span class="line">           String base, String key, String value, long totalElements, int shardSize)</span><br><span class="line">   &#123;</span><br><span class="line">       String shard = shardKey(base, key, totalElements, shardSize);</span><br><span class="line">       redisTemplate.opsForHash().put(shard, key, value);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public String shardHget(</span><br><span class="line">           String base, String key, int totalElements, int shardSize)</span><br><span class="line">   &#123;</span><br><span class="line">       String shard = shardKey(base, key, totalElements, shardSize);</span><br><span class="line">       return (String) redisTemplate.opsForHash().get(shard, key);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>实现的方式其实挺简单的，就是通过求键的模，通过不同的模把数据存储到不同的Hash中。<br>集群也是同样的道理，将不同的模的数据存储到不同的服务器，比如模0~4存储到1服务器，其他存储到2服务器</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/Spring循环依赖的解决方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/Spring循环依赖的解决方法/" itemprop="url">Spring循环依赖的解决方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T20:42:53+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Spring的循环依赖是什么？就是两个Bean之间互相依赖，比如A的Bean中依赖B，B的Bean依赖A<br>TeatA.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.dao;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class TestA &#123;</span><br><span class="line">	public TestB testB;</span><br><span class="line">	@Autowired</span><br><span class="line">	public void setTestB(TestB testB) &#123;</span><br><span class="line">		this.testB = testB;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TestB.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.dao;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class TestB &#123;</span><br><span class="line">	public TestA testA;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	public void setTestA(TestA testA)&#123;</span><br><span class="line">		this.testA = testA;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时如果运行Spring，是不会报错的，证明Spring可以自己解决循环依赖，那Spring是怎么解决的呢</p>
<h1 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h1><p>这里需要大家了解下Spring的Bean的声明周期，不清楚的可以看这篇<a href="https://southlight-lin.github.io/2019/02/19/Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" target="_blank" rel="noopener">Spring-Bean的生命周期</a>博客<br>长话短说，先说下Spring的解决办法，如果Spring发现一个Bean（当前Bean为A）存在循环依赖时，此时就会为当前Bean封装一个ObjectFactory，放进一个类似IOC容器的HashMap中 <strong> singletonFactories </strong> ，放进之后，继续创建Bean  A，当到了Bean的生命周期的populateBean的属性解析的时候，发现依赖Bean B，就去创建Bean B；在创建Bean  B的时候发现B存在循环依赖，就把当前B封装成一个ObjectFactory放进 <strong> singletonFactories </strong> （注意，此时Map中已经有两个ObjectFactory）</p>
<h2 id="Spring获取单例Bean的流程"><a href="#Spring获取单例Bean的流程" class="headerlink" title="Spring获取单例Bean的流程"></a>Spring获取单例Bean的流程</h2><p>这里有必要讲一下Spring获取单例Bean的流程，在getSingleton方法中<br>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton(java.lang.String, boolean)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">		// 先尝试从IOC容器中获取Bean</span><br><span class="line">		Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">		// 如果获取不到Bean，并且解析出当前Bean存在循环依赖</span><br><span class="line">		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			synchronized (this.singletonObjects) &#123;</span><br><span class="line">				// 尝试从earlySingletonObjects中获取Bean</span><br><span class="line">				// earlySingletonObjects跟singletonFactories是相辅相成的</span><br><span class="line">				// singletonFactories中存放ObjectFactory，ObjectFactory可以返回一个实例</span><br><span class="line">				// earlySingletonObjects可以存放ObjectFactory返回的实例</span><br><span class="line">				singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">				// 如果不在earlySingletonObjects中</span><br><span class="line">				if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">					// 判断是否有ObjectFactory，如果有，就通过ObjectFactory创建</span><br><span class="line">					if (singletonFactory != null) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						// 将实例存放进earlySingletonObjects</span><br><span class="line">						this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						// 将ObjectFactory移除</span><br><span class="line">						this.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释已经写明白了，先从IOC容器中获取，如果没有就判断是否有循环依赖，有循环依赖则从singletonFactories和earlySingletonObjects获取</p>
<h2 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h2><p>我们继续讲解上面的流程，我们讲到在创建B的Bean时发现循环依赖，就把B封装成ObjectFactory并放进singletonFactories，然后在Bean生命周期的populateBean的方法解析属性时发现存在依赖A的Bean，此时又要走创建Bean A的流程，但是走到org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton这个方法时（也就是上面Spring的源代码），会从singletonFactories获取A的ObjectFactory，由ObjectFactory创建对象，并且赋值给B的Bean，此时B的Bean是指向A的实例（尽管A的Bean还没有创建，但是实例，也就是对象已经存在），这样一来B的Bean就会创建完成，需要添加进IOC容器<br>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingleton<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void addSingleton(String beanName, Object singletonObject) &#123;</span><br><span class="line">		synchronized (this.singletonObjects) &#123;</span><br><span class="line">			this.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">			this.singletonFactories.remove(beanName);</span><br><span class="line">			this.earlySingletonObjects.remove(beanName);</span><br><span class="line">			this.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加进IOC容器前需要擦除earlySingletonObjects和singletonFactories有关B的所有信息<br>这样的话，B的Bean已经创建完成了，回退到解析A的属性时，此时A需依赖Bean  B，因为Bean B已经创建，所以直接将Bean B赋给A的属性，就这样循环依赖解决了。</p>
<h2 id="再重复一次"><a href="#再重复一次" class="headerlink" title="再重复一次"></a>再重复一次</h2><p>当Spring创建TestA时，在doCreate方法中，有这么一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">		 * 这个判断很重要，Spring依靠这个判断解决循环依赖，检测循环依赖</span><br><span class="line">		 * 是这样的，当发现有依赖循环时，比如A依赖B，B依赖A，此时获取A的Bean</span><br><span class="line">		 * Spring发现依赖循环，并且B的Bean还没有被创建，先创建A的ObjectFactory，然后添加进singletonFactories</span><br><span class="line">		 * 在下面的populateBean方法，将属性的依赖B创建</span><br><span class="line">		 */</span><br><span class="line">		// Eagerly cache singletons to be able to resolve circular references</span><br><span class="line">		// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br><span class="line">        		// 这里有三个条件需要判断：1、是否为代理；2、是否允许允许循环依赖；3、是否对应的Bean正在创建</span><br><span class="line">		boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;</span><br><span class="line">				isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">		if (earlySingletonExposure) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(&quot;Eagerly caching bean &apos;&quot; + beanName +</span><br><span class="line">						&quot;&apos; to allow for resolving potential circular references&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			// 为避免后期循环依赖，可以在Bean初始化完成前将创建实例的ObjectFactory加入工厂</span><br><span class="line">			// 在Lambda表达式中，我们熟知的AOP的advice就是在这里动态织入的</span><br><span class="line">            // addSingletonFactory方法就是将ObjectFactory放进singletonFactories中</span><br><span class="line">			addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean) );</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>在创建Bean的时候会判断这个Bean是否存在循环依赖，此时TestA会判断出存在循环依赖。就会执行<strong> addSingletonFactory </strong><br>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;</span><br><span class="line">		Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);</span><br><span class="line">		synchronized (this.singletonObjects) &#123;</span><br><span class="line">			if (!this.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">				this.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">				this.earlySingletonObjects.remove(beanName);</span><br><span class="line">				this.registeredSingletons.add(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是为A封装一个ObjectFactory并添加进singletonFactories，为了给下面循环依赖的B使用<br>接下来解析A的属性时发现依赖B的Bean，因为B的Bean还没被创建，所以需要创建B，所以又走了一遍上面的流程。当解析B的属性时发现依赖A的Bean，因为A的Bean还没有，所以先获取A的Bean，所以会执行这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">		// 先尝试从IOC容器中获取Bean</span><br><span class="line">		Object singletonObject = this.singletonObjects.get(beanName);</span><br><span class="line">		// 如果获取不到Bean，并且解析出当前Bean存在循环依赖</span><br><span class="line">		if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			synchronized (this.singletonObjects) &#123;</span><br><span class="line">				// 尝试从earlySingletonObjects中获取Bean</span><br><span class="line">				// earlySingletonObjects跟singletonFactories是相辅相成的</span><br><span class="line">				// singletonFactories中存放ObjectFactory，ObjectFactory可以返回一个实例</span><br><span class="line">				// earlySingletonObjects可以存放ObjectFactory返回的实例</span><br><span class="line">				singletonObject = this.earlySingletonObjects.get(beanName);</span><br><span class="line">				// 如果不在earlySingletonObjects中</span><br><span class="line">				if (singletonObject == null &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">					ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);</span><br><span class="line">					// 判断是否有ObjectFactory，如果有，就通过ObjectFactory创建</span><br><span class="line">					if (singletonFactory != null) &#123;</span><br><span class="line">						singletonObject = singletonFactory.getObject();</span><br><span class="line">						// 将实例存放进earlySingletonObjects</span><br><span class="line">						this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">						// 将ObjectFactory移除</span><br><span class="line">						this.singletonFactories.remove(beanName);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return singletonObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为singletoeFactories中有两个ObjectFactory分别是A和B的，所以使用A的ObjectFactory提供的实例为B中的A赋值，当B创建完后又将B的Bean赋值给A中的B，这样A的Bean也就创建完成了。</p>
<p>*注意：循环依赖只运行单例，原型直接抛出异常</p>
<h1 id="画图理解"><a href="#画图理解" class="headerlink" title="画图理解"></a>画图理解</h1><p><img src="/2019/03/08/Spring循环依赖的解决方法/20190308102208466.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/为什么SpringBoot可以不用配置文件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/为什么SpringBoot可以不用配置文件/" itemprop="url">为什么SpringBoot可以不用配置文件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-03T23:13:19+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们使用SpringBoot的时候，只需要引入跟SpringBoot的start包，比如mybatis-spring-boot-starter就可实现与Mybatis的结合，DataSource的配置就可以在application.properties或者application.yml中配置。那到底为什么只要引入了跟SpringBoot的starter包依赖就可以实现自动装配呢？今天就来简单的聊聊其中的原理。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>一个SpringBoot项目，一般都会有一个启动类，只要运行启动类中的main方法，就可以启动SpringBoot项目。比如下面这段代码，标准的SpringBoot启动类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">//@Configuration</span><br><span class="line">//@EnableAutoConfiguration</span><br><span class="line">//@ComponentScan(&#123;&quot;com.lnw&quot;,&quot;com.lnw&quot;&#125;)</span><br><span class="line">public class SpringbootSwaggerApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootSwaggerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的说run方法就是启动一个Spring容器，然后刷新容器，这里就不再深入，我们只要知道， <strong> 如果一个@Configuration的配置类如果会被Spring扫描到，那么这个配置类里面的配置就会被Spring所加载 </strong> 。这里最重要的就是@SpringBootApplication注解，它是SpringBoot自动装配的密码所在。<br>我们来看下这个注解</p>
<h1 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters = &#123;</span><br><span class="line">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">	@AliasFor(annotation = EnableAutoConfiguration.class)</span><br><span class="line">	Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line">	@AliasFor(annotation = EnableAutoConfiguration.class)</span><br><span class="line">	String[] excludeName() default &#123;&#125;;</span><br><span class="line">	@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)</span><br><span class="line">	String[] scanBasePackages() default &#123;&#125;;</span><br><span class="line">	@AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)</span><br><span class="line">	Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到注解里面还有注解，分别是@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan。其中@SpringBootCofuration这个注解是没什么作用的，@ComponentScan注解主要是做扫描当前包下的加了注解的类，<strong> @EnableAutoConfiguration </strong> 才是关键，也就是说只要加了这个@EnableAutoConfiguration注解就可以打开SpringBoot的自动配置的功能。我们看它的源码</p>
<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.autoconfigure;</span><br><span class="line"></span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] excludeName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里引用了一个@Import注解，里面注入了一个AutoConfigurationImportSelector类。</p>
<h3 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h3><p>SpringBoot运行后，就会创建Spring的容器，容器的创建需要一些配置类做初始化，比如@Configuration或者@Import注解的类，所以Spring容器创建之初会执行AutoConfigurationImportSelector里面的代码，最重要的方法就是org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getCandidateConfigurations<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,</span><br><span class="line">			AnnotationAttributes attributes) &#123;</span><br><span class="line">		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">				getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">		Assert.notEmpty(configurations,</span><br><span class="line">				&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span><br><span class="line">						+ &quot;are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">		return configurations;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>SpringFactoriesLoader.loadFactoryNames就是扫描当前项目以及项目依赖的所有Configuration<br>SpringFactoriesLoader.loadFactoryNames方法是这样的，它会扫描所有的jar包，如果这个jar中有META-INF/spring.factories文件，就把spring.factories文件的内容（描述配置类的全路路径）扫描到List集合中，稍后给Spring-context包处理<br>在spring-boot-autoconfigure包中的META-INF/spring.factories文件中，定义了差不多100多个配置<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304095132878.png" alt=""><br>这些配置只要添加了跟SpringBoot的starter依赖，就会被加载<br>比如添加了Redis的starter包，spring.factories文件中已经定义了<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304095527979.png" alt=""><br>所以这个类会被Spring扫描到，这个类就是一个@Configuration类<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304095604776.png" alt=""></p>
<p>如果SpringBoot的spring.factories没有它规定的starter，比如Mybatis，那怎么办？那就自己开发一个autoconfigure，只要在你自己的META/INF里面声明一个spring.factories文件，把配置类写上，就可以了。比如mybatis就开发了一个跟SpringBoot整合的autoconfigure（它是自己开发的，不是Spring开发的）<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304095954308.png" alt=""><br>里面的内容是<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304100043957.png" alt=""><br>而这个MybatisAutoConfiguration类，就是一般的配置类，就跟我们平时的@Configuration配置类一样<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304100643222.png" alt=""><br>这个配置类说明了@Configuration生效的条件，比如要有SqlSessionFactory类，要有DataSource这个Bean，要在DataSourceAutoConfiguration这个配置文件执行后<br><strong> @EnableConfigurationProperties </strong> 这个注解可以从application.properties或者application.yml中读取需要的配置<br>比如里面的MybatisProperties<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304101417055.png" alt=""><br>这个类会读取mybatis前缀的属性，比如<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304101521691.png" alt=""></p>
<h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><p>我们可以自己写一个autoconfiguration，实现自动装配，项目的结构如下图，项目可以是普通项目也可以是springboot项目<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304101912272.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line"></span><br><span class="line">@EnableConfigurationProperties(LNWProperties.class)</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(LNWService.class)  //前提：LNWService类存在</span><br><span class="line">@ConditionalOnProperty(prefix = &quot;lnw&quot;, value = &quot;enabled&quot;, matchIfMissing = true)</span><br><span class="line">public class LNWAutoConfiguration &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LNWProperties lnwProperties;</span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingBean(LNWService.class)  //前提：LNWService Bean不存在</span><br><span class="line">    public LNWService getLNWService()&#123;</span><br><span class="line">        LNWService service = new LNWService();</span><br><span class="line">         // 设置message属性，这个Service里面的message就会被改变</span><br><span class="line">        service.setMessage(lnwProperties.getMessage());</span><br><span class="line">        return service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.properties;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">// 读取前缀为lnw的属性</span><br><span class="line">@ConfigurationProperties(prefix = &quot;lnw&quot;)</span><br><span class="line">public class LNWProperties &#123;</span><br><span class="line"></span><br><span class="line">    private final static String MESSAGE = &quot;LNW-SPRING-BOOT&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认值为MESSAGE</span><br><span class="line">     */</span><br><span class="line">    private String message = MESSAGE;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.service;</span><br><span class="line">public class LNWService &#123;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHello()&#123;</span><br><span class="line">        return &quot;Hello &quot; + message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是spring.factories，我们要把LNWAutoConfiguration这个配置文件交给springboot<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.lnw.config.LNWAutoConfiguration</span><br></pre></td></tr></table></figure></p>
<p>接下来写一个SpringBoot项目（先添加SpringBoot依赖）<br>在pom文件中，添加我们上面写的那个项目<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304102817198.png" alt=""><br>然后在项目的application.properties中，添加<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304102929243.png" alt=""></p>
<p>我们开始测试，SpringBoot默认是有添加test依赖的，我们直接使用SpringBoot的test来测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw;</span><br><span class="line"></span><br><span class="line">import com.lnw.controller.HelloController;</span><br><span class="line">import com.lnw.service.LNWService;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">import org.springframework.test.web.servlet.MockMvc;</span><br><span class="line">import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;</span><br><span class="line">import org.springframework.test.web.servlet.setup.MockMvcBuilders;</span><br><span class="line"></span><br><span class="line">import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringbootSwaggerApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LNWService lnwService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testAutoConfigure()&#123;</span><br><span class="line">        System.out.println(lnwService.sayHello());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后输出<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304103449613.png" alt=""><br>再改变一下值<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304103524932.png" alt=""><br>再运行<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304103600098.png" alt=""><br>这样就OK了</p>
<h1 id="SpringBoot扫描spring-factories的原理"><a href="#SpringBoot扫描spring-factories的原理" class="headerlink" title="SpringBoot扫描spring.factories的原理"></a>SpringBoot扫描spring.factories的原理</h1><p>关于SpringFactoriesLoader，它在SpringBoot程序启动的时候，在刷新容器中会被执行。<br>他可以从classpath下的每个jar包中搜寻所有META-INF/spring.factories配置文件，然后解析spring.factories的内容得到Configuration类。<br>在上的SpringBoot的项目中，扫描出来的@Configuration有100duoge<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304101817584.png" alt=""><br>其实底层是用了ClassLoader类加载器的<strong> getResources(name) </strong> 方法，该方法会遍历其负责加载的所有jar包，找到jar包中名称为name的资源文件，这里的资源文件可以是任何文件<br>所以SpringBoot的SpringFactoriesLoader就是利用ClassLoader这个方法去查找所有jar包下的META-INF/spring.factories文件。<br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304104124112.png" alt=""><br><img src="/2019/03/03/为什么SpringBoot可以不用配置文件/20190304104129043.png" alt=""></p>
<h2 id="模拟SpringFactoriesLoader"><a href="#模拟SpringFactoriesLoader" class="headerlink" title="模拟SpringFactoriesLoader"></a>模拟SpringFactoriesLoader</h2><p>我们也可以自己写个测试来寻找当前所有jar包中的spring.factories文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line">public class FindResourcesTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String name = &quot;META-INF/spring.factories&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader()</span><br><span class="line">                    .getResources(name);</span><br><span class="line">            while (urls.hasMoreElements())&#123;</span><br><span class="line">                URL url = urls.nextElement();</span><br><span class="line">                System.out.println(url.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jar:file:/C:/Users/%e6%9e%97%e6%a5%a0%e7%82%9c/.m2/repository/org/springframework/boot/spring-boot/2.1.0.RELEASE/spring-boot-2.1.0.RELEASE.jar!/META-INF/spring.factories</span><br><span class="line">jar:file:/C:/Users/%e6%9e%97%e6%a5%a0%e7%82%9c/.m2/repository/org/springframework/spring-beans/5.1.2.RELEASE/spring-beans-5.1.2.RELEASE.jar!/META-INF/spring.factories</span><br><span class="line">file:/E:/IDEA/simulation-integration/lnw-spring-boot-auto-config/target/classes/META-INF/spring.factories</span><br><span class="line">jar:file:/C:/Users/%e6%9e%97%e6%a5%a0%e7%82%9c/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/2.1.0.RELEASE/spring-boot-autoconfigure-2.1.0.RELEASE.jar!/META-INF/spring.factories</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后我来总结一下为什么SpringBoot不用配置文件就能实现配置：<br>1、每个SpringBoot的主程序类都有一个@SpringBootApplication注解。这个注解里面有一个十分重要的注解@EnableAutoConfiguration<br>2、@EnableAutoConfiguration注解里面引用了一个类AutoConfigurationImportSelector，这个类非常重要<br>3、AutoConfigurationImportSelector里面调用了一个方法-&gt;SpringFactoriesLoader.loadFactoryNames<br>4、SpringFactoriesLoader.loadFactoryNames方法，会去扫描当前所有jar包下的METS-INF/spring.factories文件，并把文件的内容扫描放到一个List中<br>5、生成的List会交给BeanFactory解析</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/一段String代码引发的思考/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/一段String代码引发的思考/" itemprop="url">一段String代码引发的思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T20:19:08+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题的出现"><a href="#问题的出现" class="headerlink" title="问题的出现"></a>问题的出现</h1><p>  String对象我们写Java的不可能没用过吧，但是你知道字符串常量池吗？今天就来聊聊JVM底层的字符串常量池，什么时候把字符串放进常量池？JDK1.6跟JDK1.7的常量池有什么变化？除了字符串常量池还有没有其他的常量池<br>先来看一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;1&quot;);</span><br><span class="line">s1.intern();</span><br><span class="line">String s2 = &quot;1&quot;;</span><br><span class="line">System.out.println(s1==s2);   // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String  s3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;22&quot;;</span><br><span class="line">System.out.println(s3 == s4);  // true</span><br></pre></td></tr></table></figure></p>
<p>总共有两句输出，你知道两句输出的结果是什么吗？虽然注释第一个为false，第二个为true。但是在JDK1.6里面，两个都为false，你知道为什么吗？请开始我的表演。</p>
<h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  说白了，字符串常量池就是用来存放字符串数据（在内存中）。但是注意，字符串常量池只是JVM中的一种常量池，其他的还有<strong> class文件常量池 </strong> ，<strong> 运行时常量池 </strong><br>  一时间也说不清楚其他两种常量池的作用和关系，只知道运行时常量池包含class文件常量池和字符串常量池，而且运行时常量池都存在于<strong> 方法区 </strong><br>  在JDK1.6及以前版本，字符串常量池是存在于运行时常量池，也就是存在于方法区中的。但是，JDK1.7以后，字符串常量池就被移出到<strong> 堆 </strong> 里面了。</p>
<h2 id="什么时候才可以向字符串常量池添加数据"><a href="#什么时候才可以向字符串常量池添加数据" class="headerlink" title="什么时候才可以向字符串常量池添加数据"></a>什么时候才可以向字符串常量池添加数据</h2><ul>
<li>1、常量的字符串，就是被关键字final修饰的字符串，会在编译时添加进字符串常量池</li>
<li>2、显示声明的时候。比如String s=”1”，这时，当执行这段代码的时候，就会向字符串常量池里面添加数据，叫做字面量</li>
<li>3、调用String类的intern方法时（这个方法在JDK1.6和1.7里面有差异，等下面再说）</li>
</ul>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>  经过上面的一番操作，我们应该理解常量池（在方法区中）和堆是两个不同的东西。所以，我们可以推测，上面的代码之所以输出的结果会不一样，原因应该是有些对象是在堆里面，有些对象是常量池里面的。</p>
<h2 id="首先看第一个输出那段代码"><a href="#首先看第一个输出那段代码" class="headerlink" title="首先看第一个输出那段代码"></a>首先看第一个输出那段代码</h2><p>String s1 = new String(“1”);请问这句代码一共创建了多少个对象？1个？错！是两个。s1是一个，还有一个就是上面说过的字面量，”1”就是字面量，此时会在字符串常量池里面创建一个”1”的对象，所以总共两个。<strong> s1指向的是堆里面的”1”对象 </strong> ，接下来调用intern方法，下面就来解释下该方法的作用</p>
<h2 id="intern（）方法的作用"><a href="#intern（）方法的作用" class="headerlink" title="intern（）方法的作用"></a>intern（）方法的作用</h2><p>简单的讲，intern方法就是<strong> 向常量池里面添加数据 </strong> ，前提是<strong> 该数据还不在常量池里面 </strong> ，然后返回一个String对象<br>  JDK1.6里面，intern方法向字符串常量池里面添加的是对象，也就是比如s1.intern（s1是String对象，值为1），如果常量池里面还没有”1”这个对象，就会将”1”这个对象添加到常量池里面。如果常量池里面已经有”1”这个对象了，则返回<strong> 常量池里面的对象 </strong> 。<br>  JDK1.7里面，如果常量池里面有”1”这个对象，做法跟1.6时一样，返回<strong> 常量池里面的对象 </strong> ，但是，如果常量池里面没有该值的对象，则添加的是<strong> 对s1在堆中的对象的引用 </strong> （说得有点绕口，说白了就是添加在堆中的对象）。<br>  我们看下代码就知道了<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;1&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2); // false</span><br><span class="line"></span><br><span class="line">String s3 = &quot;1&quot;;</span><br><span class="line">System.out.println(s2 == s3); // true</span><br></pre></td></tr></table></figure></p>
<p>  执行s1.intern返回的是常量池里面的对象，因为上一句代码已经创建了两个对象，一个在堆里面，一个在常量池里面。所以intern方法会发现常量池里面已经有”1”这个对象了，则返回该对象。s3也是常量池里面的”1”对象，所以一个输出false，一个输出true.</p>
<h2 id="继续分析"><a href="#继续分析" class="headerlink" title="继续分析"></a>继续分析</h2><p>  我们前面说到intern方法只是检查常量池里面有没有该值，有则返回（返回的是常量池里面的对象），没有则添加（JDK1.6和1.7的添加规则不同）。接下来String s2=”1”；因为s2是字面量，也就是显示声明，而且常量池里面已经有”1”这个对象了。所以答案就很明显了，s1是在堆里面的”1”对象，s2是在字符串常量池里面的”1”对象，所以两者是不会相等的，结果为false。</p>
<h2 id="继续分析第二段代码"><a href="#继续分析第二段代码" class="headerlink" title="继续分析第二段代码"></a>继续分析第二段代码</h2><p>  String s3 = new String(“2”) + new String(“2”);这里虽然也是创建了两个对象，一个是”22”的堆对象，一个是”2”的常量池对象，注意：没有”22”常量池对象。<br>  接下来调用intern方法，因为字符串常量池还没有”22”这个对象，所以重点来了，如果是JDK1.7，添加的是<strong> 堆里面”22”这个对象的引用（说白了就是堆里面”22”这个对象）</strong> ，所以常量池里面的”22”这个对象会指向堆里面”22”这个对象。所以下一句代码String s4=”22”，貌似是常量池里面的”22”对象，但是因为此时常量池的”22”对象已经指向了堆里面的”22”对象，所以说s4也是堆里面的对象。所以输出结果为true。<br>  但是如果是JDK1.6，在调用intern方法的时候，因为常量池的”22”这个对象还不存在，所以就添加了”22”这个常量池对象，注意：<strong> 是常量池对象 </strong> ，所以下一句的String s4=”22”就是常量池对象了，结果就输出了false。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说了那么多，其实就一句——常量池对象跟堆里面的对象时不一样的（只是简单理解，不要当真）<br>贴出总代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.stringpool;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 第一条代码一运行，会创建两个对象。</span><br><span class="line">         * 一个对象是常量池 &quot;1&quot;的对象，存储在字符串常量池中</span><br><span class="line">         * 另一个对象是 String 对象s1</span><br><span class="line">         * 这里s1因为是new出来的，所以s1是堆里面的String对象</span><br><span class="line">         */</span><br><span class="line">        String s1 = new String(&quot;1&quot;);</span><br><span class="line">        /**</span><br><span class="line">         * 调用intern方法，如果&quot;1&quot;不在字符串常量池中，则将s1对象的引用（内存中的地址）添加到字符串常量池中</span><br><span class="line">         * JDK1.7以上就是添加对象的引用，但是1.7以下是直接将&quot;1&quot;添加到常量池</span><br><span class="line">         * 但是如果存在这个&quot;1&quot;值的对象，则返回该对象</span><br><span class="line">         * 返回的常量池里面的对象</span><br><span class="line">         */</span><br><span class="line">        String s5 = s1.intern();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 因为s5是返回常量池里面的&quot;1&quot;对象</span><br><span class="line">         * s1是堆里面的对象</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s1 == s5);  // false</span><br><span class="line">        /**</span><br><span class="line">         * 第三条代码运行时，因为上面第一条代码已经将&quot;1&quot;放进了字符串常量池了</span><br><span class="line">         * 所以s2是字符创常量池里面的&quot;1&quot;对象</span><br><span class="line">         */</span><br><span class="line">        String s2 = &quot;1&quot;;</span><br><span class="line">        /**</span><br><span class="line">         * 因为s1是堆里面String对象，s2是字符串常量池&quot;1&quot;的对象，所以为false</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s1==s2);   // false</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 因为s5是返回常量池里面的&quot;1&quot;对象</span><br><span class="line">         * s2也是常量池里面&quot;1&quot;的对象</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s5 == s2); // true</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 这里的s3显然是&quot;22&quot;，但是，&quot;22&quot;还没有进入字符串常量</span><br><span class="line">         * 也就是说，目前字符串常量里面只有&quot;2&quot;这个对象</span><br><span class="line">         * 但是，堆中有&quot;22&quot;这个对象</span><br><span class="line">         * s3就是指向&quot;22&quot;这个堆中的对象的引用</span><br><span class="line">         */</span><br><span class="line">        String  s3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">        /**</span><br><span class="line">         * 因为&quot;22&quot;还没有进入字符串常量，所以把s3这个对象对应的在堆中&quot;22&quot;这个对象的引用推入字符串常量池</span><br><span class="line">         * 也就是说字符串常量池的&quot;22&quot;会指向堆里面&quot;22&quot;这个对象</span><br><span class="line">         * 如果值已经存在，则返回常量池里面值&quot;22&quot;的对象</span><br><span class="line">         */</span><br><span class="line">        String s6 = s3.intern();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 因为s6和s3都是堆里面&quot;22&quot;这个对象的引用，所以为true</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s6 == s3);  // true</span><br><span class="line">        /**</span><br><span class="line">         * 因为上面的intern方法已经将&quot;22&quot;这个对象的引用放进字符创常量池</span><br><span class="line">         * 所以s4指向的堆里面&quot;22&quot;这个对象</span><br><span class="line">         */</span><br><span class="line">        String s4 = &quot;22&quot;;</span><br><span class="line">        /**</span><br><span class="line">         * 因为s4和s3引用的都是堆里面的对象，所以为true</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s3 == s4);  // true</span><br><span class="line"></span><br><span class="line">        System.out.println(s6 == s4);  // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/24/git学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/24/git学习/" itemprop="url">git学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-24T20:29:20+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h1><p>git init 就是把当前文件夹初始化为git仓库，这个文件夹就会被git所托管，文件夹里面的文件发生的所有改变都会被git所发现，而且该文件夹下就会多了一个.git的目录。<br>我们创建Git版本库时，Git自动为我们创建了唯一一个master分支</p>
<h1 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h1><p>git add就是告诉Git，把文件添加到仓库（只是添加到暂存区）。即使有个文件已经在当前文件夹，但是没有使用git add 文件名 命令，该文件也还是不存在git仓库<br>可以使用git add . 一下子添加当前目录下的所有文件</p>
<h1 id="git-commit-m"><a href="#git-commit-m" class="headerlink" title="git commit -m"></a>git commit -m</h1><p>git commit告诉Git，把文件提交到仓库先将文件添加给Git托管，只有调用commit才算是正在的添加到仓库中。git commit后面要加上 -m参数，-m 参数代表本次提交的说明，最好输入的是有意义的内容，以便以后可以在历史中方便找到改动的记录</p>
<h1 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h1><p>git status可以查看当前文件夹下有哪些文件被修改或者哪些文件没有被Git锁管理</p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>git diff 可以查看当前目录下的文件跟上次提交的文件具体做了哪些修改</p>
<h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p>git log 列出了我们往期提交的所有历史记录。如果感觉输出的内容太多，可以加上–pretty=oneline命令</p>
<h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>如果我们提交过多个版本，但是如果我们想回退到上一个版本，可以使用git reset命令<br>回退到上一个版本 git reset –hard HEAD^<br>回退到上上一个版本 git reset –hard HEAD^^<br>回退到上100个版本 git reset –hard HEAD~100<br>但是回退版本最好使用版本号，版本号可是使用git log查看，每次提交都会生成一个版本号，版本号不用全写，只需写前面几位就可以，git会自动识别。</p>
<p>深入进去了解的话，我们每次提交，git里面会有一条链表记录，而且会有指针指向当前版本<br><img src="/2019/02/24/git学习/20190224085606485.png" alt=""><br>当版本回退时，比如回退到上一个版本，只需修改指针即可<br><img src="/2019/02/24/git学习/20190224085649620.png" alt=""></p>
<ul>
<li>图来自廖雪峰老师讲的Git课程<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000</a></li>
</ul>
<p>一张图解释add、commit、跟HEAD之间的关系<br><img src="/2019/02/24/git学习/20190224085857433.png" alt=""></p>
<p>此外，还可以使用git checkout – file 直接丢弃工作区的修改</p>
<h1 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h1><p>git rm用于删除文件，这里的删除只是从版本库里面删除</p>
<h1 id="添加项目到GitHub"><a href="#添加项目到GitHub" class="headerlink" title="添加项目到GitHub"></a>添加项目到GitHub</h1><p>要将项目提交到GitHub，首先需要在GitHub上建一个仓库，然后复制仓库的地址，在本地将仓库clone下来，然后把你Java项目或者其他项目放进你从GitHub上clone下来的文件夹，接下来就是用git命令了<br>命令<br>1、使用 git status 查看文件夹下有哪些没有被git所管理</p>
<p>2、 git add . 将当前文件夹下的所有文件托管给git 的仓库</p>
<p>3、 git commit -m “提交项目”  告诉git 将项目提交到仓库， -m 后面是说明，内容随意，只是最好是有意义的说明，以便后面可以从历史上看到变动的记录</p>
<p>4、git push -u origin master  最后将当前的master分支推送到远程仓库，也就是将当前被git管理的所有东西添加到远程仓库</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/使用redis的分布式锁实现一个简单的秒杀系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/使用redis的分布式锁实现一个简单的秒杀系统/" itemprop="url">使用redis的分布式锁实现一个简单的秒杀系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T16:03:51+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/实战/" itemprop="url" rel="index">
                    <span itemprop="name">实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>实现秒杀系统时，为了控制并发造成商品数量的不一致，我们可能会在程序中使用锁，比如一般会用synchronized关键字或者ReentrantLock的Lock锁来加锁，但是这种加锁的最细粒子程度只能到代码段，按照我们的想法，当发生对同一个商品（比如id）执行操作时，才需要加锁；但是如果此时进来两个不同的商品（比如id为100和200），我们可以不用加锁，因为两个不同的商品互不干扰，就算不加锁也不会出现并发问题。而我们如果使用synchronized或者Lock实现加锁时，当两个并发访问两个不同的商品时，还是会对我们的代码段加锁。<br>这时，我们可以使用redis的setnx（set if not exists)来实现加锁的功能，setnx（key, value)就是如果key不存在redis，就运行设置（key，value）值。如果key值已经存在，就不允许操作。我们可以利用这个特性，在程序对商品进行操作时，可以向redis进行setnx，key值可以为商品的id比如gId:10092，value值随意。如果redis成功设置了gId:10092则证明目前除了当前操作还没有人对商品进行修改，当我们完成了对商品的操作完，记得一定要<strong> 把key值删除掉（del key) </strong> 。 如果redis设置gId:10092失败了，则说明当前有人正在修改商品的属性，我们可以先放弃操作，休息一小段时间后再请求。这样就差不多是占“茅坑”，茅坑有很多个，当你想要蹲的茅坑已经被别人占时，你只好先放弃然后稍后再尝试。<br>可能有人会问，为什么要绕这么大的弯子去请求redis服务器再操作了呢？主要有两个原因：第一、上面已经说了，如果用Synchronized或者Lock锁，就算是不同的商品，都会对核心代码段产生竞争。第二、Redis足够快，它是纯内存操作的，速度很快，就算是发送请求访问redis，延迟可以忽略不计。</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>Maven，Spring环境，SpringAOP环境，Jedis包，junti测试包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.8.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="秒杀的逻辑"><a href="#秒杀的逻辑" class="headerlink" title="秒杀的逻辑"></a>秒杀的逻辑</h3><p>假设我们就只有一个服务——秒杀商品，我们先定义一个接口，然后写一个实现类，接口里面只有一个秒杀方法<br>秒杀接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package workspace;</span><br><span class="line">public interface SecKill &#123;</span><br><span class="line">    public void seckill(String userId, Long gId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>秒杀实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package workspace;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">@Service</span><br><span class="line">public class SecKillImpl implements SecKill &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 模拟数据库</span><br><span class="line">     */</span><br><span class="line">    static Map&lt;Long, Long&gt; inventory ;</span><br><span class="line">    static &#123;</span><br><span class="line">        inventory = new HashMap&lt;&gt;();</span><br><span class="line">        // 插入两条数据</span><br><span class="line">        inventory.put(10001L, 1000L);</span><br><span class="line">        inventory.put(10002L, 1000L);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void seckill(String userId, Long gId) &#123;</span><br><span class="line">        if (null!=userId)&#123;</span><br><span class="line">            reduceInventory(gId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 库存减一</span><br><span class="line">     * @param gId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long reduceInventory(Long gId)&#123;</span><br><span class="line">        inventory.put(gId, inventory.get(gId)-1);</span><br><span class="line">        return  inventory.get(gId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们用HashMap模拟数据库，数据里面有两条数据，库存都是1000，秒杀的逻辑就是让库存减一</p>
<h3 id="AOP切面实现加锁解锁"><a href="#AOP切面实现加锁解锁" class="headerlink" title="AOP切面实现加锁解锁"></a>AOP切面实现加锁解锁</h3><p>接下来，我用AOP对seckill方法进行增强，在不改变seckill方法的前提下，利用AOP的环绕通知对seckill进行加锁和解锁，所以需要配置AOP环境<br>配置切面切点和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package config;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import workspace.JedisLock;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class AOPConfig implements BeanFactoryAware &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 客户端获取锁失败后轮询获取锁的时间30秒</span><br><span class="line">     */</span><br><span class="line">    final static Long TIME_OUT = 90L;</span><br><span class="line">    /**</span><br><span class="line">     * Redis中键的过期时间10秒</span><br><span class="line">     */</span><br><span class="line">    final static int EXPIRE = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 记录失败操作的次数</span><br><span class="line">     */</span><br><span class="line">    public static Long ERROR_COUNT = 0L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行秒杀方法时(载点)</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;execution(* workspace.SecKillImpl.seckill(..))&quot;)</span><br><span class="line">    public void pointCut()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Around(&quot;pointCut()&quot;)</span><br><span class="line">    public boolean around(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        Object[] objects = pjp.getArgs();</span><br><span class="line">        Long gId = (Long) objects[1];</span><br><span class="line">        JedisLock lock = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+&quot; before executing--&quot;);</span><br><span class="line">            lock = createJedisLock();</span><br><span class="line">            if (lock.lock(gId,TIME_OUT, EXPIRE)) &#123;</span><br><span class="line">                pjp.proceed();</span><br><span class="line">                System.out.println(&quot;--after executing--&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+&quot;  操作失败--&quot;);</span><br><span class="line">                ERROR_COUNT++;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock(gId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanFactory beanFactory;</span><br><span class="line">    public JedisLock createJedisLock()&#123;</span><br><span class="line">        return this.beanFactory.getBean(JedisLock.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>1、使用around环绕通知，是为了在执行seckill秒杀方法前对其进行加锁，在方法执行完成后进行解锁。如果获取不到锁，就不能执行seckill秒杀方法</li>
<li>2、实现BeanFactoryAware接口的原因是，为了获取原型的JedisLock，JedisLock是操作Jedis的封装，每个JedisLock代表一条Jedis连接，操作完需要关闭Jedis。而且JedisLock需要注明是prototype原型对象</li>
<li>3、必须设置KEY的过期时间，也就是加锁在redis的有效时间，这必须设置，防止因为突发原因比如服务器忽然宕机忘记解锁导致其他客户端获取不到锁</li>
</ul>
<h3 id="JedisLock实现加解锁"><a href="#JedisLock实现加解锁" class="headerlink" title="JedisLock实现加解锁"></a>JedisLock实现加解锁</h3><p>接下来说下JedisLock的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package workspace;</span><br><span class="line"></span><br><span class="line">import config.JedisFactory;</span><br><span class="line">import org.springframework.beans.factory.InitializingBean;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Scope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class JedisLock implements InitializingBean &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    JedisFactory jedisFactory;</span><br><span class="line">    </span><br><span class="line">    Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 该标志用于判断是否需要删除锁</span><br><span class="line">     */</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public boolean isFlag() &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFlag(boolean flag) &#123;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        // 每个Jedis锁对应一个Jedis连接</span><br><span class="line">        // 只有最后调用unlock，才释放Jedis连接</span><br><span class="line">        this.jedis = jedisFactory.getJedis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean lock(Long gId, long timeout, int expire) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Long startTime = System.currentTimeMillis() / 1000;</span><br><span class="line">            // 在限定时间内有限循环轮询</span><br><span class="line">            while (System.currentTimeMillis() / 1000 - startTime &lt; timeout) &#123;</span><br><span class="line">                // 如果获取锁成功</span><br><span class="line">                Long result = 0L;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 调用redis的setnx</span><br><span class="line">                    result = jedis.setnx(gId.toString(), &quot;1&quot;);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (result == 1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getId() + &quot;获取&quot;+ gId +&quot;锁成功&quot;);</span><br><span class="line">                    // 设置过期时间</span><br><span class="line">                    jedis.expire(gId + &quot;&quot;, expire);</span><br><span class="line">                    this.flag = true;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果获取不到锁</span><br><span class="line">                System.out.println(Thread.currentThread().getId() + &quot;出现锁等待&quot;);</span><br><span class="line">                // 短暂休眠，尽可能的避免活锁</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+ &quot;获取锁&quot;+gId+&quot;错误&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock(Long gId) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this.flag)&#123;</span><br><span class="line">                // 直接删除</span><br><span class="line">                jedis.del(gId + &quot;&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+ &quot;删除&quot; + gId +&quot;锁成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            if (jedis.isConnected()) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是通过JedisFactory获取Jedis连接，JedisFactory也是自己实现，等下会有说明。这里需要特别注意两点</p>
<ul>
<li>1、JedisLock必须是原型模式，因为并发操作时，每个操作代表一个用户，每个用户需要对应一条Redis连接，避免多个用户公用一条Jedis连接，防止其中一个用户关闭了连接导致另一个不能用</li>
<li>2、实现InitializingBean方法，每生成一个Bean就初始化一条Jedis连接</li>
</ul>
<h3 id="JedisFactory创建Jedis连接"><a href="#JedisFactory创建Jedis连接" class="headerlink" title="JedisFactory创建Jedis连接"></a>JedisFactory创建Jedis连接</h3><p>跟数据库连接池一样，这里需要使用一JedisPool创建Jedis连接池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package config;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.pool2.impl.GenericObjectPoolConfig;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class JedisFactory &#123;</span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    </span><br><span class="line">    public JedisFactory() &#123;</span><br><span class="line">        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();</span><br><span class="line">        poolConfig.setMaxIdle(100);</span><br><span class="line">        poolConfig.setMinIdle(1);</span><br><span class="line">        poolConfig.setMaxTotal(1000);</span><br><span class="line">        poolConfig.setMaxWaitMillis(5000);</span><br><span class="line">        this.jedisPool = new JedisPool(poolConfig, &quot;127.0.0.1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Jedis getJedis() &#123;</span><br><span class="line">        Jedis jedis = jedisPool().getResource();</span><br><span class="line">        return jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JedisPool jedisPool() &#123;</span><br><span class="line">        if (this.jedisPool != null) &#123;</span><br><span class="line">            return this.jedisPool;</span><br><span class="line">        &#125;</span><br><span class="line">        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();</span><br><span class="line">        poolConfig.setMaxIdle(100);</span><br><span class="line">        poolConfig.setMinIdle(1);</span><br><span class="line">        poolConfig.setMaxTotal(1000);</span><br><span class="line">        JedisPool jedisPool = new JedisPool(poolConfig, &quot;127.0.0.1&quot;);</span><br><span class="line">        this.jedisPool = jedisPool;</span><br><span class="line">        return this.jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要是创建一个JedisPool的连接池，设置连接池大小和每条连接的最长连接时间，getJedis方法就是从JedisPool里面获取一条Jedis连接<br>逻辑大概就是这样，接下来就来测试一下</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>因为是使用Spring，所以需要配置Spring环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package config;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;config&quot;, &quot;workspace&quot;&#125;)</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注解扫描指定的包，开启AOP功能</p>
<p>开始测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package workspace;</span><br><span class="line">import config.AOPConfig;</span><br><span class="line">import config.AppConfig;</span><br><span class="line">import config.JedisFactory;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">public class App </span><br><span class="line">&#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSecKill()&#123;</span><br><span class="line"></span><br><span class="line">        final ApplicationContext ac = new AnnotationConfigApplicationContext();</span><br><span class="line">        ((AnnotationConfigApplicationContext) ac).register(AppConfig.class);</span><br><span class="line">        ((AnnotationConfigApplicationContext) ac).refresh();</span><br><span class="line">        System.out.println(&quot;获取SecKill  Bean&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int threadCount = 100;</span><br><span class="line">        int splitPoint = threadCount / 2;</span><br><span class="line">         final CountDownLatch endCount = new CountDownLatch(threadCount);</span><br><span class="line">         final CountDownLatch beginCount = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">        Thread[] threads = new Thread[threadCount];</span><br><span class="line">        //起500个线程，秒杀第一个商品</span><br><span class="line">        for(int i= 0;i &lt; splitPoint;i++)&#123;</span><br><span class="line">            threads[i] = new Thread(new  Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //等待在一个信号量上，挂起</span><br><span class="line">                        beginCount.await();</span><br><span class="line">                        SecKill secKill = ac.getBean(SecKill.class);</span><br><span class="line">                        // 该方法会被AOP代理</span><br><span class="line">                        secKill.seckill(&quot;1&quot;, 10001L);</span><br><span class="line"></span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;finally &#123;</span><br><span class="line">                        endCount.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //再起500个线程，秒杀第二件商品</span><br><span class="line">        for(int i= splitPoint;i &lt; threadCount;i++)&#123;</span><br><span class="line">            threads[i] = new Thread(new  Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //等待在一个信号量上，挂起</span><br><span class="line">                        beginCount.await();</span><br><span class="line">                        SecKill secKill = ac.getBean(SecKill.class);</span><br><span class="line">                        // 该方法会被AOP代理</span><br><span class="line">                        secKill.seckill(&quot;1&quot;, 10002L);</span><br><span class="line"></span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;finally &#123;</span><br><span class="line">                        endCount.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long startTime = System.currentTimeMillis()/1000;</span><br><span class="line">        //主线程释放开始信号量，并等待结束信号量，这样做保证1000个线程做到完全同时执行，保证测试的正确性</span><br><span class="line">        // 也就说开始让线程工作</span><br><span class="line">        beginCount.countDown();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //主线程等待结束信号量，也就是等待其他线程的工作全部做完</span><br><span class="line">            endCount.await();</span><br><span class="line">            //观察秒杀结果是否正确</span><br><span class="line">            System.out.println(SecKillImpl.inventory.get(10001L));</span><br><span class="line">            System.out.println(SecKillImpl.inventory.get(10002L));</span><br><span class="line">            System.out.println(&quot;error count&quot; + AOPConfig.ERROR_COUNT);</span><br><span class="line">            System.out.println(&quot;total cost &quot; + (System.currentTimeMillis()/1000 - startTime));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的说明一下</p>
<ul>
<li>1、先让Spring跑起来，把我们写的AppConfig注册进去</li>
<li>2、声明CountDownLatch（阀），是为了最后数据的正确性校验，等所有线程跑完了再输出最后库存里的剩余数量是否正确</li>
<li>3、我们开启100个线程测试，50个操作10001商品，50个操作10002商品，如果操作正确的话，最后两个商品的库存应该都是950</li>
</ul>
<p>最后结果：<br><img src="/2019/02/23/使用redis的分布式锁实现一个简单的秒杀系统/20190224021815748.png" alt=""><br>库存跟我们预想的一致</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>当线程很多的时候，比如有1000个线程，为了顺利通过测试，需要延长每个操作循环等待锁的时间。我使用1000个线程并发时，需要延长时间至60秒（不知道是不是我电脑的问题…）<br>或者你可以使用另一个Redis的连接池——lettuce，我测试过了，lettuce比以往的JedisPool更快，1000个并发使用JedisPool需要60秒，而使用lettuce则需要不到40秒</p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/SouthLight-Lin/redis-in-seckill" target="_blank" rel="noopener">https://github.com/SouthLight-Lin/redis-in-seckill</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/类的加载时候的初始化顺序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/类的加载时候的初始化顺序/" itemprop="url">类的加载时候的初始化顺序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T21:23:21+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在牛客网上刷题时，一直做错类的加载时初始化这些题，不懂静态方法什么时候执行，初始化代码块什么时候执行，构造方法什么执行，今天在这里谨记，下次要是再做错，我….</p>
<h1 id="题型一"><a href="#题型一" class="headerlink" title="题型一"></a>题型一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public A()&#123;</span><br><span class="line">		System.out.println(&quot;构造方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;初始化块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;A的静态main方法&quot;);</span><br><span class="line">		new A();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出执行顺序，执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">A的静态main方法</span><br><span class="line">初始化块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure></p>
<h1 id="题型二"><a href="#题型二" class="headerlink" title="题型二"></a>题型二</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;父类静态代码块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public A()&#123;</span><br><span class="line">		System.out.println(&quot;父类构造方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;父类初始化块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class B extends A&#123;</span><br><span class="line">	static&#123;</span><br><span class="line">		System.out.println(&quot;子类静态代码块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public B()&#123;</span><br><span class="line">		System.out.println(&quot;子类构造方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;子类初始化块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		new B();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出执行过程，结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类静态代码块</span><br><span class="line">子类静态代码块</span><br><span class="line">父类初始化块</span><br><span class="line">父类构造方法</span><br><span class="line">子类初始化块</span><br><span class="line">子类构造方法</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于题型一，谨记：静态的修饰变量（static）总是先于构造方法和普通代码块执行。static中又有static静态变量，static静态初始化块，static静态方法，里面静态方法是最后执行的，所以题型一中先执行静态代码块再执行静态方法。（原因：用static修饰的地方在编译器编译时就已经开始执行）<br>对于题型二，谨记：<strong> 先执行父类的静态代码块，然后执行子类的静态代码块 </strong> ，因为在编译时就开始执行。接着调用main方法，里面开始new B，所以 <strong> 执行父类的普通初始化块-&gt;父类的构造方法快-&gt;最后执行子类的普通初始化块-&gt;子类的构造块 </strong> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">SouthLight Lin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SouthLight Lin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
