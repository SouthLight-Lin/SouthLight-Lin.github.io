<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="SouthLight&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SouthLight&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SouthLight&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>SouthLight's Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">SouthLight's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/liguosheng/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/liguosheng/" itemprop="url">liguosheng</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-03T09:24:39+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AAAAA</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/一段String代码引发的思考/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/一段String代码引发的思考/" itemprop="url">一段String代码引发的思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T20:19:08+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题的出现"><a href="#问题的出现" class="headerlink" title="问题的出现"></a>问题的出现</h1><p>  String对象我们写Java的不可能没用过吧，但是你知道字符串常量池吗？今天就来聊聊JVM底层的字符串常量池，什么时候把字符串放进常量池？JDK1.6跟JDK1.7的常量池有什么变化？除了字符串常量池还有没有其他的常量池<br>先来看一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;1&quot;);</span><br><span class="line">s1.intern();</span><br><span class="line">String s2 = &quot;1&quot;;</span><br><span class="line">System.out.println(s1==s2);   // false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String  s3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = &quot;22&quot;;</span><br><span class="line">System.out.println(s3 == s4);  // true</span><br></pre></td></tr></table></figure></p>
<p>总共有两句输出，你知道两句输出的结果是什么吗？虽然注释第一个为false，第二个为true。但是在JDK1.6里面，两个都为false，你知道为什么吗？请开始我的表演。</p>
<h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  说白了，字符串常量池就是用来存放字符串数据（在内存中）。但是注意，字符串常量池只是JVM中的一种常量池，其他的还有<strong> class文件常量池 </strong> ，<strong> 运行时常量池 </strong><br>  一时间也说不清楚其他两种常量池的作用和关系，只知道运行时常量池包含class文件常量池和字符串常量池，而且运行时常量池都存在于<strong> 方法区 </strong><br>  在JDK1.6及以前版本，字符串常量池是存在于运行时常量池，也就是存在于方法区中的。但是，JDK1.7以后，字符串常量池就被移出到<strong> 堆 </strong> 里面了。</p>
<h2 id="什么时候才可以向字符串常量池添加数据"><a href="#什么时候才可以向字符串常量池添加数据" class="headerlink" title="什么时候才可以向字符串常量池添加数据"></a>什么时候才可以向字符串常量池添加数据</h2><ul>
<li>1、常量的字符串，就是被关键字final修饰的字符串，会在编译时添加进字符串常量池</li>
<li>2、显示声明的时候。比如String s=”1”，这时，当执行这段代码的时候，就会向字符串常量池里面添加数据，叫做字面量</li>
<li>3、调用String类的intern方法时（这个方法在JDK1.6和1.7里面有差异，等下面再说）</li>
</ul>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>  经过上面的一番操作，我们应该理解常量池（在方法区中）和堆是两个不同的东西。所以，我们可以推测，上面的代码之所以输出的结果会不一样，原因应该是有些对象是在堆里面，有些对象是常量池里面的。</p>
<h2 id="首先看第一个输出那段代码"><a href="#首先看第一个输出那段代码" class="headerlink" title="首先看第一个输出那段代码"></a>首先看第一个输出那段代码</h2><p>String s1 = new String(“1”);请问这句代码一共创建了多少个对象？1个？错！是两个。s1是一个，还有一个就是上面说过的字面量，”1”就是字面量，此时会在字符串常量池里面创建一个”1”的对象，所以总共两个。<strong> s1指向的是堆里面的”1”对象 </strong> ，接下来调用intern方法，下面就来解释下该方法的作用</p>
<h2 id="intern（）方法的作用"><a href="#intern（）方法的作用" class="headerlink" title="intern（）方法的作用"></a>intern（）方法的作用</h2><p>简单的讲，intern方法就是<strong> 向常量池里面添加数据 </strong> ，前提是<strong> 该数据还不在常量池里面 </strong> ，然后返回一个String对象<br>  JDK1.6里面，intern方法向字符串常量池里面添加的是对象，也就是比如s1.intern（s1是String对象，值为1），如果常量池里面还没有”1”这个对象，就会将”1”这个对象添加到常量池里面。如果常量池里面已经有”1”这个对象了，则返回<strong> 常量池里面的对象 </strong> 。<br>  JDK1.7里面，如果常量池里面有”1”这个对象，做法跟1.6时一样，返回<strong> 常量池里面的对象 </strong> ，但是，如果常量池里面没有该值的对象，则添加的是<strong> 对s1在堆中的对象的引用 </strong> （说得有点绕口，说白了就是添加在堆中的对象）。<br>  我们看下代码就知道了<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;1&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s1 == s2); // false</span><br><span class="line"></span><br><span class="line">String s3 = &quot;1&quot;;</span><br><span class="line">System.out.println(s2 == s3); // true</span><br></pre></td></tr></table></figure></p>
<p>  执行s1.intern返回的是常量池里面的对象，因为上一句代码已经创建了两个对象，一个在堆里面，一个在常量池里面。所以intern方法会发现常量池里面已经有”1”这个对象了，则返回该对象。s3也是常量池里面的”1”对象，所以一个输出false，一个输出true.</p>
<h2 id="继续分析"><a href="#继续分析" class="headerlink" title="继续分析"></a>继续分析</h2><p>  我们前面说到intern方法只是检查常量池里面有没有该值，有则返回（返回的是常量池里面的对象），没有则添加（JDK1.6和1.7的添加规则不同）。接下来String s2=”1”；因为s2是字面量，也就是显示声明，而且常量池里面已经有”1”这个对象了。所以答案就很明显了，s1是在堆里面的”1”对象，s2是在字符串常量池里面的”1”对象，所以两者是不会相等的，结果为false。</p>
<h2 id="继续分析第二段代码"><a href="#继续分析第二段代码" class="headerlink" title="继续分析第二段代码"></a>继续分析第二段代码</h2><p>  String s3 = new String(“2”) + new String(“2”);这里虽然也是创建了两个对象，一个是”22”的堆对象，一个是”2”的常量池对象，注意：没有”22”常量池对象。<br>  接下来调用intern方法，因为字符串常量池还没有”22”这个对象，所以重点来了，如果是JDK1.7，添加的是<strong> 堆里面”22”这个对象的引用（说白了就是堆里面”22”这个对象）</strong> ，所以常量池里面的”22”这个对象会指向堆里面”22”这个对象。所以下一句代码String s4=”22”，貌似是常量池里面的”22”对象，但是因为此时常量池的”22”对象已经指向了堆里面的”22”对象，所以说s4也是堆里面的对象。所以输出结果为true。<br>  但是如果是JDK1.6，在调用intern方法的时候，因为常量池的”22”这个对象还不存在，所以就添加了”22”这个常量池对象，注意：<strong> 是常量池对象 </strong> ，所以下一句的String s4=”22”就是常量池对象了，结果就输出了false。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>说了那么多，其实就一句——常量池对象跟堆里面的对象时不一样的（只是简单理解，不要当真）<br>贴出总代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.stringpool;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * 第一条代码一运行，会创建两个对象。</span><br><span class="line">         * 一个对象是常量池 &quot;1&quot;的对象，存储在字符串常量池中</span><br><span class="line">         * 另一个对象是 String 对象s1</span><br><span class="line">         * 这里s1因为是new出来的，所以s1是堆里面的String对象</span><br><span class="line">         */</span><br><span class="line">        String s1 = new String(&quot;1&quot;);</span><br><span class="line">        /**</span><br><span class="line">         * 调用intern方法，如果&quot;1&quot;不在字符串常量池中，则将s1对象的引用（内存中的地址）添加到字符串常量池中</span><br><span class="line">         * JDK1.7以上就是添加对象的引用，但是1.7以下是直接将&quot;1&quot;添加到常量池</span><br><span class="line">         * 但是如果存在这个&quot;1&quot;值的对象，则返回该对象</span><br><span class="line">         * 返回的常量池里面的对象</span><br><span class="line">         */</span><br><span class="line">        String s5 = s1.intern();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 因为s5是返回常量池里面的&quot;1&quot;对象</span><br><span class="line">         * s1是堆里面的对象</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s1 == s5);  // false</span><br><span class="line">        /**</span><br><span class="line">         * 第三条代码运行时，因为上面第一条代码已经将&quot;1&quot;放进了字符串常量池了</span><br><span class="line">         * 所以s2是字符创常量池里面的&quot;1&quot;对象</span><br><span class="line">         */</span><br><span class="line">        String s2 = &quot;1&quot;;</span><br><span class="line">        /**</span><br><span class="line">         * 因为s1是堆里面String对象，s2是字符串常量池&quot;1&quot;的对象，所以为false</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s1==s2);   // false</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 因为s5是返回常量池里面的&quot;1&quot;对象</span><br><span class="line">         * s2也是常量池里面&quot;1&quot;的对象</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s5 == s2); // true</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 这里的s3显然是&quot;22&quot;，但是，&quot;22&quot;还没有进入字符串常量</span><br><span class="line">         * 也就是说，目前字符串常量里面只有&quot;2&quot;这个对象</span><br><span class="line">         * 但是，堆中有&quot;22&quot;这个对象</span><br><span class="line">         * s3就是指向&quot;22&quot;这个堆中的对象的引用</span><br><span class="line">         */</span><br><span class="line">        String  s3 = new String(&quot;2&quot;) + new String(&quot;2&quot;);</span><br><span class="line">        /**</span><br><span class="line">         * 因为&quot;22&quot;还没有进入字符串常量，所以把s3这个对象对应的在堆中&quot;22&quot;这个对象的引用推入字符串常量池</span><br><span class="line">         * 也就是说字符串常量池的&quot;22&quot;会指向堆里面&quot;22&quot;这个对象</span><br><span class="line">         * 如果值已经存在，则返回常量池里面值&quot;22&quot;的对象</span><br><span class="line">         */</span><br><span class="line">        String s6 = s3.intern();</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 因为s6和s3都是堆里面&quot;22&quot;这个对象的引用，所以为true</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s6 == s3);  // true</span><br><span class="line">        /**</span><br><span class="line">         * 因为上面的intern方法已经将&quot;22&quot;这个对象的引用放进字符创常量池</span><br><span class="line">         * 所以s4指向的堆里面&quot;22&quot;这个对象</span><br><span class="line">         */</span><br><span class="line">        String s4 = &quot;22&quot;;</span><br><span class="line">        /**</span><br><span class="line">         * 因为s4和s3引用的都是堆里面的对象，所以为true</span><br><span class="line">         */</span><br><span class="line">        System.out.println(s3 == s4);  // true</span><br><span class="line"></span><br><span class="line">        System.out.println(s6 == s4);  // true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/24/git学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/24/git学习/" itemprop="url">git学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-24T20:29:20+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h1><p>git init 就是把当前文件夹初始化为git仓库，这个文件夹就会被git所托管，文件夹里面的文件发生的所有改变都会被git所发现，而且该文件夹下就会多了一个.git的目录。<br>我们创建Git版本库时，Git自动为我们创建了唯一一个master分支</p>
<h1 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h1><p>git add就是告诉Git，把文件添加到仓库（只是添加到暂存区）。即使有个文件已经在当前文件夹，但是没有使用git add 文件名 命令，该文件也还是不存在git仓库<br>可以使用git add . 一下子添加当前目录下的所有文件</p>
<h1 id="git-commit-m"><a href="#git-commit-m" class="headerlink" title="git commit -m"></a>git commit -m</h1><p>git commit告诉Git，把文件提交到仓库先将文件添加给Git托管，只有调用commit才算是正在的添加到仓库中。git commit后面要加上 -m参数，-m 参数代表本次提交的说明，最好输入的是有意义的内容，以便以后可以在历史中方便找到改动的记录</p>
<h1 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h1><p>git status可以查看当前文件夹下有哪些文件被修改或者哪些文件没有被Git锁管理</p>
<h1 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h1><p>git diff 可以查看当前目录下的文件跟上次提交的文件具体做了哪些修改</p>
<h1 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h1><p>git log 列出了我们往期提交的所有历史记录。如果感觉输出的内容太多，可以加上–pretty=oneline命令</p>
<h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>如果我们提交过多个版本，但是如果我们想回退到上一个版本，可以使用git reset命令<br>回退到上一个版本 git reset –hard HEAD^<br>回退到上上一个版本 git reset –hard HEAD^^<br>回退到上100个版本 git reset –hard HEAD~100<br>但是回退版本最好使用版本号，版本号可是使用git log查看，每次提交都会生成一个版本号，版本号不用全写，只需写前面几位就可以，git会自动识别。</p>
<p>深入进去了解的话，我们每次提交，git里面会有一条链表记录，而且会有指针指向当前版本<br><img src="/2019/02/24/git学习/20190224085606485.png" alt=""><br>当版本回退时，比如回退到上一个版本，只需修改指针即可<br><img src="/2019/02/24/git学习/20190224085649620.png" alt=""></p>
<ul>
<li>图来自廖雪峰老师讲的Git课程<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000</a></li>
</ul>
<p>一张图解释add、commit、跟HEAD之间的关系<br><img src="/2019/02/24/git学习/20190224085857433.png" alt=""></p>
<p>此外，还可以使用git checkout – file 直接丢弃工作区的修改</p>
<h1 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h1><p>git rm用于删除文件，这里的删除只是从版本库里面删除</p>
<h1 id="添加项目到GitHub"><a href="#添加项目到GitHub" class="headerlink" title="添加项目到GitHub"></a>添加项目到GitHub</h1><p>要将项目提交到GitHub，首先需要在GitHub上建一个仓库，然后复制仓库的地址，在本地将仓库clone下来，然后把你Java项目或者其他项目放进你从GitHub上clone下来的文件夹，接下来就是用git命令了<br>命令<br>1、使用 git status 查看文件夹下有哪些没有被git所管理</p>
<p>2、 git add . 将当前文件夹下的所有文件托管给git 的仓库</p>
<p>3、 git commit -m “提交项目”  告诉git 将项目提交到仓库， -m 后面是说明，内容随意，只是最好是有意义的说明，以便后面可以从历史上看到变动的记录</p>
<p>4、git push -u origin master  最后将当前的master分支推送到远程仓库，也就是将当前被git管理的所有东西添加到远程仓库</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/23/使用redis的分布式锁实现一个简单的秒杀系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/23/使用redis的分布式锁实现一个简单的秒杀系统/" itemprop="url">使用redis的分布式锁实现一个简单的秒杀系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-23T16:03:51+08:00">
                2019-02-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/实战/" itemprop="url" rel="index">
                    <span itemprop="name">实战</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>实现秒杀系统时，为了控制并发造成商品数量的不一致，我们可能会在程序中使用锁，比如一般会用synchronized关键字或者ReentrantLock的Lock锁来加锁，但是这种加锁的最细粒子程度只能到代码段，按照我们的想法，当发生对同一个商品（比如id）执行操作时，才需要加锁；但是如果此时进来两个不同的商品（比如id为100和200），我们可以不用加锁，因为两个不同的商品互不干扰，就算不加锁也不会出现并发问题。而我们如果使用synchronized或者Lock实现加锁时，当两个并发访问两个不同的商品时，还是会对我们的代码段加锁。<br>这时，我们可以使用redis的setnx（set if not exists)来实现加锁的功能，setnx（key, value)就是如果key不存在redis，就运行设置（key，value）值。如果key值已经存在，就不允许操作。我们可以利用这个特性，在程序对商品进行操作时，可以向redis进行setnx，key值可以为商品的id比如gId:10092，value值随意。如果redis成功设置了gId:10092则证明目前除了当前操作还没有人对商品进行修改，当我们完成了对商品的操作完，记得一定要<strong> 把key值删除掉（del key) </strong> 。 如果redis设置gId:10092失败了，则说明当前有人正在修改商品的属性，我们可以先放弃操作，休息一小段时间后再请求。这样就差不多是占“茅坑”，茅坑有很多个，当你想要蹲的茅坑已经被别人占时，你只好先放弃然后稍后再尝试。<br>可能有人会问，为什么要绕这么大的弯子去请求redis服务器再操作了呢？主要有两个原因：第一、上面已经说了，如果用Synchronized或者Lock锁，就算是不同的商品，都会对核心代码段产生竞争。第二、Redis足够快，它是纯内存操作的，速度很快，就算是发送请求访问redis，延迟可以忽略不计。</p>
<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>Maven，Spring环境，SpringAOP环境，Jedis包，junti测试包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.3.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.8.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="秒杀的逻辑"><a href="#秒杀的逻辑" class="headerlink" title="秒杀的逻辑"></a>秒杀的逻辑</h3><p>假设我们就只有一个服务——秒杀商品，我们先定义一个接口，然后写一个实现类，接口里面只有一个秒杀方法<br>秒杀接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package workspace;</span><br><span class="line">public interface SecKill &#123;</span><br><span class="line">    public void seckill(String userId, Long gId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>秒杀实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package workspace;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">@Service</span><br><span class="line">public class SecKillImpl implements SecKill &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 模拟数据库</span><br><span class="line">     */</span><br><span class="line">    static Map&lt;Long, Long&gt; inventory ;</span><br><span class="line">    static &#123;</span><br><span class="line">        inventory = new HashMap&lt;&gt;();</span><br><span class="line">        // 插入两条数据</span><br><span class="line">        inventory.put(10001L, 1000L);</span><br><span class="line">        inventory.put(10002L, 1000L);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void seckill(String userId, Long gId) &#123;</span><br><span class="line">        if (null!=userId)&#123;</span><br><span class="line">            reduceInventory(gId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 库存减一</span><br><span class="line">     * @param gId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public Long reduceInventory(Long gId)&#123;</span><br><span class="line">        inventory.put(gId, inventory.get(gId)-1);</span><br><span class="line">        return  inventory.get(gId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们用HashMap模拟数据库，数据里面有两条数据，库存都是1000，秒杀的逻辑就是让库存减一</p>
<h3 id="AOP切面实现加锁解锁"><a href="#AOP切面实现加锁解锁" class="headerlink" title="AOP切面实现加锁解锁"></a>AOP切面实现加锁解锁</h3><p>接下来，我用AOP对seckill方法进行增强，在不改变seckill方法的前提下，利用AOP的环绕通知对seckill进行加锁和解锁，所以需要配置AOP环境<br>配置切面切点和方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package config;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Around;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.beans.factory.BeanFactory;</span><br><span class="line">import org.springframework.beans.factory.BeanFactoryAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import workspace.JedisLock;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class AOPConfig implements BeanFactoryAware &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 客户端获取锁失败后轮询获取锁的时间30秒</span><br><span class="line">     */</span><br><span class="line">    final static Long TIME_OUT = 90L;</span><br><span class="line">    /**</span><br><span class="line">     * Redis中键的过期时间10秒</span><br><span class="line">     */</span><br><span class="line">    final static int EXPIRE = 10;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 记录失败操作的次数</span><br><span class="line">     */</span><br><span class="line">    public static Long ERROR_COUNT = 0L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 执行秒杀方法时(载点)</span><br><span class="line">     */</span><br><span class="line">    @Pointcut(&quot;execution(* workspace.SecKillImpl.seckill(..))&quot;)</span><br><span class="line">    public void pointCut()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Around(&quot;pointCut()&quot;)</span><br><span class="line">    public boolean around(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        Object[] objects = pjp.getArgs();</span><br><span class="line">        Long gId = (Long) objects[1];</span><br><span class="line">        JedisLock lock = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+&quot; before executing--&quot;);</span><br><span class="line">            lock = createJedisLock();</span><br><span class="line">            if (lock.lock(gId,TIME_OUT, EXPIRE)) &#123;</span><br><span class="line">                pjp.proceed();</span><br><span class="line">                System.out.println(&quot;--after executing--&quot;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+&quot;  操作失败--&quot;);</span><br><span class="line">                ERROR_COUNT++;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            lock.unlock(gId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">        this.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanFactory beanFactory;</span><br><span class="line">    public JedisLock createJedisLock()&#123;</span><br><span class="line">        return this.beanFactory.getBean(JedisLock.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明：</p>
<ul>
<li>1、使用around环绕通知，是为了在执行seckill秒杀方法前对其进行加锁，在方法执行完成后进行解锁。如果获取不到锁，就不能执行seckill秒杀方法</li>
<li>2、实现BeanFactoryAware接口的原因是，为了获取原型的JedisLock，JedisLock是操作Jedis的封装，每个JedisLock代表一条Jedis连接，操作完需要关闭Jedis。而且JedisLock需要注明是prototype原型对象</li>
<li>3、必须设置KEY的过期时间，也就是加锁在redis的有效时间，这必须设置，防止因为突发原因比如服务器忽然宕机忘记解锁导致其他客户端获取不到锁</li>
</ul>
<h3 id="JedisLock实现加解锁"><a href="#JedisLock实现加解锁" class="headerlink" title="JedisLock实现加解锁"></a>JedisLock实现加解锁</h3><p>接下来说下JedisLock的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package workspace;</span><br><span class="line"></span><br><span class="line">import config.JedisFactory;</span><br><span class="line">import org.springframework.beans.factory.InitializingBean;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Scope;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class JedisLock implements InitializingBean &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    JedisFactory jedisFactory;</span><br><span class="line">    </span><br><span class="line">    Jedis jedis;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 该标志用于判断是否需要删除锁</span><br><span class="line">     */</span><br><span class="line">    boolean flag = false;</span><br><span class="line"></span><br><span class="line">    public boolean isFlag() &#123;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setFlag(boolean flag) &#123;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        // 每个Jedis锁对应一个Jedis连接</span><br><span class="line">        // 只有最后调用unlock，才释放Jedis连接</span><br><span class="line">        this.jedis = jedisFactory.getJedis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean lock(Long gId, long timeout, int expire) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Long startTime = System.currentTimeMillis() / 1000;</span><br><span class="line">            // 在限定时间内有限循环轮询</span><br><span class="line">            while (System.currentTimeMillis() / 1000 - startTime &lt; timeout) &#123;</span><br><span class="line">                // 如果获取锁成功</span><br><span class="line">                Long result = 0L;</span><br><span class="line">                try &#123;</span><br><span class="line">                    // 调用redis的setnx</span><br><span class="line">                    result = jedis.setnx(gId.toString(), &quot;1&quot;);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (result == 1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getId() + &quot;获取&quot;+ gId +&quot;锁成功&quot;);</span><br><span class="line">                    // 设置过期时间</span><br><span class="line">                    jedis.expire(gId + &quot;&quot;, expire);</span><br><span class="line">                    this.flag = true;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果获取不到锁</span><br><span class="line">                System.out.println(Thread.currentThread().getId() + &quot;出现锁等待&quot;);</span><br><span class="line">                // 短暂休眠，尽可能的避免活锁</span><br><span class="line">                Thread.sleep(200);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getId()+ &quot;获取锁&quot;+gId+&quot;错误&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock(Long gId) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (this.flag)&#123;</span><br><span class="line">                // 直接删除</span><br><span class="line">                jedis.del(gId + &quot;&quot;);</span><br><span class="line">                System.out.println(Thread.currentThread().getId()+ &quot;删除&quot; + gId +&quot;锁成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            if (jedis.isConnected()) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是通过JedisFactory获取Jedis连接，JedisFactory也是自己实现，等下会有说明。这里需要特别注意两点</p>
<ul>
<li>1、JedisLock必须是原型模式，因为并发操作时，每个操作代表一个用户，每个用户需要对应一条Redis连接，避免多个用户公用一条Jedis连接，防止其中一个用户关闭了连接导致另一个不能用</li>
<li>2、实现InitializingBean方法，每生成一个Bean就初始化一条Jedis连接</li>
</ul>
<h3 id="JedisFactory创建Jedis连接"><a href="#JedisFactory创建Jedis连接" class="headerlink" title="JedisFactory创建Jedis连接"></a>JedisFactory创建Jedis连接</h3><p>跟数据库连接池一样，这里需要使用一JedisPool创建Jedis连接池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package config;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.pool2.impl.GenericObjectPoolConfig;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class JedisFactory &#123;</span><br><span class="line">    JedisPool jedisPool;</span><br><span class="line">    </span><br><span class="line">    public JedisFactory() &#123;</span><br><span class="line">        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();</span><br><span class="line">        poolConfig.setMaxIdle(100);</span><br><span class="line">        poolConfig.setMinIdle(1);</span><br><span class="line">        poolConfig.setMaxTotal(1000);</span><br><span class="line">        poolConfig.setMaxWaitMillis(5000);</span><br><span class="line">        this.jedisPool = new JedisPool(poolConfig, &quot;127.0.0.1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Jedis getJedis() &#123;</span><br><span class="line">        Jedis jedis = jedisPool().getResource();</span><br><span class="line">        return jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JedisPool jedisPool() &#123;</span><br><span class="line">        if (this.jedisPool != null) &#123;</span><br><span class="line">            return this.jedisPool;</span><br><span class="line">        &#125;</span><br><span class="line">        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();</span><br><span class="line">        poolConfig.setMaxIdle(100);</span><br><span class="line">        poolConfig.setMinIdle(1);</span><br><span class="line">        poolConfig.setMaxTotal(1000);</span><br><span class="line">        JedisPool jedisPool = new JedisPool(poolConfig, &quot;127.0.0.1&quot;);</span><br><span class="line">        this.jedisPool = jedisPool;</span><br><span class="line">        return this.jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要是创建一个JedisPool的连接池，设置连接池大小和每条连接的最长连接时间，getJedis方法就是从JedisPool里面获取一条Jedis连接<br>逻辑大概就是这样，接下来就来测试一下</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>因为是使用Spring，所以需要配置Spring环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package config;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;config&quot;, &quot;workspace&quot;&#125;)</span><br><span class="line">@EnableAspectJAutoProxy</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注解扫描指定的包，开启AOP功能</p>
<p>开始测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">package workspace;</span><br><span class="line">import config.AOPConfig;</span><br><span class="line">import config.AppConfig;</span><br><span class="line">import config.JedisFactory;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import java.util.concurrent.CountDownLatch;</span><br><span class="line">public class App </span><br><span class="line">&#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void testSecKill()&#123;</span><br><span class="line"></span><br><span class="line">        final ApplicationContext ac = new AnnotationConfigApplicationContext();</span><br><span class="line">        ((AnnotationConfigApplicationContext) ac).register(AppConfig.class);</span><br><span class="line">        ((AnnotationConfigApplicationContext) ac).refresh();</span><br><span class="line">        System.out.println(&quot;获取SecKill  Bean&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int threadCount = 100;</span><br><span class="line">        int splitPoint = threadCount / 2;</span><br><span class="line">         final CountDownLatch endCount = new CountDownLatch(threadCount);</span><br><span class="line">         final CountDownLatch beginCount = new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">        Thread[] threads = new Thread[threadCount];</span><br><span class="line">        //起500个线程，秒杀第一个商品</span><br><span class="line">        for(int i= 0;i &lt; splitPoint;i++)&#123;</span><br><span class="line">            threads[i] = new Thread(new  Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //等待在一个信号量上，挂起</span><br><span class="line">                        beginCount.await();</span><br><span class="line">                        SecKill secKill = ac.getBean(SecKill.class);</span><br><span class="line">                        // 该方法会被AOP代理</span><br><span class="line">                        secKill.seckill(&quot;1&quot;, 10001L);</span><br><span class="line"></span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;finally &#123;</span><br><span class="line">                        endCount.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //再起500个线程，秒杀第二件商品</span><br><span class="line">        for(int i= splitPoint;i &lt; threadCount;i++)&#123;</span><br><span class="line">            threads[i] = new Thread(new  Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        //等待在一个信号量上，挂起</span><br><span class="line">                        beginCount.await();</span><br><span class="line">                        SecKill secKill = ac.getBean(SecKill.class);</span><br><span class="line">                        // 该方法会被AOP代理</span><br><span class="line">                        secKill.seckill(&quot;1&quot;, 10002L);</span><br><span class="line"></span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;finally &#123;</span><br><span class="line">                        endCount.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long startTime = System.currentTimeMillis()/1000;</span><br><span class="line">        //主线程释放开始信号量，并等待结束信号量，这样做保证1000个线程做到完全同时执行，保证测试的正确性</span><br><span class="line">        // 也就说开始让线程工作</span><br><span class="line">        beginCount.countDown();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            //主线程等待结束信号量，也就是等待其他线程的工作全部做完</span><br><span class="line">            endCount.await();</span><br><span class="line">            //观察秒杀结果是否正确</span><br><span class="line">            System.out.println(SecKillImpl.inventory.get(10001L));</span><br><span class="line">            System.out.println(SecKillImpl.inventory.get(10002L));</span><br><span class="line">            System.out.println(&quot;error count&quot; + AOPConfig.ERROR_COUNT);</span><br><span class="line">            System.out.println(&quot;total cost &quot; + (System.currentTimeMillis()/1000 - startTime));</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简单的说明一下</p>
<ul>
<li>1、先让Spring跑起来，把我们写的AppConfig注册进去</li>
<li>2、声明CountDownLatch（阀），是为了最后数据的正确性校验，等所有线程跑完了再输出最后库存里的剩余数量是否正确</li>
<li>3、我们开启100个线程测试，50个操作10001商品，50个操作10002商品，如果操作正确的话，最后两个商品的库存应该都是950</li>
</ul>
<p>最后结果：<br><img src="/2019/02/23/使用redis的分布式锁实现一个简单的秒杀系统/20190224021815748.png" alt=""><br>库存跟我们预想的一致</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>当线程很多的时候，比如有1000个线程，为了顺利通过测试，需要延长每个操作循环等待锁的时间。我使用1000个线程并发时，需要延长时间至60秒（不知道是不是我电脑的问题…）<br>或者你可以使用另一个Redis的连接池——lettuce，我测试过了，lettuce比以往的JedisPool更快，1000个并发使用JedisPool需要60秒，而使用lettuce则需要不到40秒</p>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/SouthLight-Lin/redis-in-seckill" target="_blank" rel="noopener">https://github.com/SouthLight-Lin/redis-in-seckill</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/类的加载时候的初始化顺序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/21/类的加载时候的初始化顺序/" itemprop="url">类的加载时候的初始化顺序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T21:23:21+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在牛客网上刷题时，一直做错类的加载时初始化这些题，不懂静态方法什么时候执行，初始化代码块什么时候执行，构造方法什么执行，今天在这里谨记，下次要是再做错，我….</p>
<h1 id="题型一"><a href="#题型一" class="headerlink" title="题型一"></a>题型一</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;静态代码块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public A()&#123;</span><br><span class="line">		System.out.println(&quot;构造方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;初始化块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;A的静态main方法&quot;);</span><br><span class="line">		new A();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出执行顺序，执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">A的静态main方法</span><br><span class="line">初始化块</span><br><span class="line">构造方法</span><br></pre></td></tr></table></figure></p>
<h1 id="题型二"><a href="#题型二" class="headerlink" title="题型二"></a>题型二</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		System.out.println(&quot;父类静态代码块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public A()&#123;</span><br><span class="line">		System.out.println(&quot;父类构造方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;父类初始化块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class B extends A&#123;</span><br><span class="line">	static&#123;</span><br><span class="line">		System.out.println(&quot;子类静态代码块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public B()&#123;</span><br><span class="line">		System.out.println(&quot;子类构造方法&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;子类初始化块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		new B();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出执行过程，结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">父类静态代码块</span><br><span class="line">子类静态代码块</span><br><span class="line">父类初始化块</span><br><span class="line">父类构造方法</span><br><span class="line">子类初始化块</span><br><span class="line">子类构造方法</span><br></pre></td></tr></table></figure></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于题型一，谨记：静态的修饰变量（static）总是先于构造方法和普通代码块执行。static中又有static静态变量，static静态初始化块，static静态方法，里面静态方法是最后执行的，所以题型一中先执行静态代码块再执行静态方法。（原因：用static修饰的地方在编译器编译时就已经开始执行）<br>对于题型二，谨记：<strong> 先执行父类的静态代码块，然后执行子类的静态代码块 </strong> ，因为在编译时就开始执行。接着调用main方法，里面开始new B，所以 <strong> 执行父类的普通初始化块-&gt;父类的构造方法快-&gt;最后执行子类的普通初始化块-&gt;子类的构造块 </strong> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/19/Spring-Bean的生命周期/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/19/Spring-Bean的生命周期/" itemprop="url">Spring-Bean的生命周期</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-19T23:45:22+08:00">
                2019-02-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们的对象在Spring中是用Bean来描述的，创建一个Bean的过程是怎么样的，创建的Bean最后存放在哪里？这篇博客给你答案</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>我们需要有一个Spring的运行环境，先声明一个UserDAO的Bean，再从容器中获取<br>UserDAO.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.dao;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class UserDAO  &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Spring的配置类AppConfig.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.lnw&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动测试<br>Boot.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.test;</span><br><span class="line">import com.lnw.config.AppConfig;</span><br><span class="line">import com.lnw.dao.UserDAO;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line">public class Boot &#123;</span><br><span class="line">	private int a = 1;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext();</span><br><span class="line">		// 把我们的AppConfig类注册到BDM中去</span><br><span class="line">		ac.register(AppConfig.class);</span><br><span class="line">		// refresh是整个Spring中最核心的代码</span><br><span class="line">		ac.refresh();</span><br><span class="line">		System.out.println(ac.getBean(UserDAO.class).hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来就可从容器中获取UserDAO的Bean并输出hashCode</p>
<h1 id="Bean创建的前身BeanDefinition"><a href="#Bean创建的前身BeanDefinition" class="headerlink" title="Bean创建的前身BeanDefinition"></a>Bean创建的前身BeanDefinition</h1><p>上面的三段代码，AppConfig配置类中加了@ComponentScan注解，里面指定的扫描的包路径，所以我们的UserDAO类就会被扫描进去。但是扫描出来的类，放进Spring就会被定义成BeanDefinition<br>什么是BeanDefinition？<br>简单的说就是创建Bean的原料。如果把Bean比作一道菜的话，那么BeanDefinition就是做这道菜的所有原料。也就是说，BeanDefinition定义了创建Bean的所有东西，包括类型，参数，作用域等等（下面把BeanDefinition简称为BD）<br>我们可以看看UserDAO的BeanDefinition是什么内容<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220023804063.png" alt=""></p>
<p>接下来我们直接看代码<br>org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan会扫描我们指定包下所有加了注解的类，然后把类封装成BeanDefinition注册到BeanDefinitionMap中（BeanDefinitionMap是一个存放BeanDefinition的Map，它在BeanFactory中，以下简称BDM）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">		Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);</span><br><span class="line">        // 声明一个集合来存储BeanDefinition</span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;&gt;();</span><br><span class="line">		for (String basePackage : basePackages) &#123;</span><br><span class="line">			// 扫描basePackage路径下的java文件</span><br><span class="line">			// 并把它转成BeanDefinition</span><br><span class="line">			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">			for (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">				// 解析Scope属性</span><br><span class="line">				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">				candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);</span><br><span class="line">				if (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">					// 如果这个类时AbstractBeanDefinition的子类</span><br><span class="line">					// 则为它设置默认属性 比如lazy，init destory</span><br><span class="line">					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				if (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">					// 检查并处理常用的注解</span><br><span class="line">					// 这里的处理是把常用的注解的值设置到AnnotationBeanDefinition当中</span><br><span class="line">					// 也就是加了注解的类</span><br><span class="line">					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">				&#125;</span><br><span class="line">				if (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">					definitionHolder =</span><br><span class="line">							AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">					beanDefinitions.add(definitionHolder);</span><br><span class="line">					// 扫描完以后，注册BeanDefinition</span><br><span class="line">					registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return beanDefinitions;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看下registerBeanDefinition方法，里面只是简单的使用一个BDR（注册BD的工具）<br>org.springframework.context.annotation.ClassPathBeanDefinitionScanner#registerBeanDefinition<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void registerBeanDefinition(</span><br><span class="line">			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span><br><span class="line">			throws BeanDefinitionStoreException &#123;</span><br><span class="line">		// Register bean definition under primary name.</span><br><span class="line">		String beanName = definitionHolder.getBeanName();</span><br><span class="line">		// 将BD注册</span><br><span class="line">		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line">		// Register aliases for bean name, if any.</span><br><span class="line">		String[] aliases = definitionHolder.getAliases();</span><br><span class="line">		if (aliases != null) &#123;</span><br><span class="line">			for (String alias : aliases) &#123;</span><br><span class="line">				registry.registerAlias(beanName, alias);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个BD注册工具会将BD注册到BDM中，目前这个BDM存储在DefaultListableBeanFactory中，这个类中有一个属性，专门用来存储BD的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 这个Map很重要很重要</span><br><span class="line">	 * Bean的定义的所有数据都存放在这里，也就是说这个Map中存放生产Bean的原料</span><br><span class="line">	 * @author SouthLight-Lin</span><br><span class="line">	 */</span><br><span class="line">	/** Map of bean definition objects, keyed by bean name. */</span><br><span class="line">	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);</span><br></pre></td></tr></table></figure></p>
<p>org.springframework.beans.factory.support.DefaultListableBeanFactory#registerBeanDefinition方法中的代码很长，但是关键的代码就是把BD添加put进去Map中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.beanDefinitionMap.put(beanName, beanDefinition);</span><br></pre></td></tr></table></figure></p>
<p>接下来，当Spring需要创建Bean时，就从这个BDM中获取BD原料来创建Bean</p>
<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><p>上面写了那么多，是为了解释BeanDefinition的作用，接下来完整的还原当我们调用getBean时，Bean的生命周期是怎么样的</p>
<h2 id="1、Spring会将扫描出来的类封装成BeanDefinition，为后面的Bean的创建做准备"><a href="#1、Spring会将扫描出来的类封装成BeanDefinition，为后面的Bean的创建做准备" class="headerlink" title="1、Spring会将扫描出来的类封装成BeanDefinition，为后面的Bean的创建做准备"></a>1、Spring会将扫描出来的类封装成BeanDefinition，为后面的Bean的创建做准备</h2><p>这是创建Bean的第一步，上面已经讲过</p>
<h2 id="2、先简单的实例化一个对象"><a href="#2、先简单的实例化一个对象" class="headerlink" title="2、先简单的实例化一个对象"></a>2、先简单的实例化一个对象</h2><p>Spring会先从容器中getBean，如果这个Bean不存在，就尝试创建一个Bean出来<br>Spring会从BeanDefinition中通过反射先new出一个对象，然后再对这个对象进行加工使它成为Bean<br>在org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (instanceWrapper == null) &#123;</span><br><span class="line">			// 创建一个对象实例（此时还不是Bean，只是一个普通的对象）</span><br><span class="line">			instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3、Spring根据Bean的定义填充所有属性，比如它的属性里面有List，String参数，或者有依赖对象，就进行依赖注入"><a href="#3、Spring根据Bean的定义填充所有属性，比如它的属性里面有List，String参数，或者有依赖对象，就进行依赖注入" class="headerlink" title="3、Spring根据Bean的定义填充所有属性，比如它的属性里面有List，String参数，或者有依赖对象，就进行依赖注入"></a>3、Spring根据Bean的定义填充所有属性，比如它的属性里面有List，String参数，或者有依赖对象，就进行依赖注入</h2><p>在org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean方法的populateBean方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Initialize the bean instance.</span><br><span class="line">		// 将对象复制给exposedObject，然后下面就对这个对象进行初始化，使它成为Bean</span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		try &#123;</span><br><span class="line">			// Bean属性的初始化，包括依赖注入</span><br><span class="line">			populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">			// 如果实现了InitializingBean，就执行接口里的afterProperty方法进行初始化</span><br><span class="line">			// 还执行了Aware接口</span><br><span class="line">			// 还执行了BeanPostProcessor的Bean处理器</span><br><span class="line">			exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>exposedObject = initializeBean(beanName, exposedObject, mbd);这段代码是下面其他步骤的代码，下面再说</p>
<p>我们可以写一个@Autowired方法注入一个Pear对象来试一下，是不是在populateBean方法里面进行依赖注入<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220020718080.png" alt=""><br>结果<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220020810440.png" alt=""><br>populateBean就是对Bean的参数进行设置，包括依赖注入</p>
<h2 id="4、Bean初始化工作的开始，首先进行Aware接口的执行"><a href="#4、Bean初始化工作的开始，首先进行Aware接口的执行" class="headerlink" title="4、Bean初始化工作的开始，首先进行Aware接口的执行"></a>4、Bean初始化工作的开始，首先进行Aware接口的执行</h2><p>xxxAware接口是为了使Bean可以获取Spring内部的资源而出现的，比如你可以通过让Bean实现BeanNameAware将Bean容器中的名称设置给Bean自己知道，或者实现BeanFactoryAware将整个容器设置给Bean<br>比如上面的UserDAO实现了BeanNameAware接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.dao;</span><br><span class="line">import org.springframework.beans.factory.BeanNameAware;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class UserDAO implements BeanNameAware&#123;</span><br><span class="line">	public String beanName;</span><br><span class="line">	@Override</span><br><span class="line">	public void setBeanName(String name) &#123;</span><br><span class="line">		beanName = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以将beanName传进来给Bean使用<br>在第三步的代码中，initializaBean就包括执行Aware接口<br>initializaBean方法里面包含Bean的生命周期的四个步骤，分别是Aware接口的执行，BeanPostProcessor的前置处理，初始化方法的执行，BeanPostProcessor的后置处理<br>先贴上代码，再具体说明<br>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean(java.lang.String, java.lang.Object, org.springframework.beans.factory.support.RootBeanDefinition)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) &#123;</span><br><span class="line">		if (System.getSecurityManager() != null) &#123;</span><br><span class="line">			AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">				invokeAwareMethods(beanName, bean);</span><br><span class="line">				return null;</span><br><span class="line">			&#125;, getAccessControlContext());</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 如果实现了xxxAware接口，执行接口的Set方法</span><br><span class="line">			invokeAwareMethods(beanName, bean);</span><br><span class="line">		&#125;</span><br><span class="line">		Object wrappedBean = bean;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			// 执行BeanPostProcessor的前置处理</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 执行Bean的初始化方法，比如实现了InitializingBean</span><br><span class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable ex) &#123;</span><br><span class="line">			throw new BeanCreationException(</span><br><span class="line">					(mbd != null ? mbd.getResourceDescription() : null),</span><br><span class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</span><br><span class="line">			// 执行BeanPostProcess的后置处理</span><br><span class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		return wrappedBean;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5、BeanPostProcessor的前置处理"><a href="#5、BeanPostProcessor的前置处理" class="headerlink" title="5、BeanPostProcessor的前置处理"></a>5、BeanPostProcessor的前置处理</h2><p>什么是BeanPostProcessor？BeanPostProcessor就是处理Bean的一个工具，它能在创建Bean的过程之中，对Bean进行处理。只要实现了BeanPostProcessor方法，实现它的前置处理方法（postProcessBeforeInitialization）和后置处理方法（postProcessAfterInitialization），就能在所有Bean的创建过程中对Bean做一些操作<br>调用applyBeanPostProcessorsBeforeInitialization方法开始对Bean进行BeanPostProcessor的前置处理<br>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		// 循环执行所有BeanPostProcessor</span><br><span class="line">		for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">			Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			if (current == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			result = current;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过循环所有的BeanPostProcessor对Bean进行处理，Spring内置的BeanPostProcessor有<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220010050881.png" alt=""><br>这里只说明了几个BeanPostProcessor的小小的功能…其它的目前还不知道</p>
<h2 id="6、Bean的初始化方法的执行"><a href="#6、Bean的初始化方法的执行" class="headerlink" title="6、Bean的初始化方法的执行"></a>6、Bean的初始化方法的执行</h2><p>Bean的初始化方法就是Bean刚生成时执行的方法，可以实现InitializingBean来执行初始化方法<br>在invokeInitMethods方法中<br>我们让UserDAO实现InitializingBean接口，看何时调用该方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.dao;</span><br><span class="line">import org.springframework.beans.factory.InitializingBean;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">@Component</span><br><span class="line">public class UserDAO implements InitializingBean &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;executing InitializingBean&apos;s afterPropertiesSet&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在afterPropertiesSet方法打下断掉，看何时调用<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220021258539.png" alt=""><br><img src="/2019/02/19/Spring-Bean的生命周期/20190220021337110.png" alt=""></p>
<h2 id="7、BeanPostProcessor的后置处理"><a href="#7、BeanPostProcessor的后置处理" class="headerlink" title="7、BeanPostProcessor的后置处理"></a>7、BeanPostProcessor的后置处理</h2><p>同第五步差不多，当执行完初始化方法之后，就执行BeanPostProcessor的后置处理postProcessAfterInitialization，也是循环调用所有的BeanPostProcessor处理Bean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)</span><br><span class="line">			throws BeansException &#123;</span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		// 循环执行所有BeanPostProcessor</span><br><span class="line">		for (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">			Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			if (current == null) &#123;</span><br><span class="line">				return result;</span><br><span class="line">			&#125;</span><br><span class="line">			result = current;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>一张图解释4、5、6、7步骤<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220030041426.png" alt=""></p>
<h2 id="8、将创建的Bean放进Spring的IOC容器"><a href="#8、将创建的Bean放进Spring的IOC容器" class="headerlink" title="8、将创建的Bean放进Spring的IOC容器"></a>8、将创建的Bean放进Spring的IOC容器</h2><p>Spring调用getBean方法获得Bean，当获取不到时，就尝试进行创建，如果创建成功，就把Bean放进IOC容器，以便下次获取（前提是Bean的Scope为singleton，单例模式）<br>经过上面的步骤，Bean就算是创建完成了，如果Scope属性为单例模式，那么就把Bean放进IOC容器<br>看一下程序的调用链<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220015929690.png" alt=""><br>当getBean获取不到Bean时就进行创建，如果是Singleton，最后将Bean添加到IOC容器<br>添加的代码如下<br>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingleton<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected void addSingleton(String beanName, Object singletonObject) &#123;</span><br><span class="line">		synchronized (this.singletonObjects) &#123;</span><br><span class="line">			this.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">			this.singletonFactories.remove(beanName);</span><br><span class="line">			this.earlySingletonObjects.remove(beanName);</span><br><span class="line">			this.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实，我们常说的IOC容器，就是singletonObjects，它是一个ConcurrentHashMap<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220020134207.png" alt=""></p>
<h2 id="9、最后销毁Bean时，如果Bean实现了DisposableBean，它将调用destroy（）方法"><a href="#9、最后销毁Bean时，如果Bean实现了DisposableBean，它将调用destroy（）方法" class="headerlink" title="9、最后销毁Bean时，如果Bean实现了DisposableBean，它将调用destroy（）方法"></a>9、最后销毁Bean时，如果Bean实现了DisposableBean，它将调用destroy（）方法</h2><h1 id="初始化Bean方法的两种方法："><a href="#初始化Bean方法的两种方法：" class="headerlink" title="初始化Bean方法的两种方法："></a>初始化Bean方法的两种方法：</h1><pre><code>1、注解@PostConstruct
2、实现InitializingBean 接口
</code></pre><p>第一种方法比第二种方法先执行，因为@PostConstruct的实现是CommonAnnotationBeanPostProcessor，它是BeanPostProcessor的实现，是一个Bean的处理器，会先调用postBeanPostProcessorBeforeInitialization的前置方法，然后再调用InitializingBean接口的方法<br>我们可以写段代码来测试一下，UserDAO实现InitializingBean，并且写一个方法，在该方法上注解@PostContruct<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.dao;</span><br><span class="line">import org.springframework.beans.factory.InitializingBean;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import javax.annotation.PostConstruct;</span><br><span class="line">@Component</span><br><span class="line">public class UserDAO implements InitializingBean &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;executing InitializingBean&apos;s afterPropertiesSet&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@PostConstruct</span><br><span class="line">	public void  initMethod()&#123;</span><br><span class="line">		System.out.println(&quot;@PostConstruct is executing &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看运行结果<br><img src="/2019/02/19/Spring-Bean的生命周期/20190220021734930.png" alt=""></p>
<p>*注：@PreDestroy这个注解是销毁Bean时执行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/" itemprop="url">Spring-Mybatis把接口变成Bean的秘密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-16T23:48:08+08:00">
                2019-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index">
                    <span itemprop="name">Spring</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们使用Spring+Mybatis做开发时，一般都会引入spring-mybatis这个包，这个包是mybatis自己开发的，它利用Spring的扩展接口将自己很好的整合在Spring中，下面就来说一下，我们定义的mapper接口，是怎么把它变成一个实际的对象然后存储在容器中的</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>我们先来准备下环境</p>
<h2 id="配置Spring环境"><a href="#配置Spring环境" class="headerlink" title="配置Spring环境"></a>配置Spring环境</h2><p>引入Spring包，引入mybatis包，引入Spring跟Mybatis整合的包，引入数据库连接驱动的包<br><img src="/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/20190217121626695.png" alt=""></p>
<h3 id="AppConfig-java，该类只是简单的配置了Bean的扫描包"><a href="#AppConfig-java，该类只是简单的配置了Bean的扫描包" class="headerlink" title="AppConfig.java，该类只是简单的配置了Bean的扫描包"></a>AppConfig.java，该类只是简单的配置了Bean的扫描包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.config;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.demo&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MybatisConfig-java，该类配置了数据库连接池和SQLSessionFactory，以及Mapper接口的扫描"><a href="#MybatisConfig-java，该类配置了数据库连接池和SQLSessionFactory，以及Mapper接口的扫描" class="headerlink" title="MybatisConfig.java，该类配置了数据库连接池和SQLSessionFactory，以及Mapper接口的扫描"></a>MybatisConfig.java，该类配置了数据库连接池和SQLSessionFactory，以及Mapper接口的扫描</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.config;</span><br><span class="line">import org.apache.ibatis.datasource.pooled.PooledDataSource;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.jdbc.datasource.DriverManagerDataSource;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(&quot;com.demo.dao&quot;)</span><br><span class="line">public class MybatisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource()&#123;</span><br><span class="line">        System.out.println(&quot;config datasoutce------&quot;);</span><br><span class="line">        DriverManagerDataSource dataSource = new DriverManagerDataSource();</span><br><span class="line">        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/classsystem&quot;);</span><br><span class="line">        dataSource.setUsername(&quot;root&quot;);</span><br><span class="line">        dataSource.setPassword(&quot;root&quot;);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Autowired</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;</span><br><span class="line">        System.out.println(&quot;config SessionFactory-------&quot;);</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        return sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UserDao-java，写一个简单的接口，用于查询数据库"><a href="#UserDao-java，写一个简单的接口，用于查询数据库" class="headerlink" title="UserDao.java，写一个简单的接口，用于查询数据库"></a>UserDao.java，写一个简单的接口，用于查询数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.dao;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    @Select(&quot;select * from stu_info where id=1&quot;)</span><br><span class="line">    public List&lt;Map&lt;String,Object&gt;&gt; selectOne();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test-java最后写一个测试启动类"><a href="#Test-java最后写一个测试启动类" class="headerlink" title="Test.java最后写一个测试启动类"></a>Test.java最后写一个测试启动类</h3><p>Test.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.test;</span><br><span class="line"></span><br><span class="line">import com.demo.config.AppConfig;</span><br><span class="line">import com.demo.dao.UserDao;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext annotationConfigApplicationContext =</span><br><span class="line">                new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">        annotationConfigApplicationContext.start();</span><br><span class="line">        //以下是测试Mybatis的代码</span><br><span class="line">        UserDao dao = annotationConfigApplicationContext.getBean(UserDao.class);</span><br><span class="line">        System.out.println(dao.selectOne());</span><br><span class="line">        System.out.println(&quot;---over----&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来项目即可运行并输出</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>通过上面的小demo，我们可以通过UserDao的selectOne方法查询数据库，但是我有一个问题，为什么一个UserDao可以实例化？<br>我们输出从容器中得到的UserDao的类看下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserDao dao = annotationConfigApplicationContext.getBean(UserDao.class);</span><br><span class="line">System.out.println(annotationConfigApplicationContext.getBean(&quot;&amp;userDao&quot;));</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.mybatis.spring.mapper.MapperFactoryBean@6913c1fb</span><br></pre></td></tr></table></figure></p>
<p>看来，一个Mapper接口变成了一个MapperFactoryBean了<br>这里提出几个问题？<br>1、MapperFactoryBean是什么东西？<br>2、它是怎么进入容器，然后被Spring锁管理的？</p>
<h1 id="MapperFactoryBean是什么东西"><a href="#MapperFactoryBean是什么东西" class="headerlink" title="MapperFactoryBean是什么东西"></a>MapperFactoryBean是什么东西</h1><p>我们看下MapperFactoryBean的源码，发现它实现了Spring的FactoryBean</p>
<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><p>FactoryBean是Spring中特殊的Bean，它可以通过getObject方法生成指定的Bean属性。<br>当我们手动向Spring容器中注册BeanDefinition（简称BD） 时，可以设置BD为FactoryBean类型，这样在Spring中获取这个Bean时，就会使用FactoryBean的getObject创建Bean</p>
<h2 id="如何手动向Spring容器中注入BeanDefinition"><a href="#如何手动向Spring容器中注入BeanDefinition" class="headerlink" title="如何手动向Spring容器中注入BeanDefinition"></a>如何手动向Spring容器中注入BeanDefinition</h2><p>何为BeanDefinition？<br>BeanDefinition是Bean的描述，如果把Bean比作一道菜的话，那么BeanDefinition就是做这道菜的原料。在Spring中，Bean的创建是通过BeanDefinition来创建的，所有属性都包含在BeanDefinition中，比如单例模式，懒加载，类名，方法….<br>如何手动的向Spring中注册BD？<br>在Spring中，只要配置类实现了ImportBeanDefinitionRegistrar接口，就可直接向Spring中注册BD<br>org.springframework.context.annotation.ImportBeanDefinitionRegistrar<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line">import com.lnw.dao.Pear;</span><br><span class="line">import com.lnw.test.MyFactoryBean2;</span><br><span class="line">import org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line">import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line"> * 实现了该接口，就可参与Spring的Factory的建设</span><br><span class="line"> * 可以调用接口的实现方法直接添加BeanDefinition</span><br><span class="line"> */</span><br><span class="line"> @Configuration</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		BeanDefinition pear = BeanDefinitionBuilder.genericBeanDefinition(Pear.class).getBeanDefinition();</span><br><span class="line">		registry.registerBeanDefinition(&quot;pear&quot;, pear);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的话就可以自己手动的在Spring容器中添加一个Pear（梨）的Bean了</p>
<h2 id="继续刚才FactoryBean的话题"><a href="#继续刚才FactoryBean的话题" class="headerlink" title="继续刚才FactoryBean的话题"></a>继续刚才FactoryBean的话题</h2><p>如果我有两个类，Apple和Pear<br>我手动先容器中注册了Pear，我可以通过FactoryBean来改变Pear从而获取Apple<br>先编写一个类实现FactoryBean接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.test;</span><br><span class="line">import com.lnw.dao.Apple;</span><br><span class="line">import org.springframework.beans.factory.FactoryBean;</span><br><span class="line">public class MyFactoryBean2 implements FactoryBean &#123;</span><br><span class="line">	Class clazz;</span><br><span class="line">	MyFactoryBean2()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	MyFactoryBean2(Class clazz)&#123;</span><br><span class="line">		this.clazz = clazz;</span><br><span class="line">	&#125;</span><br><span class="line">	public Class getClazz() &#123;</span><br><span class="line">		return clazz;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setClazz(Class clazz) &#123;</span><br><span class="line">		this.clazz = clazz;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Object getObject() throws Exception &#123;</span><br><span class="line">		return  new Apple();</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">		return clazz;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点就是getObject方法，它返回一个Apple对象</p>
<p>然后，我们手动注册一个Pear的BD，把它的类型改为我们规定的FactoryBean类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line">import com.lnw.dao.Pear;</span><br><span class="line">import com.lnw.test.MyFactoryBean2;</span><br><span class="line">import org.springframework.beans.factory.config.BeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class="line">import org.springframework.beans.factory.support.BeanDefinitionRegistry;</span><br><span class="line">import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/**</span><br><span class="line"> * 实现了该接口，就可参与Spring的Factory的建设</span><br><span class="line"> * 可以调用接口的实现方法直接添加BeanDefinition</span><br><span class="line"> */</span><br><span class="line"> @Configuration</span><br><span class="line">public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		BeanDefinition pear = BeanDefinitionBuilder.genericBeanDefinition(Pear.class).getBeanDefinition();</span><br><span class="line">        // 将Bean的类型改为我们的FactoryBean，这样返回的就是Apple</span><br><span class="line">		((AbstractBeanDefinition) pear).setBeanClass(MyFactoryBean2.class);</span><br><span class="line">		registry.registerBeanDefinition(&quot;pear&quot;, pear);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们从容器中获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ac.getBean(&quot;pear&quot;).getClass());</span><br></pre></td></tr></table></figure></p>
<p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class com.lnw.dao.Apple</span><br></pre></td></tr></table></figure></p>
<p>这就是FactoryBean的功能和作用</p>
<h1 id="MapperScan注解"><a href="#MapperScan注解" class="headerlink" title="@MapperScan注解"></a>@MapperScan注解</h1><p>通过上面我们可以大概知道，spring-mybatis就是通过设置MapperFactoryBean解决从一个Mapper接口变成一个可实际操作的对象的过程<br>那MapperFactoryBean在哪里设置进去的呢？<br>答案就在我们的@MapperScan注解中<br>我们打开注解<br>@MapperScan<br><img src="/2019/02/16/Spring-Mybatis把接口变成Bean的秘密/20190217125931918.png" alt=""><br>发现它引入了一个类：MapperScannerRegistrar<br>MapperScannerRegistrar.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware &#123;</span><br><span class="line">  private ResourceLoader resourceLoader;</span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    AnnotationAttributes annoAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line"></span><br><span class="line">    // this check is needed in Spring 3.1</span><br><span class="line">    if (resourceLoader != null) &#123;</span><br><span class="line">      scanner.setResourceLoader(resourceLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = annoAttrs.getClass(&quot;annotationClass&quot;);</span><br><span class="line">    if (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">      scanner.setAnnotationClass(annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(&quot;markerInterface&quot;);</span><br><span class="line">    if (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">      scanner.setMarkerInterface(markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends BeanNameGenerator&gt; generatorClass = annoAttrs.getClass(&quot;nameGenerator&quot;);</span><br><span class="line">    if (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">      scanner.setBeanNameGenerator(BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line">    Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass = annoAttrs.getClass(&quot;factoryBean&quot;);</span><br><span class="line">    if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">      scanner.setMapperFactoryBean(BeanUtils.instantiateClass(mapperFactoryBeanClass));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(annoAttrs.getString(&quot;sqlSessionTemplateRef&quot;));</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(annoAttrs.getString(&quot;sqlSessionFactoryRef&quot;));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; basePackages = new ArrayList&lt;String&gt;();</span><br><span class="line">    for (String pkg : annoAttrs.getStringArray(&quot;value&quot;)) &#123;</span><br><span class="line">      if (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (String pkg : annoAttrs.getStringArray(&quot;basePackages&quot;)) &#123;</span><br><span class="line">      if (StringUtils.hasText(pkg)) &#123;</span><br><span class="line">        basePackages.add(pkg);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (Class&lt;?&gt; clazz : annoAttrs.getClassArray(&quot;basePackageClasses&quot;)) &#123;</span><br><span class="line">      basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    // 扫描包并注册BD</span><br><span class="line">    scanner.doScan(StringUtils.toStringArray(basePackages));</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void setResourceLoader(ResourceLoader resourceLoader) &#123;</span><br><span class="line">    this.resourceLoader = resourceLoader;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它实现了ImportBeanDefinitionRegistrar，代表它手动的向Spring中注册了BD<br>它里面还有一个扫描器，通过扫描器把mapper接口扫描出来，并设置为MapperFactoryBean类型我们直接看源码<br>org.mybatis.spring.mapper.ClassPathMapperScanner#doScan<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = super.doScan(basePackages);</span><br><span class="line">    if (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      logger.warn(&quot;No MyBatis mapper was found in &apos;&quot; + Arrays.toString(basePackages) + &quot;&apos; package. Please check your configuration.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 处理扫描出来的BD</span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>org.mybatis.spring.mapper.ClassPathMapperScanner#processBeanDefinitions<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    for (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating MapperFactoryBean with name &apos;&quot; + holder.getBeanName() </span><br><span class="line">          + &quot;&apos; and &apos;&quot; + definition.getBeanClassName() + &quot;&apos; mapperInterface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // the mapper interface is the original class of the bean</span><br><span class="line">      // but, the actual class of the bean is MapperFactoryBean</span><br><span class="line">      /**</span><br><span class="line">      下面两句是核心</span><br><span class="line">          1、设置构造方法中的Class属性为接口的类属性，这样的话最后生成的Bean是Mapper接口的实现类</span><br><span class="line">          2、设置Bean的类型为MapperFactoryBean的类型，这样创建Bean的时候就会调用MapperFactoryBean的getObject方法创建对象</span><br><span class="line">      */</span><br><span class="line">      definition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); // issue #59</span><br><span class="line">      definition.setBeanClass(this.mapperFactoryBean.getClass());</span><br><span class="line"></span><br><span class="line">      definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);</span><br><span class="line"></span><br><span class="line">      boolean explicitFactoryUsed = false;</span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = true;</span><br><span class="line">      &#125; else if (this.sqlSessionFactory != null) &#123;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = true;</span><br><span class="line">      &#125; else if (this.sqlSessionTemplate != null) &#123;</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!explicitFactoryUsed) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Enabling autowire by type for MapperFactoryBean with name &apos;&quot; + holder.getBeanName() + &quot;&apos;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很长，但是主要的就是中间那两句代码！第一句是设置产生的Bean的类型，通过构造方法传入；第二句是设置BD的类型为FactoryBean，这样才能在创建Bean的时候调用getObject方法<br>这样一来，Spring-Mybatis在getObject方法中，通过动态代理为Mapper接口创建代理对象，产生一个可操作的Bean，创建代理对象的过程以后再讨论。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们的@MapperScan注解，会引入MapperScannerRegistrar类，这个类实现了ImportBeanDefinitionRegistrar的底层Spring接口，这个接口可以手动的向Spring注册BD，Spring使用这个BD创建Bean。<br>但是在注册BD之前mybatis把BD的属性设置为MapperFactoryBean，MapperFactoryBean实现了Spring底层的FactoryBean，FactoryBean可以指定生成什么样的Bean。所以MapperFactoryBean的getObject方法中，通过传入接口的属性，使用动态代理技术创建一个实现了Mapper接口的代理对象</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/详解SpringMVC/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/详解SpringMVC/" itemprop="url">详解SpringMVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T15:06:13+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringMVC的本质"><a href="#SpringMVC的本质" class="headerlink" title="SpringMVC的本质"></a>SpringMVC的本质</h1><p>SpringMVC本质只是一个Servlet，Servlet的运行需要Servlet容器，常见的容器有Tomcat跟Jetty。Servlet的运行会调用一次init()跟一次destory()方法，用于初始化Servlet跟销毁Servlet。SpringMVC利用init()方法创建WebApplication的运行环境。（此时的WebApplication只是ServletWebApplicationContext，存储Controller、ViewResolver、HandlerMapping等）<br>所以SpringMVC的运行需要Servlet-api，而Servlet如Tomcat或者Jetty容器已经依赖了Servlet-api（如果是开发时使用插件形式，比如使用Tomcat插件，就需要手动引入）</p>
<h1 id="SpringMVC的前身——Servlet"><a href="#SpringMVC的前身——Servlet" class="headerlink" title="SpringMVC的前身——Servlet"></a>SpringMVC的前身——Servlet</h1><p>*注：下面关于Servlet来自一篇推文：<a href="https://mp.weixin.qq.com/s__biz=MzA4MjIyNTY0MQ==&amp;mid=2647739557&amp;idx=1&amp;sn=ffd844a61c842fdc6551a2e9d4dbaab9&amp;key=3ced8d6e9f21461a1452cf26cf0e495b3ba44084c1c66b8e318a5039b4502e115714558bdf8f1a95094fbe9bf322e08b5d5f62b091a46fa4293fa17528a4a855794f08c29486fd6fac84f294b5c19a34&amp;ascene=1&amp;uin=MTEyMjk5MTQyMw%3D%3D&amp;devicetype=Windows+10&amp;version=62060728&amp;lang=zh_CN&amp;pass_ticket=TONBS%2FY8dLqbPKMCi6vH0pFR1i222o7yZyVAlvO7Ve6%2BzCA0TO5GtC6Q69c5hJqf" target="_blank" rel="noopener">https://mp.weixin.qq.com/s__biz=MzA4MjIyNTY0MQ==&amp;mid=2647739557&amp;idx=1&amp;sn=ffd844a61c842fdc6551a2e9d4dbaab9&amp;key=3ced8d6e9f21461a1452cf26cf0e495b3ba44084c1c66b8e318a5039b4502e115714558bdf8f1a95094fbe9bf322e08b5d5f62b091a46fa4293fa17528a4a855794f08c29486fd6fac84f294b5c19a34&amp;ascene=1&amp;uin=MTEyMjk5MTQyMw%3D%3D&amp;devicetype=Windows+10&amp;version=62060728&amp;lang=zh_CN&amp;pass_ticket=TONBS%2FY8dLqbPKMCi6vH0pFR1i222o7yZyVAlvO7Ve6%2BzCA0TO5GtC6Q69c5hJqf</a></p>
<p>SpringMVC之前，就是Servlet。Spring MVC 是基于 Servlet 实现的。所以要分析 Spring MVC，首先应追根溯源，弄懂 Servlet。Servlet 是 J2EE 规范之一，在遵守该规范的前提下，我们可将 Web 应用部署在 Servlet 容器下。这样做的好处是什么呢？我觉得可使开发者聚焦业务逻辑，而不用去关心 HTTP 协议方面的事情。比如，普通的 HTTP 请求就是一段有格式的文本，服务器需要去解析这段文本才能知道用户请求的内容是什么。如果我们为了写一个 Web 应用，还要去解析 HTTP 协议相关的内容，那会增加很多工作量。</p>
<p>如果我们写的 Web 应用不大，不夸张的说，项目中对 HTTP 提供支持的代码会比业务代码还要多，这岂不是得不偿失。当然，在现实中，有现成的框架可用，并不需要自己造轮子。如果我们基于 Servlet 规范实现 Web 应用的话，HTTP 协议的处理过程就不需要我们参与了。这些工作交给 Servlet 容器就行了，我们只需要关心业务逻辑怎么实现即可。<br>Servlet的具体就是交给Servlet接口、ServletConfig、GenericServlet、HttpServlet这些类中实现，等有时间再详解。</p>
<h1 id="运行SpringMVC的前期准备"><a href="#运行SpringMVC的前期准备" class="headerlink" title="运行SpringMVC的前期准备"></a>运行SpringMVC的前期准备</h1><p>SpringMVC要运行需要Servlet，这里我们使用Tomcat插件作为Servlet容器，先引入Servlet的api,虽然Servlet-api在Tomcat插件呢中已经存在，但是SpringMVC在编译时需要Servlet-api的存在，不然编译不通过<br>哦对，在这之前需要引入Spring的包有context,web,webmvc 下面会说这几个包的作用<br>完整的pom.xml如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.demo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lnw-spring-mvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;lnw-spring-mvc Maven Webapp&lt;/name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project&apos;s website --&gt;</span><br><span class="line">    &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">		&lt;!--引入Servlet-api，然后scope设置为provided，表示编译时存在，运行时可去除</span><br><span class="line">		因为Tomcat中已经有Servlet-api了，运行时使用Tomcat里面的Servelt-Api就可以了--&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;lnw-spring-mvc&lt;/finalName&gt;</span><br><span class="line">        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">            &lt;plugins&gt;</span><br><span class="line">				&lt;!--添加Tomcat插件，设置路径和端口--&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">                    &lt;configuration&gt;</span><br><span class="line">                        &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">                        &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">                    &lt;/configuration&gt;</span><br><span class="line">                &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/plugins&gt;</span><br><span class="line">        &lt;/pluginManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong> 引入的Servlet-api需要设置scope为provide表示编译时存在，运行时去除 </strong><br>Servlet容器跟依赖包都有了，接下来就是要让SpringMVC整合到Tomcat中<br>以前都是在web.xml配置，因为你Tomcat启动时会读取web.xml中的配置来启动加载SpringMVC的DispatcherServlet，但我这里想用java-config来配置，因为java-config配置更加直观一点（个人观点）<br>我们用一个MyWebApplicationInitializer类表示一个web.xml配置，用AppConfig类来配置Spring<br>我的理解是MyWebApplicationInitializer可以让Tomcat发现SpringMVC的存在并注册DispatcherServlet，AppConfig可以配置Spring的容器以及其他Spring属性</p>
<p>MyWebApplicationInitializer.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.demo.config;</span><br><span class="line">import org.springframework.web.WebApplicationInitializer;</span><br><span class="line">import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;</span><br><span class="line">import org.springframework.web.servlet.DispatcherServlet;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletRegistration;</span><br><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext servletCxt) &#123;</span><br><span class="line">        System.out.println(&quot;------init------&quot;);</span><br><span class="line">        // Load Spring web application configuration</span><br><span class="line">        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        // 注册Spring的配置类</span><br><span class="line">        ac.register(AppConfig.class);</span><br><span class="line">        // ac.refresh();</span><br><span class="line">        // Create and register the DispatcherServlet</span><br><span class="line">        DispatcherServlet servlet = new DispatcherServlet(ac);</span><br><span class="line">        ServletRegistration.Dynamic registration = servletCxt.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">        registration.setLoadOnStartup(1);</span><br><span class="line">        registration.addMapping(&quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/12/详解SpringMVC/20190212115408186.png" alt=""><br>这里的ac.refresh()之所以要注释掉，因为此时容器中还没有ServletContext，因为还没有将Tomcat容器中的ServletContext注入到Spring容器中，而SpringMVC中的有些组件需要ServletContext才能进行创建，如果此时没有ServletContext，在调用refresh时就会出现错误，显示“No ServletContext set”，比如resourceHandlerMapping这个Bean，在创建的时候就会进行断言<br>ServletContext的传入，在FrameworkServlet中，还没调用refresh前<br><img src="/2019/02/12/详解SpringMVC/20190213125005726.png" alt=""><br><img src="/2019/02/12/详解SpringMVC/20190213123002392.png" alt=""><br>只有设置了ServletContext，断言的时候才不会报错，如果没有把自己手写的ac.refresh注释掉，因为容器中没有ServletContext，项目时运行不了的<br>只有执行完FrameworkServlet里的initWebApplicationContext，设置了ServletContext，才能将SpringMVC进行刷新</p>
<ul>
<li>注：ServletContext 代表一个程序的应用，管理我们的Servlet，而且所有的Servlet都可以共享这个Context<br><img src="/2019/02/12/详解SpringMVC/20190213125530145.png" alt=""><br><img src="/2019/02/12/详解SpringMVC/20190213125703302.png" alt=""></li>
</ul>
<p>还有，我已经在一篇博客中讲过SpringMVC是怎么随着Tomcat中启动的，有兴趣可以去看下，为什么配置了一个MyWebApplicationInitializer，该类只是实现了WebApplicationInitializer就可以随着Tomcat启动（很有趣的哦）</p>
<p>AppConfig.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.lnw&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class AppConfig&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppConfig类就只是一个普通的Spring配置类，标明扫描包的路径，开启SpringMVC的注解</p>
<h2 id="这里为什么要加-EnableWebMVC注解呢？"><a href="#这里为什么要加-EnableWebMVC注解呢？" class="headerlink" title="这里为什么要加@EnableWebMVC注解呢？"></a>这里为什么要加@EnableWebMVC注解呢？</h2><p>这个问题很重要！<br>加上@EnableWebMVC注解，会在Spring容器中引入一个DelegatingWebMvcConfiguration类，这个类又继承自WebMvcConfigurationSupport类<br>WebMvcConfigurationSupport里面配置了需要SpringMVC的许多默认选项，比如SpringMVC的九大组件，大多都是在这个类中默认配置（除了文件上传的那个组件好像没有默认配置）<br>WebMvcConfigurationSupport类里面配置了很多SpringMVC许多组件默认的Bean，截取相关代码<br>WebMvcConfigurationSupport.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   @Bean</span><br><span class="line">public BeanNameUrlHandlerMapping beanNameHandlerMapping() &#123;</span><br><span class="line">	BeanNameUrlHandlerMapping mapping = new BeanNameUrlHandlerMapping();</span><br><span class="line">	mapping.setOrder(2);</span><br><span class="line">	mapping.setInterceptors(getInterceptors());</span><br><span class="line">	mapping.setCorsConfigurations(getCorsConfigurations());</span><br><span class="line">	return mapping;</span><br><span class="line">&#125;</span><br><span class="line">   @Bean</span><br><span class="line">public ViewResolver mvcViewResolver() &#123;</span><br><span class="line">	ViewResolverRegistry registry = new ViewResolverRegistry(</span><br><span class="line">			mvcContentNegotiationManager(), this.applicationContext);</span><br><span class="line">	configureViewResolvers(registry);</span><br><span class="line"></span><br><span class="line">	if (registry.getViewResolvers().isEmpty() &amp;&amp; this.applicationContext != null) &#123;</span><br><span class="line">		String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">				this.applicationContext, ViewResolver.class, true, false);</span><br><span class="line">		if (names.length == 1) &#123;</span><br><span class="line">			registry.getViewResolvers().add(new InternalResourceViewResolver());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ViewResolverComposite composite = new ViewResolverComposite();</span><br><span class="line">	composite.setOrder(registry.getOrder());</span><br><span class="line">	composite.setViewResolvers(registry.getViewResolvers());</span><br><span class="line">	if (this.applicationContext != null) &#123;</span><br><span class="line">		composite.setApplicationContext(this.applicationContext);</span><br><span class="line">	&#125;</span><br><span class="line">	if (this.servletContext != null) &#123;</span><br><span class="line">		composite.setServletContext(this.servletContext);</span><br><span class="line">	&#125;</span><br><span class="line">	return composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说，加了@EnableWebMVC的注解，引入WebMVCConfigurationSupport类，创建配置类，Spring容器中就会有了许多SpringMVC组件的默认配置的Bean，然后在SpringMVC的DispatcherServlet中，需要组件初始化的时候就可以从Spring容器中获取这些默认的Bean</p>
<p>这样一来，运行添加的Tomcat插件（Tomcat版本最高为7…) ，就可顺利运行SpringMVC项目<br>如果想配置SpringMVC的其他属性，比如静态资源，模板引擎，文件上传的大小..<br>需要声明一个配置类，实现WebMvcConfigurer类，重写里面的方法即可</p>
<h1 id="SpringMVC运行的初始化"><a href="#SpringMVC运行的初始化" class="headerlink" title="SpringMVC运行的初始化"></a>SpringMVC运行的初始化</h1><p>SpringMVC的运行，离不开九大组件，而且SpringMVC的本质就是一个Servlet，所以在Tomcat启动的时候就会调用Init方法对Servlet的方法进行初始化<br>这里就要说一下SpringMVC的三个Servlet<br><img src="/2019/02/12/详解SpringMVC/20190213115117039.png" alt=""><br>红线上部分是Servlet的类，下部分是SpringMVC的三个Servlet（哎，反正就是一个Servlet）<br>所以注册Servlet的时候就会调用Servlet的init方法</p>
<h2 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h2><p>先执行HTTPServletBean的init方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * init()中，首先将Servlet中的配置参数使用BeanWrapper设置到DispatcherServlet的相关属性</span><br><span class="line">	 * 然后调用模板方法initServletBean()初始化</span><br><span class="line">	 */</span><br><span class="line">	public final void init() throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">		// 将Servlet中的配置参数封装到pvs中</span><br><span class="line">		// Set bean properties from init parameters.</span><br><span class="line">		PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);</span><br><span class="line">		if (!pvs.isEmpty()) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				// bw为DispatcherServlet</span><br><span class="line">				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);</span><br><span class="line">				ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());</span><br><span class="line">				bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">				// 模板方法，可以在子类调用，做一些初始化工作，bw就是DispatcherServlet，</span><br><span class="line">				// 也就是初始化DispatcherServlet</span><br><span class="line">				initBeanWrapper(bw);</span><br><span class="line">				// 将配置的初始值（如contextConfigLocation)设置到DispaterServlet</span><br><span class="line">				bw.setPropertyValues(pvs, true);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (BeansException ex) &#123;</span><br><span class="line">				if (logger.isErrorEnabled()) &#123;</span><br><span class="line">					logger.error(&quot;Failed to set bean properties on servlet &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				throw ex;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Let subclasses do whatever initialization they like.</span><br><span class="line">		// 一般都是FrameWorkServlet的初始化入口</span><br><span class="line">		initServletBean();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>然后调用FrameworkServlet的<strong> initServletBean </strong> 方法，但是<strong> initServlet </strong> 方法中，又调用<strong> initWebApplicationContext（）</strong> 方法初始化容器，所以FrameworkServlet的关键初始话方法就是<strong> initWebApplicationContext() </strong> 方法了<br>org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext initWebApplicationContext() &#123;</span><br><span class="line">		/*----------------------------------------------------------*/</span><br><span class="line">		// initWebApplicationContext方法主要做了三件事：</span><br><span class="line">			// 1、获取spring的根容器rootContext</span><br><span class="line">			// 2、设置webApplicationContext并根据情况调用refresh方法</span><br><span class="line">			// 3、将webApplicationContext设置到Servlet中</span><br><span class="line">		/*----------------------------------------------------------*/</span><br><span class="line"></span><br><span class="line">		// 1</span><br><span class="line">		WebApplicationContext rootContext =</span><br><span class="line">				WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">		WebApplicationContext wac = null;</span><br><span class="line"></span><br><span class="line">		if (this.webApplicationContext != null) &#123;</span><br><span class="line">			// A context instance was injected at construction time -&gt; use it</span><br><span class="line">			wac = this.webApplicationContext;</span><br><span class="line">			if (wac instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">				ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">				if (!cwac.isActive()) &#123;</span><br><span class="line">					// The context has not yet been refreshed -&gt; provide services such as</span><br><span class="line">					// setting the parent context, setting the application context id, etc</span><br><span class="line">					if (cwac.getParent() == null) &#123;</span><br><span class="line">						// The context instance was injected without an explicit parent -&gt; set</span><br><span class="line">						// the root application context (if any; may be null) as the parent</span><br><span class="line">						cwac.setParent(rootContext);</span><br><span class="line">					&#125;</span><br><span class="line">					// 2</span><br><span class="line">					configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (wac == null) &#123;</span><br><span class="line">			// No context instance was injected at construction time -&gt; see if one</span><br><span class="line">			// has been registered in the servlet context. If one exists, it is assumed</span><br><span class="line">			// that the parent context (if any) has already been set and that the</span><br><span class="line">			// user has performed any initialization such as setting the context id</span><br><span class="line">			wac = findWebApplicationContext();</span><br><span class="line">		&#125;</span><br><span class="line">		if (wac == null) &#123;</span><br><span class="line">			// No context instance is defined for this servlet -&gt; create a local one</span><br><span class="line">			wac = createWebApplicationContext(rootContext);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!this.refreshEventReceived) &#123;</span><br><span class="line">			// Either the context is not a ConfigurableApplicationContext with refresh</span><br><span class="line">			// support or the context injected at construction time had already been</span><br><span class="line">			// refreshed -&gt; trigger initial onRefresh manually here.</span><br><span class="line">			synchronized (this.onRefreshMonitor) &#123;</span><br><span class="line">				//2</span><br><span class="line">				onRefresh(wac);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (this.publishContext) &#123;</span><br><span class="line">			// 3</span><br><span class="line">			// Publish the context as a servlet context attribute.</span><br><span class="line">			String attrName = getServletContextAttributeName();</span><br><span class="line">			getServletContext().setAttribute(attrName, wac);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return wac;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>webApplicationContext在我们的配置类中已经注册给DispatcherServlet，DispatcherServlet又把WebApplication交给FrameworkServlet，所以这里会执行<strong> configureAndRefreshWebApplicationContext(cwac) </strong> 方法<br>如果没有webApplicationContext则SpringMVC自己创建createWebApplicationContext()，内部也是调用configureAndRefreshWebApplicationContext方法</p>
<p>org.springframework.web.servlet.FrameworkServlet#configureAndRefreshWebApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) &#123;</span><br><span class="line">		if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">			// The application context id is still set to its original default value</span><br><span class="line">			// -&gt; assign a more useful id based on available information</span><br><span class="line">			if (this.contextId != null) &#123;</span><br><span class="line">				wac.setId(this.contextId);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// Generate default id...</span><br><span class="line">				wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">						ObjectUtils.getDisplayString(getServletContext().getContextPath()) + &apos;/&apos; + getServletName());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 设置ServletContext容器，这很重要，九大组件的创建需要ServletContext</span><br><span class="line">		wac.setServletContext(getServletContext());</span><br><span class="line">		// 设置ServletConfig</span><br><span class="line">		wac.setServletConfig(getServletConfig());</span><br><span class="line">		wac.setNamespace(getNamespace());</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 这里添加了一个监听器，这个监听器很重要</span><br><span class="line">		 * 监听的是ContextRefreshListener事件，也就是容器刷新时的事件</span><br><span class="line">		 * 当发生刷新容器事件时，会调用FrameworkServlet的onApplicationEvent方法</span><br><span class="line">		 * 该方法里面就会调用onRefresh（）进行初始化九大组件</span><br><span class="line">		 */</span><br><span class="line">		wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">		// The wac environment&apos;s #initPropertySources will be called in any case when the context</span><br><span class="line">		// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span><br><span class="line">		// use in any post-processing or initialization that occurs below prior to #refresh</span><br><span class="line">		ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">		if (env instanceof ConfigurableWebEnvironment) &#123;</span><br><span class="line">			((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		postProcessWebApplicationContext(wac);</span><br><span class="line">		applyInitializers(wac);</span><br><span class="line">		// 刷新容器</span><br><span class="line">		wac.refresh();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里最重要的就是添加了ContextRefreshListener监听器，这个监听器很重要，在代码的最后调用<strong> wac.refresh </strong> 刷新后，会执行这个ContextRefreshListener监听器触发事件<br>ContextRefreshListener是Framework的内部类里面只有一段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">			FrameworkServlet.this.onApplicationEvent(event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>onApplicationEvent方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">		this.refreshEventReceived = true;</span><br><span class="line">		synchronized (this.onRefreshMonitor) &#123;</span><br><span class="line">			onRefresh(event.getApplicationContext());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是当发生容器的刷新时，最后会执行<strong> onRefresh </strong> 方法，该方法在DispatcherServlet具体实现</p>
<ul>
<li>注：wac.refresh() 方法就是Spring-Context的知识，也就是IOC，Bean的生成管理等，这里不深入阐述<br>来看下DispatcherServlet</li>
</ul>
<h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>上面说到当发生刷新容器的事件时，会调用<strong> onRefresh </strong> 方法，该方法在DispatcherServlet中具体实现，而里面只是调用了<strong> initStrategies </strong> 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected void onRefresh(ApplicationContext context) &#123;</span><br><span class="line">		// 只执行了initStrategies方法</span><br><span class="line">		initStrategies(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected void initStrategies(ApplicationContext context) &#123;</span><br><span class="line">		// 初始化MultipartResolver组件</span><br><span class="line">		// 该组件是用来处理上传文件请求，只是没有默认实现</span><br><span class="line">		initMultipartResolver(context);</span><br><span class="line">		// 初始化LocaleResolver</span><br><span class="line">		// 该组件的作用是可以通过request解析出Locale，Locale是对当前区域的声明</span><br><span class="line">		initLocaleResolver(context);</span><br><span class="line">		// 初始化ThemeResolver</span><br><span class="line">		// 该组件的作用是可以通过request解析出Theme主题</span><br><span class="line">		initThemeResolver(context);</span><br><span class="line">		// 初始化HandlerMapping组件</span><br><span class="line">		// 该组件的作用是存储URL跟Controller之间的映射</span><br><span class="line">		initHandlerMappings(context);</span><br><span class="line">		// 初始化HandlerAdapters</span><br><span class="line">		// 该组件的作用是可以用Handler（Controller）执行请求</span><br><span class="line">		initHandlerAdapters(context);</span><br><span class="line">		// 初始化HandlerExceptionResolvers组件</span><br><span class="line">		// 该组件的作用是对页面渲染前的异常进行处理。然后渲染在View里面</span><br><span class="line">		initHandlerExceptionResolvers(context);</span><br><span class="line">		// 初始化RequestToViewNamTranslator组件</span><br><span class="line">		// 该组件的作用是，如果Controller没有返回值，则通过request确定ViewName值,然后查询View</span><br><span class="line">		initRequestToViewNameTranslator(context);</span><br><span class="line">		// 初始化ViewResolvers组件</span><br><span class="line">		// 该组件的作用是将String类型的视图名和Locale解析为View类型的视图</span><br><span class="line">		initViewResolvers(context);</span><br><span class="line">		// 初始化FlashMapManager组件</span><br><span class="line">		// 该组件的作用是用于管理FlashMap的</span><br><span class="line">		initFlashMapManager(context);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，SpringMVC的初始化就到这了，下面来看下当一个请求过来时，SpringMVC是怎么工作的</p>
<h1 id="SpringMVC对请求的处理过程"><a href="#SpringMVC对请求的处理过程" class="headerlink" title="SpringMVC对请求的处理过程"></a>SpringMVC对请求的处理过程</h1><p>我们事先写一个Controller<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class IndexController &#123;</span><br><span class="line">    @GetMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;Hello Tomcat!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来具体跟踪一下，当我们输入请求localhost:8080/hello，SpringMVC里面是怎么处理的</p>
<h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><p>首先，请求会先到达Tomcat，Tomcat会分配一个Socket线程来连接它，接着封装request和response，然后交给具体的Servlet，这里就是使用我们的DispatcherServlet，所以请求就从Servlet容器（Tomcat）传递到Servlet     （发生在：Servlet容器）</p>
<h2 id="2、"><a href="#2、" class="headerlink" title="2、"></a>2、</h2><p>接着，HttpServlet先处理，在service方法中，将ServletRequest和ServletResponse转换成HttpServletRequest和HttpServletResponse，并调用service方法  （发生在：Servlet-api的HttpServlet中）</p>
<h2 id="3、"><a href="#3、" class="headerlink" title="3、"></a>3、</h2><p>接下来SpringMVC出场了，FrameworkServlet的service首先处理，但是，service方法又会将请求先交给HttpServlet的service处理  （发生在：FrameworkServlet）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * 实现了HttpServlet的service方法</span><br><span class="line">	 * 不管是什么请求，最后都会走processRequest方法</span><br><span class="line">	 * Override the parent class implementation in order to intercept PATCH requests.</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	protected void service(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		// 添加了对PATCH请求的处理</span><br><span class="line">		HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">		if (httpMethod == HttpMethod.PATCH || httpMethod == null) &#123;</span><br><span class="line">			processRequest(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		// 其他类型全部交给父类处理，也就是交给HttpServlet处理</span><br><span class="line">		// 但是由于FrameworkServlet重写了get，post，put等请求方法，最后还是会调用该类的</span><br><span class="line">		// 其他请求方法比如doGet()</span><br><span class="line">		else &#123;</span><br><span class="line">			super.service(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		// 反正不管是什么方法，最后都会走processRequest方法</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4、"><a href="#4、" class="headerlink" title="4、"></a>4、</h2><p>在HttpServlet的service方法中，会根据请求的类型将请求传递到doGet方法  （发生在：HttpServlet中）</p>
<h2 id="5、"><a href="#5、" class="headerlink" title="5、"></a>5、</h2><p>由于FrameworkServlet实现了doGet方法，所以请求又回到了FrameworkServlet中，而doGet方法中只调用了<strong> processRequest </strong> 方法。这里需要说明一下，几乎所有的请求都会交给<strong> processRequest </strong> 方法处理<br>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	protected final void doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	protected final void doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		processRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p><strong> processRequest </strong> 里面有调用 <strong> doService </strong> 方法，该方法在DispatcherServlet中具体实现，也就是说最后将请求交给了DispatcherServlet （发生在FrameworkServlet中）</p>
<h2 id="6、"><a href="#6、" class="headerlink" title="6、"></a>6、</h2><p>DispatcherServlet的doService方法将webApplicationContext、localeResolver、themeResolver、outputFlashMap和FlashMapManager设置到了request属性中，然后将请求交给doDispatch方法中  （发生在：DispatcherServlet）<br>org.springframework.web.servlet.DispatcherServlet#doService<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		logRequest(request);</span><br><span class="line">		// 对include请求，进行request的attribute做快照备份</span><br><span class="line">		Map&lt;String, Object&gt; attributesSnapshot = null;</span><br><span class="line">		if (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">			attributesSnapshot = new HashMap&lt;&gt;();</span><br><span class="line">			Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">			while (attrNames.hasMoreElements()) &#123;</span><br><span class="line">				String attrName = (String) attrNames.nextElement();</span><br><span class="line">				if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">					attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// 对request设置一些属性，在handler和view中需要使用到</span><br><span class="line">		// Make framework objects available to handlers and view objects.</span><br><span class="line">		request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">		request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);</span><br><span class="line">		request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);</span><br><span class="line">		request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line">		if (this.flashMapManager != null) &#123;</span><br><span class="line">			// 都跟FlashMap 有关，主要作用域redirect转发时参数的传递</span><br><span class="line">			// 应用场景：</span><br><span class="line">			// 			当你提交完订单后，需要重定向到一个页面，但是重定向无法传递参数过去</span><br><span class="line">			//			这时，你可以使用FlashMap帮助你完成参数的传递</span><br><span class="line"></span><br><span class="line">			// 每次处理请求时，都会先判断一下FlashMap中是否有数据</span><br><span class="line">			// 如果有就先设置到 inputFlashMap里面，也就是保存上次转发过来的属性</span><br><span class="line">			// 再设置到Model里面</span><br><span class="line">			FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">			if (inputFlashMap != null) &#123;</span><br><span class="line">				request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">			&#125;</span><br><span class="line">			// OUTPUT_FLASH_MAP_ATTRIBUTE用于保存本次请求需要转发的属性</span><br><span class="line">			request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());</span><br><span class="line">			request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			// 最后将请求交给doDispatch</span><br><span class="line">			doDispatch(request, response);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				// Restore the original attribute snapshot, in case of an include.</span><br><span class="line">				// 还原request的快照属性</span><br><span class="line">				if (attributesSnapshot != null) &#123;</span><br><span class="line">					restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7、"><a href="#7、" class="headerlink" title="7、"></a>7、</h2><p>doDispatch是DispatcherServlet中最重要的方法，里面有很多判断和操作，但是主要有四个功能。在此之前先说下Handler、HandlerMapping跟HandlerAdapter三者之间的关系，还有View跟ViewResolver</p>
<h3 id="Handler、HandlerMapping跟HandlerAdapter"><a href="#Handler、HandlerMapping跟HandlerAdapter" class="headerlink" title="Handler、HandlerMapping跟HandlerAdapter"></a>Handler、HandlerMapping跟HandlerAdapter</h3><p>Handler：就是我们编写的Controller控制器<br>HandlerMapping：可以用来速查Handler，可以根据request返回HandlerExecutionChain，HandlerExecutionChain里面包含Handler跟Interceptor<br>HandlerAdapter：当要执行我们的Controller时，SpringMVC就会使用HandlerAdapter来执行，调用handle方法，执行完返回ModelAndView<br>我们可以这样理解，Handler就是工具，可以用来做某件事；HandlerMapping是存放工具的清单，标明了工具放在哪里；HandlerAdapter就是使用工具干活的工人。</p>
<h3 id="View跟ViewResolver"><a href="#View跟ViewResolver" class="headerlink" title="View跟ViewResolver"></a>View跟ViewResolver</h3><p>View是用来展示数据的<br>ViewResolver是用来查找View的<br>做完请求工作后，需要返回结果，而返回结果就需要模板，View就是所需的模板，ViewResolver就是用来选择哪个模板</p>
<p>这四个功能分别为：一、使用HandlerMapping找到可以干活的Handler； 二、找到合适的HandlerAdapter让他去干活； 三、让HandlerAdapter开始干活，干完活后返回数据； 四、将返回的数据进行处理，封装成View展示给用户<br>先来看下doDispatch方法的代码，具体代码再分析<br>org.springframework.web.servlet.DispatcherServlet#doDispatch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		/**</span><br><span class="line">		 *</span><br><span class="line">		 *   doDispatch中最重要的代码总共有四句（见下面的标签数字）</span><br><span class="line">		 *</span><br><span class="line">		 *   Handler、HandlerMapping、HandlerAdapter三者的关系：</span><br><span class="line">		 *   	Handler：就是我们的控制器Controller中加了@XXXMapping的方法</span><br><span class="line">		 *   	HandlerMapping：	用来快速查找Handler</span><br><span class="line">		 *   	HandlerAdapter：调用Handler来干活，而且不同Handler需要不同的Adapter</span><br><span class="line">		 *   这就好比HandlerAdapter是工人，Handler是工具，HandlerMapping是根据加工的需求来选择用什么设备</span><br><span class="line">		 */</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 封装Request，如果不是上传请求则直接使用接收到的request</span><br><span class="line">		 * 如果是上传请求，重新封装成MultipartHttpServletRequest</span><br><span class="line">		 */</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		/**</span><br><span class="line">		 * 处理请求的处理器链</span><br><span class="line">		 * 包含有处理器Handler和对应的拦截器Interceptor</span><br><span class="line">		 */</span><br><span class="line">		HandlerExecutionChain mappedHandler = null;</span><br><span class="line">		/**</span><br><span class="line">		 * 是否为上传请求的标记</span><br><span class="line">		 */</span><br><span class="line">		boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">		/**</span><br><span class="line">		 * 从request中获取异步请求</span><br><span class="line">		 */</span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			/**</span><br><span class="line">			 * View 跟 ViewResolver</span><br><span class="line">			 * View 是用来展示数据的</span><br><span class="line">			 * 而ViewResolver是用来查找View的</span><br><span class="line">			 * 做完请求工作后，需要返回结果，而返回结果就需要模板，</span><br><span class="line">			 * View就是所需要的模板，ViewResolver就是来选择哪个模板</span><br><span class="line">			 *</span><br><span class="line">			 * **/</span><br><span class="line">			ModelAndView mv = null;</span><br><span class="line">			/**</span><br><span class="line">			 * 异常声明</span><br><span class="line">			 * doDispatch()中对异常又两种处理方法：</span><br><span class="line">			 * 		一、如果是处理请求中出现的异常，会捕获并在processDispatchResult中渲染到最后的视图中</span><br><span class="line">			 * 		二、如果是渲染中出现异常，则直接抛出</span><br><span class="line">			 */</span><br><span class="line">			Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				// 检查是不是上传请求</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">				/** 第一句</span><br><span class="line">				 *  使用HandlerMapping找到可以干活的Handler</span><br><span class="line">				 *</span><br><span class="line">				 * **/</span><br><span class="line">				// Determine handler for the current request.</span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				if (mappedHandler == null) &#123;</span><br><span class="line">					// 找不到Handler返回404</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 第二句</span><br><span class="line">				 * 	找到合适的HandlerAdapter去让他干活</span><br><span class="line">				 * **/</span><br><span class="line">				// Determine handler adapter for the current request.</span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// 处理GET、HEAD请求的last-modified</span><br><span class="line">				// Process last-modified header, if supported by the handler.</span><br><span class="line">				/**</span><br><span class="line">				 * Last-Modified是HTTP头部的一种属性，表示当前请求的资源跟上一次请求的资源是否相同</span><br><span class="line">				 * 如果相同，返回304并且没有新的实体（body)返回</span><br><span class="line">				 * 否则返回新的实体内容</span><br><span class="line">				 *</span><br><span class="line">				 * 在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是客户端请求的资源，</span><br><span class="line">				 * 同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。</span><br><span class="line">				 * 客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过</span><br><span class="line">				 * 如果服务器端的资源没有变化，则自动返回 HTTP 304（Not Changed.）状态码，内容为空，这样就节省了传输数据量。</span><br><span class="line">				 * 当服务器端代码发生改变或者重启服务器时，则重新发出资源，</span><br><span class="line">				 * 返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。</span><br><span class="line">				 */</span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">				if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 如果有拦截器，就饿执行我们的拦截器，preHandle前置处理**/</span><br><span class="line">				if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				/** 第三句</span><br><span class="line">				 * 	让HandlerAdapter开始干活，干完活后返回数据</span><br><span class="line">				 * **/</span><br><span class="line">				// Actually invoke the handler.</span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// 如果需要异步处理，则直接返回</span><br><span class="line">				/**</span><br><span class="line">				 * 因为异步处理会重新开启一个线程去执行结果的返回</span><br><span class="line">				 * 不会占用目前这个线程，所以可以直接返回</span><br><span class="line">				 */</span><br><span class="line">				if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 当view为空时（比如，handler返回类型为void），根据request设置默认view</span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line">				/** 执行了拦截器的后置处理 postHandle**/</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				dispatchException = ex;</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Throwable err) &#123;</span><br><span class="line">				// As of 4.3, we&apos;re processing Errors thrown from handler methods as well,</span><br><span class="line">				// making them available for @ExceptionHandler methods and other scenarios.</span><br><span class="line">				dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);</span><br><span class="line">			&#125;</span><br><span class="line">			/** 第四句</span><br><span class="line">			 * 	将数据处理，通过View展示给用户</span><br><span class="line">			 * 	处理结果，包括处理异常，渲染页面，发出完成通知，触发拦截器的afterCompletion</span><br><span class="line">			 * **/</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable err) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">					new NestedServletException(&quot;Handler processing failed&quot;, err));</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			// 判断是否为异步请求</span><br><span class="line">			if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				// 执行异步的拦截器</span><br><span class="line">				// Instead of postHandle and afterCompletion</span><br><span class="line">				if (mappedHandler != null) &#123;</span><br><span class="line">					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				// 删除上传请求的资源，不然会产生临时的资源</span><br><span class="line">				// Clean up any resources used by a multipart request.</span><br><span class="line">				if (multipartRequestParsed) &#123;</span><br><span class="line">					cleanupMultipart(processedRequest);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="8、"><a href="#8、" class="headerlink" title="8、"></a>8、</h2><p>getHandler方法获取Handler的过程，会遍历容器中所有的HandlerMapping，上面说到的WebMVCConfigurationSupport会默认创建RequestMappingHandlerMapping和BeanNameUrlHandlerMapping，在用RequestMappingHandlerMapping匹配时，我们的请求会和其初始化时读取到定义的@RequestMapping(“hello”)所注解里面的内容相匹配，然后根据这个条件找到定义的处理器方法，也就是我们的hello()方法<br> （发生在：RequestMappingHandlerMapping）<br> org.springframework.web.servlet.DispatcherServlet#getHandler<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">	if (this.handlerMappings != null) &#123;</span><br><span class="line">		for (HandlerMapping mapping : this.handlerMappings) &#123;</span><br><span class="line">			HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">			if (handler != null) &#123;</span><br><span class="line">				return handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="9、"><a href="#9、" class="headerlink" title="9、"></a>9、</h2><p> 如果是使用@PathVariable注解，则会使用RequestMappingInfoHandlerMapping里的handleMatch方法会将匹配到的Pattern设置到Request属性中，这里我们没有使用@PathVariable，所以跳过</p>
<h2 id="10、"><a href="#10、" class="headerlink" title="10、"></a>10、</h2><p> 找到Handler后，接着调用getHandlerAdapter方法根据Handler查找HandlerAdapter，也就是根据工具找到工人。查找的方式也是遍历配置的所有HandlerAdapter，然后分别调用他们的supports方法进行检查，判断Handler的类型是否支持。WebMvcConfigrationSupport类默认配置的HandlerAdapter是RequestMappingHandlerAdapter、HttpRequstHandlerAdapter和SimpleControllerHandlerAdapter，最后找到RequestMappingHandlerAdapter （发生在：DispatcherServlet）</p>
<h2 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h2><p> 接下来检查到请求时GET请求，然后检查是否可以使用缓存（我那一大段注释可以看看），因为是第一次请求，所以不使用缓存；接着调用HandlerInterceptor的preHandler方法，这里我们没有配置拦截器，所以跳过。接下来用RequestMappingHandlerAdapter使用Handler处理请求，也就是调用 mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  （发生在：DispatcherServlet中）</p>
<h2 id="12、"><a href="#12、" class="headerlink" title="12、"></a>12、</h2><p> HandlerAdapter的实现一般都很复杂，因为它要封装参数，参数有ModelAttribute，SessionAttributes，FlashMap，Request中的参数等等，所以RequestMappingHandlerAdapter会先将需要的参数封装，这里我们没有设置参数，可省略，接着讲请求传递给invokeHandleMethod方法 （发生在：RequestMappingHandlerAdapter）</p>
<h2 id="13、"><a href="#13、" class="headerlink" title="13、"></a>13、</h2><p>invokeHandleMethod方法首先创建WebDataBinderFactory、ModelFactory和ServletInvocableHandlerMethod。<br>WebDataBinderFactory跟@InitBinder注解的绑定参数有关<br>ModelFactory主要是对Model的初始化和更新<br>ServletInvocableHandlerMethod就是执行请求，参数的绑定<br> 而且，不同类型的参数的解析器是不同的，比如@PathVariable参数、RedirectAttributes参数、Model里的参数分别对应PathVariableMethodArgumentResolver、RedirectAttributeMethodArgumentResolver和ModelMethodProcessor<br> 具体执行在doInvoke中<br> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">protected ModelAndView invokeHandlerMethod(HttpServletRequest request,</span><br><span class="line">		HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	ServletWebRequest webRequest = new ServletWebRequest(request, response);</span><br><span class="line">	try &#123;</span><br><span class="line">		// 需要下面这三个工具</span><br><span class="line">		// WebDataBinderFactory的创建过程是将注解了@InitBinder的方法找出来，并</span><br><span class="line">			// 使用它们新建出ServletRequestDataBinderFactory类型的WebDataBinderFactory</span><br><span class="line">		WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line"></span><br><span class="line">		// ModelFactory主要有两个功能：一、在处理器具体处理前对Model进行初始化</span><br><span class="line">									//二、处理完请求后对Model参数进行更新</span><br><span class="line">		ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">		// 实际请求的处理就是通过它来执行的， 参数的绑定、处理请求以及返回值处理都在它里边完成</span><br><span class="line">		ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line"></span><br><span class="line">		// 将argumentsResolvers、returnValueHandlers、binderFactory</span><br><span class="line">		// paramterNameDiscoverer设置进去invocableMethod中</span><br><span class="line">		if (this.argumentResolvers != null) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.returnValueHandlers != null) &#123;</span><br><span class="line">			invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);</span><br><span class="line">		&#125;</span><br><span class="line">		invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">		invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">		// 新建ModelAndViewContainer容器， 并将相应的参数设置到Model中</span><br><span class="line">		ModelAndViewContainer mavContainer = new ModelAndViewContainer();</span><br><span class="line">		// 设置FlashMap</span><br><span class="line">		mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">		// 使用ModelFactory将SessionAttribute和注释了@ModelAttribute的方法的参数设置到Model</span><br><span class="line">		modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">		//</span><br><span class="line">		mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">		// 异步处理的相关工作</span><br><span class="line">		AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">		asyncWebRequest.setTimeout(this.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">		asyncManager.setTaskExecutor(this.taskExecutor);</span><br><span class="line">		asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">		asyncManager.registerCallableInterceptors(this.callableInterceptors);</span><br><span class="line">		asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line">		if (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">			Object result = asyncManager.getConcurrentResult();</span><br><span class="line">			mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];</span><br><span class="line">			asyncManager.clearConcurrentResult();</span><br><span class="line">			LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">				String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line">				return &quot;Resume with async result [&quot; + formatted + &quot;]&quot;;</span><br><span class="line">			&#125;);</span><br><span class="line">			invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 执行请求</span><br><span class="line">		invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">		if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 处理完请求的后置处理</span><br><span class="line">		return getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">		webRequest.requestCompleted();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="14、"><a href="#14、" class="headerlink" title="14、"></a>14、</h2><p> 当执行完HandlerMethod（也就是执行完我们的Controller代码后），调用getModelAndView方法（我们代码执行完后的数据都设置在ModelAndViewContainer中）<br> 方法中使用ModelAndViewContainer中的Model和View创建ModelAndView，将值返回给DispatcherServlet<br> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getModelAndView<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private ModelAndView getModelAndView(ModelAndViewContainer mavContainer,</span><br><span class="line">		ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	// 更新Model（包括设置SessionAttribute）</span><br><span class="line">	modelFactory.updateModel(webRequest, mavContainer);</span><br><span class="line">	if (mavContainer.isRequestHandled()) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	ModelMap model = mavContainer.getModel();</span><br><span class="line">	// 创建ModelAndView</span><br><span class="line">	ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());</span><br><span class="line">	if (!mavContainer.isViewReference()) &#123;</span><br><span class="line">		mav.setView((View) mavContainer.getView());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 如果是RedirectAttributes（重定向请求）</span><br><span class="line">	// 则将其值设置到FlashMap中</span><br><span class="line">	if (model instanceof RedirectAttributes) &#123;</span><br><span class="line">		Map&lt;String, ?&gt; flashAttributes = ((RedirectAttributes) model).getFlashAttributes();</span><br><span class="line">		HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">		if (request != null) &#123;</span><br><span class="line">			RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> (发生在：RequestMappingHandlerAdapter）</p>
<h2 id="15、"><a href="#15、" class="headerlink" title="15、"></a>15、</h2><p> 然后判断返回的View是否为空，如果为空就使用RequestToViewNameTranslatior查找默认视图，接着调用HandlerInterceptor的后置方法applyPostHandle</p>
<h2 id="16、"><a href="#16、" class="headerlink" title="16、"></a>16、</h2><p> 最后就调用processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); 将结果渲染，里面是调用render方法进行页面的渲染。调用resolveViewName方法解析出View，解析过程使用到了ViewResolver，这里使用的是默认配置InternalResourceViewResolver（它可以处理jsp视图）</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">		@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span><br><span class="line">		@Nullable Exception exception) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">	boolean errorView = false;</span><br><span class="line"></span><br><span class="line">	// 如果处理请求过程中有异常抛出</span><br><span class="line">	if (exception != null) &#123;</span><br><span class="line">		if (exception instanceof ModelAndViewDefiningException) &#123;</span><br><span class="line">			logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);</span><br><span class="line">			mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// 将错误内容设置到View中</span><br><span class="line">			Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);</span><br><span class="line">			mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">			errorView = (mv != null);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Did the handler return a view to render?</span><br><span class="line">	if (mv != null &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * -------------------------------</span><br><span class="line">		 * 渲染页面就是在这个render方法中执行的</span><br><span class="line">		 * -------------------------------</span><br><span class="line">		 */</span><br><span class="line">		render(mv, request, response);</span><br><span class="line">		if (errorView) &#123;</span><br><span class="line">			WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">		// Concurrent handling started during a forward</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (mappedHandler != null) &#123;</span><br><span class="line">		mappedHandler.triggerAfterCompletion(request, response, null);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 至此，SpringMVC的分析到此结束，里面还有很多东西没有说到，比如FlashMap是什么东西，FlashMap是怎么传递和管理的，九大组件各个组件的作用是什么，九大组件的实现类都有哪些..<br> 我们只是讲讲SpringMVC的冰山一角而已</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/SpringMVC的M、V、C到底是什么东西/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/12/SpringMVC的M、V、C到底是什么东西/" itemprop="url">SpringMVC的M、V、C到底是什么东西</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-12T14:44:42+08:00">
                2019-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们Web开发用得最多的框架可能要数SpringMVC了，但一直不是很清楚M、V、C对应SpringMVC里面的什么东西，只知道C就是Controller，就是我们写的逻辑控制器，V就是View，但是View就是指HTML或者JSP这种东西吗？还有M，Model是指我们的POJO类吗？<br>带着这些问题查阅了一些资料，有了一点头绪</p>
<h1 id="MVC三层结构"><a href="#MVC三层结构" class="headerlink" title="MVC三层结构"></a>MVC三层结构</h1><h2 id="What’s-C"><a href="#What’s-C" class="headerlink" title="What’s C ?"></a>What’s C ?</h2><p>没错，C就是Controller，是我们写的逻辑控制器，但在Spring中叫做Handler（处理器），Handler是SpringMVC的C层</p>
<h2 id="What’s-V"><a href="#What’s-V" class="headerlink" title="What’s V ?"></a>What’s V ?</h2><p>V层就是View视图层，SpringMVC把最后要展示给用户的数据+网页封装到View中</p>
<h2 id="What’s-M"><a href="#What’s-M" class="headerlink" title="What’s M ?"></a>What’s M ?</h2><p>M层就是Model层，这层功能和工作很多，它是C层和V层传输数据的桥梁，也就是说它贯穿于Controller层和View层之中，为这两层提供数据。像注视了@ModelAttribute方法、SessionAttribute、FlashMap、Model以及需要执行的方法的参数和返回值都属于这一层，而使用这一层的类有HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler、ModelFactory和FlashMapManager。它是SpringMVC中最复杂的一层，因为一个请求的参数封装有多重形式，比如方法里的参数，注解了@ModelAttribute，@SessionAttribute，还有FlashMap中的参数…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/09/SpringMVC是怎么跟着Tomcat启动的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="SouthLight Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SouthLight's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/09/SpringMVC是怎么跟着Tomcat启动的/" itemprop="url">SpringMVC是怎么跟着Tomcat启动的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-09T23:19:12+08:00">
                2019-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringMVC/" itemprop="url" rel="index">
                    <span itemprop="name">SpringMVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们通过官方文档使用SpringMVC，用Tomcat来跑时，需要配置下面这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.SpringServletContainerInitializer;</span><br><span class="line">import org.springframework.web.WebApplicationInitializer;</span><br><span class="line">import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;</span><br><span class="line">import org.springframework.web.servlet.DispatcherServlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletContainerInitializer;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRegistration;</span><br><span class="line">import javax.servlet.annotation.HandlesTypes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 为什么实现了WebApplicationInitializer就可以被Tomcat所管理？</span><br><span class="line"> * 先看一个注解和一个类</span><br><span class="line"> * @see HandlesTypes</span><br><span class="line"> * @see ServletContainerInitializer</span><br><span class="line"> * 这两个一般成对出现的</span><br><span class="line"> * 在Tomcat启动的时候，会自动去寻找所有实现该接口的类</span><br><span class="line"> * 找到这个类后，里面唯一的实现方法需要一个Set参数</span><br><span class="line"> * 这些参数Tomcat会帮你去找，参数的类型是@HandlesTypes里面的value值</span><br><span class="line"> * Spring在org.springframework.web.SpringServletContainerInitializer中引用该注解并实现ServletContainerInitializer</span><br><span class="line"> * value值就是WebApplicationInitializer</span><br><span class="line"> * @see SpringServletContainerInitializer</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;----init  my ServletContext----&quot;);</span><br><span class="line">		// Load Spring web application configuration</span><br><span class="line">		AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();</span><br><span class="line">		ac.register(AppConfig.class);</span><br><span class="line">		// ac.refresh();</span><br><span class="line"></span><br><span class="line">		// Create and register the DispatcherServlet</span><br><span class="line">		DispatcherServlet servlet = new DispatcherServlet(ac);</span><br><span class="line">		ServletRegistration.Dynamic registration = servletContext.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">		registration.setLoadOnStartup(1);</span><br><span class="line">		registration.addMapping(&quot;/*&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppConfig.class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.lnw.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.lnw&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，当我们整合Tomcat来跑时（一般都是Tomcat插件），就会执行onStartup方法来启动SpringMVC</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>我们看下我们实现的接口WebApplicationInitializr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.web;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">public interface WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Configure the given &#123;@link ServletContext&#125; with any servlets, filters, listeners</span><br><span class="line">	 * context-params and attributes necessary for initializing this web application. See</span><br><span class="line">	 * examples &#123;@linkplain WebApplicationInitializer above&#125;.</span><br><span class="line">	 * @param servletContext the &#123;@code ServletContext&#125; to initialize</span><br><span class="line">	 * @throws ServletException if any call against the given &#123;@code ServletContext&#125;</span><br><span class="line">	 * throws a &#123;@code ServletException&#125;</span><br><span class="line">	 */</span><br><span class="line">	void onStartup(ServletContext servletContext) throws ServletException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现它还是Spring的东西，如果要随着Tomcat启动执行的话，那也得是Servlet或者Tomcat里面的东西吧</p>
<p>我们查看另一个SpringMVC里面的类SpringServletContainerInitializer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.web;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ServiceLoader;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import javax.servlet.ServletContainerInitializer;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.HandlesTypes;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.annotation.AnnotationAwareOrderComparator;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line">import org.springframework.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="line">public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span><br><span class="line">			throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">		List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (webAppInitializerClasses != null) &#123;</span><br><span class="line">			for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">				// Be defensive: Some servlet containers provide us with invalid classes,</span><br><span class="line">				// no matter what @HandlesTypes says...</span><br><span class="line">				if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">						WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						initializers.add((WebApplicationInitializer)</span><br><span class="line">								ReflectionUtils.accessibleConstructor(waiClass).newInstance());</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Throwable ex) &#123;</span><br><span class="line">						throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (initializers.isEmpty()) &#123;</span><br><span class="line">			servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);</span><br><span class="line">		AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">		for (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">			initializer.onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注解@HandlerTypes里面的value值正是我们上面的那个WebApplicationInitializer</p>
<p>下面我们先来说下Tomcat里面的原理</p>
<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>就只说关键部分<br>Tomcat在启动的时候，会配置Context，配置Context需要ContextConfig<br>ContextConfig的核心就是webConfig 方法，下面主要看几条主要的代码<br>org.apache.catalina.startup.ContextConfig#webConfig<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.startup.ContextConfig#webConfig</span><br><span class="line"></span><br><span class="line">// Step 1. 读取各个jar模块和fragments</span><br><span class="line">Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Step 2. 排序fragments</span><br><span class="line">Set&lt;WebXml&gt; orderedFragments = null;</span><br><span class="line">orderedFragments =</span><br><span class="line">	WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">// Step 3. 寻找所有的ServletContainerInitializer实现</span><br><span class="line">// SpringMVC也是基于这个过程开展的</span><br><span class="line">if (ok) &#123;</span><br><span class="line">processServletContainerInitializers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step 4. 处理/WEB-INF/classes文件夹下面的注解了@HandlesTypes</span><br><span class="line">// 这一步很重要</span><br><span class="line">Map&lt;String,JavaClassCacheEntry&gt; javaClassCache = new HashMap&lt;&gt;();</span><br><span class="line">if (ok) &#123;</span><br><span class="line">	WebResource[] webResources =</span><br><span class="line">			context.getResources().listResources(&quot;/WEB-INF/classes&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Step 5. 处理所有的jar中有关的@HandlesTypes</span><br><span class="line">if (ok) &#123;</span><br><span class="line">	processAnnotations(</span><br><span class="line">			orderedFragments, webXml.isMetadataComplete(), javaClassCache);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step 6. 将所有的fragments.xml合并</span><br><span class="line">if (ok) &#123;</span><br><span class="line">	ok = webXml.merge(orderedFragments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Step 7a，将所有的web.xml合并</span><br><span class="line">// merge tomcat-web.xml</span><br><span class="line">webXml.merge(tomcatWebXml);</span><br><span class="line"></span><br><span class="line">。。。</span><br><span class="line"> // Step 11. 将扫描到的所有实现了ServletContainerInitializer类添加到StandardContext容器中</span><br><span class="line">if (ok) &#123;</span><br><span class="line">	for (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">			Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">				initializerClassMap.entrySet()) &#123;</span><br><span class="line">		if (entry.getValue().isEmpty()) &#123;</span><br><span class="line">			context.addServletContainerInitializer(</span><br><span class="line">					entry.getKey(), null);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			context.addServletContainerInitializer(</span><br><span class="line">					entry.getKey(), entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过注释大概可以知道每段代码的作用<br>其中这段代码很重要<strong> processServletContainerInitializers(); </strong><br>还有就是最后的Step 11将扫描到的类添加到Context 中<br>也就是说，Tomcat启动的时候，会使用ClassLoader扫描classes路径下所有的类，找出实现了ServletContainerInitializer类并保存，然后在随后的启动中调用ServletContainerInitializer<br>的onStart方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException;</span><br></pre></td></tr></table></figure></p>
<p>集合Set是存放注解@HandlesTypes中的类，目的是在特定的ServletContainerInitializer中启动的时候做另外的操作</p>
<h1 id="SpringMVC跟Tomcat"><a href="#SpringMVC跟Tomcat" class="headerlink" title="SpringMVC跟Tomcat"></a>SpringMVC跟Tomcat</h1><p>上面我们讲到Tomcat启动的时候会扫描到所有实现了ServletContainerInitializer的类，而我们的SpringServletContainerInitialzer就是SpringMVC跟Tomcat的桥接<br>我们再来看下SpringServletContainerInitializer的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.web;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ServiceLoader;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import javax.servlet.ServletContainerInitializer;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.HandlesTypes;</span><br><span class="line"></span><br><span class="line">import org.springframework.core.annotation.AnnotationAwareOrderComparator;</span><br><span class="line">import org.springframework.lang.Nullable;</span><br><span class="line">import org.springframework.util.ReflectionUtils;</span><br><span class="line"></span><br><span class="line">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="line">public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span><br><span class="line">			throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">		List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		if (webAppInitializerClasses != null) &#123;</span><br><span class="line">			for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">				// Be defensive: Some servlet containers provide us with invalid classes,</span><br><span class="line">				// no matter what @HandlesTypes says...</span><br><span class="line">				if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">						WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						initializers.add((WebApplicationInitializer)</span><br><span class="line">								ReflectionUtils.accessibleConstructor(waiClass).newInstance());</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Throwable ex) &#123;</span><br><span class="line">						throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (initializers.isEmpty()) &#123;</span><br><span class="line">			servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		servletContext.log(initializers.size() + &quot; Spring WebApplicationInitializers detected on classpath&quot;);</span><br><span class="line">		AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">		for (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">			initializer.onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为SpringServletContainerInitializer实现了ServletContainerInitializer，所以会被Tomcat扫描存储到Context，并且因为该类上面注解了@HandlesTypes，里面的value为WebApplicationInitializer.class，所以Tomcat会将实现了WebApplicationInitializer的类扫描出来封装到Set中。<br>Tomcat的启动中，会调用所有的ServletContainerInitializer的onStartup方法来初始化并启动StrandContext容器，所以SpringServletContainerInitiar的onStartup方法就会被调用<br>在org.springframework.web.SpringServletContainerInitializer#onStartup方法中，通过一个for循环启动所有的WebApplicationInitializer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">	initializer.onStartup(servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是这样，执行了SpringMVC官方文档的这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void onStartup(ServletContext servletContext) throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;----init  my ServletContext----&quot;);</span><br><span class="line">		// Load Spring web application configuration</span><br><span class="line">		AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();</span><br><span class="line">		ac.register(AppConfig.class);</span><br><span class="line">		// ac.refresh();</span><br><span class="line"></span><br><span class="line">		// Create and register the DispatcherServlet</span><br><span class="line">		DispatcherServlet servlet = new DispatcherServlet(ac);</span><br><span class="line">		ServletRegistration.Dynamic registration = servletContext.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">		registration.setLoadOnStartup(1);</span><br><span class="line">		registration.addMapping(&quot;/*&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">SouthLight Lin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SouthLight Lin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
